<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GPt-SNE</title>
    <url>/2020/04/27/GPt-SNE/</url>
    <content><![CDATA[<h1 id="GPt-SNE-论文重构与分析"><a href="#GPt-SNE-论文重构与分析" class="headerlink" title="GPt-SNE 论文重构与分析"></a>GPt-SNE 论文重构与分析</h1><h2 id="1-Introduction："><a href="#1-Introduction：" class="headerlink" title="1.Introduction："></a>1.Introduction：</h2><ul>
<li>首先直接指出目前的可视化的作用和目前可视化方法的痛点<ul>
<li>痛点：<ul>
<li>最先进的可视化方法往往是黑盒方法，无法洞察可视化如何编码数据的原始特征</li>
<li>其他方法如Autoencoder和pt-SNE使用复杂神经网络，对人来说依然难以理解</li>
</ul>
</li>
<li>分析：直接指出可视化的痛点，也是一种很好的表达，观点看起来很清晰，之前自己的写作顾虑太多，应该就事论事。其实作者的观点和我是一致的，但是我一没讲清楚，二是不够自信，过多的自我怀疑对工作毫无益处。</li>
</ul>
</li>
<li>接着指出有良好可解释性的线性方法，在降维上固有的局限性：<ul>
<li>痛点：线性方法仅通过对原始特征的线性组合来编码可视化</li>
<li>分析：还是不够自信吧，我们写的太拘谨了，其实我自己写作的时候，就一直在思考为什么不去直接指出线性方法的局限性，我觉得要多坚持自己的想法。</li>
</ul>
</li>
<li>然后介绍基于树的GP（genetic programming）方法，该方法常用于FC（feature construction）中的降维，并且是公认可解释的。最后明确指出，GP方法还并未被用于生成可解释的降维模型即可解释的的可视化。<ul>
<li>分析：觉得自己调研的不够充分，毕竟我都没收集到GP方法。论文写法上来说，我觉得简单直接，我在写作中也要以他为模板，即使技术方案简单也没什么好扭捏的。</li>
</ul>
</li>
<li>接着给出了他们之前的工作GP-MaL（该工作使用GP方法进行降维），并指出了之前工作存在的一些问题。<ul>
<li>分析：这样写，一方面阐述了作者在GP方法上是有底蕴的，让人更相信作者的表达。我觉得我在写作的时候可以多引用作者的论文和表达，体现出我在该研究方向上的理解。</li>
</ul>
</li>
<li>然后给出了论文的技术方案：多目标GP方法。<ul>
<li>分析：Introduction通过前两段才讲清楚问题，但是并没有让人觉得冗余。而我总是追求一句话讲清楚，为了达到这个目标，就在非线性方法的问题和线性方法的问题中做取舍，最后不伦不类，要多反思，不能僵化自己的思维。</li>
</ul>
</li>
<li>最后总结了论文的贡献：<ul>
<li>贡献：<ul>
<li>Propose a holistic set of functions and terminals for creating powerful and interpretable models for visualisation; </li>
<li>Design a multi-objective approach to allow for the evolution of a solution front containing visualisations representing different levels of quality and complexity; </li>
<li>Compare the quality and interpretability of the evolved visualisations with those produced by state-of-the-art visualisation methods on a range of datasets; </li>
<li>Perform an in-depth analysis of the trade-off between visualisation quality and tree complexity to demonstrate the unique advantages of the proposed approach.</li>
</ul>
</li>
<li>分析：我觉得贡献部分写的很平实，我在写贡献部分的时候也要平实，不要故弄玄虚。</li>
</ul>
</li>
</ul>
<h2 id="2-BackGround"><a href="#2-BackGround" class="headerlink" title="2.BackGround"></a>2.BackGround</h2><ul>
<li>Dimensionality Reduction：降维是一种通过减少数据集的特征/属性数量来提高理解和性能的过程，随着数据集变得越来越大，深层神经网络变得越来越不可解释，其重要性也在不断增加。解决这个问题的常用技术包括FS（feature select）和FC，他们分别通过删除不需要的特征或创建更少、更复杂的元特征来减少特征空间。GP方法由于其功能性和可解释性而被证明是一种适合FC问题的方法。流形学习（非线性降维）可以被看作是一种无监督的FC方法，其任务是建立一组表示高维特征空间中存在的非线性流形的特征。实现这一任务的一种方法是尝试构建一个函数，将高维空间映射到低维流形；这种方法可以在两者之间提供可理解的映射。<ul>
<li>分析：首先论文简单介绍了降维的意义和目标。与之相比我写的相关工作太冗余了，全都是已有技术的堆砌，没有紧扣主题且逻辑松散。其次论文对流形学习的介绍，用简单明了的语言就把流形学习的意义和目的讲清楚了。我在写作中要多比对自己和论文的表达。</li>
</ul>
</li>
<li>Machine Learning for Performing Visualisation:该段从机器学习的角度分析了常用的可视化方法，如FS和PCA，存在的局限性（除了简单的低维数据外，线性转换无法清晰地显示数据集中的任何低维流形/结构）。而创建最优非线性变化是一个NP难问题，因此提出了许多基于损失函数的非线性降维方法（ISOMAP，LLE）。最后提到了t-SNE，作者认为这是目前最成功的技术（当然，作者这么写的主要原因是作者的模型基于t-SNE），并对t-SNE进行了较为详细的介绍。<ul>
<li>分析：给我的感觉就是详略得当，既能感受到作者在可视化领域和机器学习领域上的积累，又写的很清爽，让人读起来很轻松。相比之下，我写的东西，要不就是全部都详写，要不就是全部都略写，主要还是自己在相关领域的积累太浅，不能把握文章的重点，要在这方面多花功夫。</li>
</ul>
</li>
<li>Multi-objective Optimisation：这部分主要介绍了MO（Multi-objective Optimisation）方法，当一个问题本质上有两个（或多个）冲突目标时使用的一种技术，在这两个目标之间必须通过问题的解决方案进行权衡。在这种情况下，解决方案的质量通常与其他解决方案的目标函数值有关。而目前最流行的的MO方法就是EC方法，这也是论文所采用的方法。<ul>
<li>分析：我在写作过程中没有了解过MO方法，所以还需要进一步深入。从写作上来说，我觉得讲的还是很清晰的，虽然我看完不知道MO方法的细节实现，但是为什么用MO方法，以及MO方法的目的，以及作者如何实现MO方法都已经了解了。所以我在介绍相对冷门的技术的时，也要这样抓住重点来讲。</li>
</ul>
</li>
<li>Related Work：作者把相关工作分成了两部分，一部分是GP方法在流形学习和可视化上的应用，另一部分介绍了其它与可解释性相关的工作。<ul>
<li>因为作者就是第一个提出将GP方法用于在流形学习，所以这一部分写的非常的自信。其中提到了三个优化目标：可分类性，视觉可解释性，语义可解释性。</li>
<li>介绍了参数t-SNE（参数t-SNE是t-SNE的一种变体，它允许在将来的样本上重用学习到的t-SNE表示。 参数化t-SNE使用受限的Boltzmann机器构造从高维空间到低维空间的映射，以构建预训练的前馈神经网络模型。 该神经网络在最大的数据集上使用了10,000多个神经元，从而严重限制了解释该网络的潜力），Autoencoder（自动编码器[3]是另一种基于神经网络的方法，它试图将数据表示压缩到尽可能小的中间隐藏层中，以便可以从简洁的表示中重新创建原始数据。 为此，自动编码器使用许多大小不同的层来编码和解码数据。 这提供了与学习到的表示之间的映射，但是在给定节点数和完全连接的拓扑的情况下进行解释是不现实的），SOM（是无监督神经网络的一种变体，已用于可视化，但是权重的数量随维度而定，因此它们的可解释性受到非平凡数据集的限制）。并指出论文和已有增强可解释性方法的区别，已有方法（如DimReader）通过更改模型参数或数据实例来分析模型，而论文提出了一种可直接解释的降维模型。</li>
<li>分析：这部分内容可以作为我们解释非线性降维相关工作参考的模板，我们不应该为了分类而分类，要紧扣自己的工作，提出符合逻辑的分类，让读者的关注点一直保持在我们的工作上。通过这段，我们可以发现我们的工作和论文工作的区别，所以我认为我们的工作还是有价值的。</li>
</ul>
</li>
</ul>
<h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3.Method"></a>3.Method</h2><ul>
<li><p>介绍GPt-SNE用于可视化需要解决的技术问题：</p>
<ul>
<li>什么终端和功能节点是合适的</li>
<li>如何构造适应度函数</li>
<li>标准的GP进化过程如何改进</li>
</ul>
</li>
<li><p>GP Architecture：对于每个个体构造两颗GP树，每颗树生成可视化的一个维度（即x轴或y轴）。选择多树表示而不是协作协作进化方法，因为必须紧密耦合（即高度依赖）两棵树才能提供高质量的可视化； 合作协作进化方法倾向于不确定地配对来自不同子种群的解决方案，这大大降低了发生这种耦合的能力。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1587963825918.png" alt="1587963825918"></p>
</li>
<li><p>上表中的Function是功能节点：</p>
<ul>
<li>Arithmetic Function节点通过线性变换来减少输入数目</li>
<li>Non-Linear Function节点给出了两种Sigmoid和ReLU两种激活函数实现非线性变化（作者根据Autoencoder和其他神经网络方法的启发而选择的。（我的观点：神经网络的非线性的确体现在激活函数上））</li>
<li>Conditional Function节点提供了另一种非线性变化，作者认为这种变换由于其不可微性而对GP方法来说是非常独特的，并且期望它们允许一棵树根据其输入表现出不同的行为</li>
</ul>
</li>
<li><p><img src="/2020/04/27/GPt-SNE/1587963903654.png" alt="1587963903654"></p>
<p><img src="/2020/04/27/GPt-SNE/1587963929329.png" alt="1587963929329"></p>
</li>
<li><p>上表中的Terminal是终端节点：数据集中的每个特征都被分配了一个不同的终端，该终端返回给定实例的特征值。</p>
<ul>
<li>$F_i$终端直接返回实例的第$i$个的特征值（虽然这么做为EC搜索过程提供了灵活性，但是确实为大量特征增大了搜索空间。为了解决这个问题，作者使用PCA来选择最重要的特征）</li>
<li>$NF_i$终端给定去噪后的特征值（通常通过求特征值的均值实现）</li>
<li>Constant终端提供一个$[-1,1]$之间的值，以允许树的不同部分对最终输出产生不同的影响</li>
<li>Zero终端仅包含在n+和-功能节点中，因为单独的Zero终端对树没有任何影响。</li>
<li>表2中的LIKEHOOD表示从终端集中选择终端的权重</li>
</ul>
</li>
</ul>
</li>
<li><p>Multi-Objective Approach：在机器学习中，模型的潜在性能与达到该性能所需的复杂性之间存在着内在的联系。例如，分离两个类的最简单模型是一个决策边界，它在空间中的某个点上简单地设置阈值，而对于三个线性可分的类，则至少需要两个阈值。而在可视化中也是如此：可视化的表达越细（具体），用于生成可视化的功能就越复杂。要在二维中重建复杂数据集的高维结构，需要两个非常大且复杂的GP树。从树中移除每个节点都会降低树重现高维概率分布的准确性（在t-SNE的情况下）。作为类比，考虑用GP树演化一个非常复杂的多项式函数：演化函数中的分量（节点）越少，可用于逼近函数的拐点就越少。为此作者使用多目标优化的方法来生成一套解决方案，从而在可视化质量和模型可解释性之间进行权衡。</p>
<ul>
<li><p>分析：作者的GP树，通过自底向上的功能节点计算，最后得到（x|y）轴上的投影。与之对比，他们的降维方法是全局的，而我们的降维方法是局部的。他们的降维方法是非线性的，我们的降维方法是全局非线性，局部线性的。</p>
</li>
<li><p>Objective 1 ：Visualisation Quality</p>
<ul>
<li>论文简要介绍了t-SNE的优化原则以及它的Cost Function。并且使用t-SNE的Cost Function作为第一个优化目标（可视化质量）。</li>
</ul>
</li>
<li><p>Objective 2：Model Complexity</p>
<ul>
<li><p>GP中遇到的一个常见问题是生成膨胀的树，其中GP树比达到给定适应度所需的树大得多。传统场景中，由于对树的规模不做限制，因此树可能包含不必要的复杂子树。</p>
</li>
<li><p>论文计算模型复杂度的公式：<img src="/2020/04/27/GPt-SNE/1587980851820.png" alt="1587980851820"></p>
<p>其中$T$是树，$I$是降维模型，$N_i$是终端节点。</p>
</li>
</ul>
</li>
<li><p>分析：其实我觉得简单直接的方法，在有效的情况下挺好的</p>
</li>
</ul>
</li>
<li><p>Optimisation of Tree Constants：为了进一步提高可视化质量而不引入额外的模型复杂性，论文使用粒子群优化（PSO）[35]在进化过程的最后阶段对每个个体的短暂随机常数（ERC）进行微调。 标准GP无法有效地微调其数字参数（因为它随机搜索参数空间）； 通过采用PSO，论文可以做到这一点。（来自两棵树的）每个ERC都在PSO表示中分配了一个维度，给定维度的值表示给定ERC的值与其原始值相差多少。 论文使用很小范围的初始位置值（[-0.15，0.15]）和较低的最小和最大速度（-0.05和0.05）将PSO搜索集中于微调树中的ERC。 将所有0值（即原始ERC值）初始化为30个粒子之一，以确保PSO搜索不会产生劣等解。  PSO搜索是单目标的（因为树结构是固定的），适应度函数是与GP搜索中的第一个目标相同的代价函数（公式（5））。  PSO仅在GP进化过程的末尾使用，这既是因为其计算成本，又是为了防止GP陷入因进化过程中的微调而导致的局部最小值。</p>
<ul>
<li>分析：这部分提到了一个跟有意思的概念，提高可视化质量而不引入额外的模型复杂性，我要在设计实现方案时多考虑这样的技术。</li>
</ul>
</li>
<li><p>Other Considerrations：这一部分讲述了作者对标准MOEA/D的改动和默认参数的设置。并且作者提到使用多线程技术，和缓存GP树来加快运算。</p>
<ul>
<li>分析：这部分我也在我的技术方案里提到，但我是在技术方案中直接给出的，作者在最后给出这些优化细节，可能更有利于读者理解核心技术。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可理解性</tag>
        <tag>非线性降维</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23</title>
    <url>/2020/04/26/LeetCode-23/</url>
    <content><![CDATA[<h1 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23.合并K个排序链表"></a>LeetCode 23.合并K个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<p>解题思路：</p>
<p>1.循环合并最后两个链表：花费时间168ms</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *a = <span class="literal">nullptr</span>,*b = <span class="literal">nullptr</span>,*c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        b = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        c = marge(a,b);</span><br><span class="line">        lists.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.使用分治法：耗时24ms</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">margeFunc</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low+<span class="number">1</span> == high)</span><br><span class="line">    	<span class="keyword">return</span> lists[low];</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    ListNode *ls = margeFunc(lists,low,middle);</span><br><span class="line">    ListNode *rs = margeFunc(lists,middle,high);</span><br><span class="line">    ListNode *s = marge(ls,rs);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">    ans = margeFunc(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用优先队列：耗时48ms</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](ListNode* &amp;a,ListNode* &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)&gt; que(comp);</span><br><span class="line">    ListNode *Head = <span class="literal">nullptr</span>,*temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != lists.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])</span><br><span class="line">        &#123;</span><br><span class="line">        	que.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Head)</span><br><span class="line">        &#123;</span><br><span class="line">        	Head = temp = que.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = que.top();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">        	que.push(temp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分需要注意，构造优先队列的第三参数时仿函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
</search>
