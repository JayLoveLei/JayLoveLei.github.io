<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>批判性思维-阅读笔记</title>
    <url>/2020/05/03/CRITICAL-THINKING/</url>
    <content><![CDATA[<h1 id="批判性思维基础"><a href="#批判性思维基础" class="headerlink" title="批判性思维基础"></a>批判性思维基础</h1><h2 id="什么是批判性思维"><a href="#什么是批判性思维" class="headerlink" title="什么是批判性思维"></a>什么是批判性思维</h2><ul>
<li>但归结起来，批判性思维就是指审慎地运用推理去断定一个断言是否为真</li>
<li>批判性思维技能列表：<ul>
<li>判断信息是否恰当</li>
<li>区分理性的断言与情感的断言</li>
<li>区别事实与观点</li>
<li>识别证据的不足</li>
<li>洞察他人论证的陷阱和漏洞</li>
<li>独立分析数据或信息</li>
<li>识别论证的逻辑错误</li>
<li>发现信息和其来源之间的联系</li>
<li>处理矛盾的、不充分的、模糊的信息</li>
<li>基于数据而不是观点建立令人信服的论证</li>
<li>选择支持力强的数据</li>
<li>避免言过其实的结论</li>
<li>识别证据的漏洞并建议收集其他信息</li>
<li>知道问题往往没有明确答案或唯一解决办法</li>
<li>提出替代方案并在决策时予以考虑</li>
<li>采取行动时考虑所有利益相关的主体</li>
<li>清楚地表达论证及其语境</li>
<li>精准地运用证据为论证辩护</li>
<li>符合逻辑地组织复杂的论证</li>
<li>展开论证时避免无关因素</li>
<li>有序地呈现增强说服力的证据</li>
</ul>
</li>
</ul>
<h2 id="基本概念：断言、论题和论证"><a href="#基本概念：断言、论题和论证" class="headerlink" title="基本概念：断言、论题和论证"></a>基本概念：断言、论题和论证</h2><ul>
<li>构成批判性思维的基本要素是断言（claims），论题（issues）和论证（arguments）</li>
<li>断言：陈述（statements）或断言（我们在相同的意义上使用这两个概念）区分为真的或假的</li>
<li>论题：当我们对一个断言进行审查的时候，即当我们探究断言之真假时，我们就提出了一个论题。批判性思维主要关注这样一类断言：被论证支持或反驳的论题。“论题”实际上就是“问题”（question），我们可以互换地使用这两个概念。“问题”就是指某个特定的断言是否真实。解决问题就是对断言的真假做出回答。</li>
<li>论证：一旦我们清楚了论题是什么，下一步就是评价支持或反驳这个断言的论证，并断定论题的真假。论证是批判性思维的最重要因素，尽管论证可以很复杂，但究其实质，论证的概念很简单：我们从事论证是为了给一个断言的真提供理由。论证由前提（premise）和结论（conclusion）构成。前提是为另一个断言提供理由的断言，被前提支持的断言是论证的结论。</li>
<li>我们将会发现，在实际生活的境况中，重要而且往往困难的是准确识别到底什么是有问题的断言，即论题到底是什么。我们识别论题的困难是由多种原因导致的，从有意混淆到含混的术语以及思想本身的混乱等。</li>
<li>对于如何审查一个断言而言，关键是知道如何支持或反驳这个断言的真假。如果我们不知道如何确定断言的真假，对于如何通过论证支持或反驳断言我们就束手无策。</li>
<li>如果无从知道一个断言何时为真何时为假，谈论断言的真假就没有意义。换句话说，只有针对清楚地表达意思的断言、一个合乎语法的断言，我们才能谈论它的真假。</li>
<li>好论证的标准有待进一步阐述，但目前需要指出两点：第一，支持结论的前提必须是真的。一个论证的前提的真往往需要新的论证来支持，这样，一个论证的前提就是新论证的结论；第二，前提和结论必须是相关的。相关的要求是指：前提为真的确能增加结论为真的可能性。</li>
</ul>
<h2 id="论证与解释"><a href="#论证与解释" class="headerlink" title="论证与解释"></a>论证与解释</h2><ul>
<li>1.洛勒头疼因为他脑袋里有钉子。</li>
<li>2.洛勒该上医疗保险因为他不能支付医疗费。</li>
<li>这两个表达都是“X，因为Y”。论证包含两部分，其中一部分（前提）是据以认为另一部分（结论）为真的理由。表达2是论证，因为洛勒不能支付医疗费是据以认为他该上医疗保险的理由。与之相对，表达1中，洛勒脑袋里有钉子不是据以认为他头疼的理由。对洛勒而言，不需要理由他也能知道自己头疼。“他脑袋里有钉子”不是证明洛勒头疼的理由，而是表明引起他头疼的原因。</li>
<li>从根本上说，论证是为了支持或证明结论，而解释是为了指明某事物的原因、它如何运作或它是如何制作的等。论证一条狗身上有跳蚤和解释狗身上有跳蚤的原因是不同的思维，论证暴力犯罪的增加也不同于解释犯罪率升高的原因。提出对荷兰榆树病的解释也不同于证明该解释是正确的。尽管解释和论证容易被混淆，但这是两种不同的思维。</li>
<li>就像“农民不需要干旱，国家森林不需要修路”，这样的表达是要告诉大家：对于国家森林，修路不是好事。但这只是从不利的角度来描述在国家森林边修路，这样的表达不是论证。有人把论证界定为说服某人接受某种观点，但这并不正确。论证是证明或支持某结论，而说服某人是赢得他同意你的观点。从逻辑的观点看，论证和说服是不同的思维。的确，试图说服别人时往往要运用论证。但论证并不总是用于说服，说服往往也不一定借助于论证。</li>
</ul>
<h2 id="两种好的论证"><a href="#两种好的论证" class="headerlink" title="两种好的论证"></a>两种好的论证</h2><ul>
<li>逻辑学家将好的论证分为两类：好的演绎论证和好的非演绎论证。</li>
<li>好的演绎论证（deductive arguments）被称为“有效的”。一个论证是有效的，指该论证不可能出现前提为真而结论为假的情形。</li>
<li>好的非演绎论证（inductive arguments）的前提并不证明其结论。非演绎论证的前提支持结论。也就是说，如果非演绎论证的前提为真，那么就提高了其结论为真的可能性。</li>
</ul>
<h2 id="识别论证"><a href="#识别论证" class="headerlink" title="识别论证"></a>识别论证</h2><ul>
<li>无论是演绎论证还是非演绎论证，都由两部分构成。其中一个部分提供让我们相信另一部分的理由。论证的根本标识词为“所以”之类的词语。构成论证至少要有两个断言，而且各断言间（或明示的或暗示的）以“所以”等词语连接。</li>
<li>论证的提示词是识别论证的指南。除了“所以”之外，论证之结论的提示词还有：<ul>
<li>由此得出……</li>
<li>这表明……</li>
<li>于是……</li>
<li>因此……</li>
<li>结果……</li>
<li>我的结论是……</li>
</ul>
</li>
<li>论证的前提也有其指示词，如：<ul>
<li>既然……</li>
<li>因为……</li>
<li>由于……</li>
<li>依据……</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>断言：表达意见或信念的陈述；真或假。</li>
<li>论证：由断言按一定结构形成的两部分，其中一部分（前提）为另一部分（结论）的真提供理由。</li>
<li>论题/问题：因探究问题而提出的断言。</li>
<li>有效的演绎论证：该类论证的前提真意味着其结论一定真。</li>
<li>强的非演绎论证：前提为结论提供的支持越多，非演绎论证越强。</li>
<li>价值判断：表达对事物评价的断言。</li>
<li>道德价值判断：表达对事物道德或伦理评价的断言。</li>
<li>修辞：具有心理上的说服力，但并不增加逻辑力量的语言。</li>
<li>影响批判性思维的错误观念：<ul>
<li>假定所有的价值判断都是主观的。</li>
<li>混淆论证和解释。</li>
<li>混淆论证和说服。</li>
<li>混淆修辞与逻辑，误以为心理说服力越强的论证逻辑力量越强。</li>
</ul>
</li>
</ul>
<h1 id="两种推理（论证）"><a href="#两种推理（论证）" class="headerlink" title="两种推理（论证）"></a>两种推理（论证）</h1><h2 id="论证：基本特征"><a href="#论证：基本特征" class="headerlink" title="论证：基本特征"></a>论证：基本特征</h2><ul>
<li>结论指示词：论证中运用下列语词，通常表示就已经给出的前提将要得出结论（“……”表示结论）<ul>
<li>于是……</li>
<li>结果……</li>
<li>所以……</li>
<li>因此……</li>
<li>这表明……</li>
<li>这蕴涵……</li>
<li>这显示……</li>
<li>这证明……</li>
</ul>
</li>
<li>前提指示词：论证中运用下列语词，通常是引入前提。这些词语往往也在给出的结论之后出现。“……”代表实际论证中的前提。<ul>
<li>既然……</li>
<li>因为……</li>
<li>由于……</li>
<li>依据……</li>
</ul>
</li>
</ul>
<h2 id="两种论证"><a href="#两种论证" class="headerlink" title="两种论证"></a>两种论证</h2><ul>
<li>演绎论证：对于一个演绎论证，如果其前提为真，则证明了其结论。乍看起来这很简单。但为了阐明问题，我们先学习演绎逻辑的基本概念：有效。当一个论证满足条件：当其前提为真时，其结论不可能为假，这个论证就是有效的。</li>
<li>非演绎论证：与演绎论证的前提证明结论不同，非演绎论证的前提并不证明结论，非演绎论证的前提支持结论。</li>
</ul>
<h2 id="演绎，非演绎和未表达前提"><a href="#演绎，非演绎和未表达前提" class="headerlink" title="演绎，非演绎和未表达前提"></a>演绎，非演绎和未表达前提</h2><ul>
<li>实际生活中的论证往往包含未表达前提。通过不同的方式补充未表达前提，可以形成非演绎论证，也可以形成演绎论证。通常上下文和语境能帮助我们理解论证者的意图，但也有时候语境不能帮助我们解决问题。后一种情形下，通过考虑各种因素，所补充的未表达前提至少应该是可信的。</li>
</ul>
<h2 id="理解论证的技术"><a href="#理解论证的技术" class="headerlink" title="理解论证的技术"></a>理解论证的技术</h2><ul>
<li>为了理解论证，首先要发现结论或某语篇的主要观点。其次，要找出为得出结论而陈述的种种理由，即寻找前提。接着，再发现针对前提的论证（如果有）。为了展开上述步骤，需要在口头表达或书面论证中准确发现前提或结论并且理解这些断言之间的相互联系——即论证的结构。</li>
</ul>
<h2 id="评估论证"><a href="#评估论证" class="headerlink" title="评估论证"></a>评估论证</h2><ul>
<li>批判性思维要求我们评估论证。评估论证分为两个方面：逻辑和真假</li>
<li>一方面我们从逻辑的角度评估论证：该论证是在证明还是在支持其结论？这是一个有效的演绎论证还是较强的非演绎论证？从理论上说，到目前为止，你已能明白这些问题在表达什么意思；随着深入学习本书，你就能针对实际论证回答这些问题。</li>
<li>另一方面我们从真假的角度评估论证。论证的前提确实为真吗？在第4章中，我们将解释，就像对于缺乏可靠信息来源的前提一样，对于与背景信息以及其他可靠信息相冲突的前提，我们最好提出质疑。在第5章、第6章和第7章中，我们将告诫大家避免落入修辞或心理的误区。在第3章中，我们要提请注意，在接受前提之前必须弄清其表达的准确含义。通常，确定前提的真假依赖于知识、经验、冷静的头脑和乐于深入调查。</li>
</ul>
<h2 id="总结（推理-论证）"><a href="#总结（推理-论证）" class="headerlink" title="总结（推理==论证）"></a>总结（推理==论证）</h2><ul>
<li>论证由前提和结论组成，推理的前提可以不止一个。</li>
<li>同一个命题可以是一个推理的前提，又是另一个推理的结论。</li>
<li>推理分为两种：演绎论证和非演绎论证。</li>
<li>如果演绎推理是可靠的，就可以证明其结论为真。</li>
<li>可靠的推理是前提为真的有效推理。</li>
<li>有效的推理不会出现前提为真而结论为假的可能。</li>
<li>非演绎推理不是证明结论，而是为结论提供支持。</li>
<li>支持程度有高低之分：支持程度决定于前提使得结论为真的可能性的高低。</li>
<li>支持程度高的非演绎推理较强，支持程度低的非演绎推理较弱。</li>
<li>演绎推理和非演绎推理都可能含有未表达的前提。</li>
<li>一个推理是演绎推理还是非演绎推理可能决定于未表达的前提到底是什么。</li>
<li>如果难以把握文章中的论证，试着刻画其论证结构图。</li>
</ul>
<h1 id="清晰地思维、批判性思维与清晰的写作"><a href="#清晰地思维、批判性思维与清晰的写作" class="headerlink" title="清晰地思维、批判性思维与清晰的写作"></a>清晰地思维、批判性思维与清晰的写作</h1><ul>
<li>尽管多种因素都可能导致表达的含混不清，但其中最主要的原因可以归结为如下四点：过度模糊、歧义、过于抽象、未定义术语。本章将在深入探讨模糊、歧义和抽象后阐述定义。</li>
<li>写作的时候也常常需要进行批判性思维，在论文写作时尤其如此。在论文中，需要表达对论题的立场，还要提供支持该立场的论证。优秀的论文通常由四部分构成：陈述论题、表明对论题所持的立场、提供支持立场的论证、对支持相反立场的论证展开反驳。显然，如果论文中的陈述含混不清，当然会削弱论证的力量。本章中，我们还将具体指导如何清晰地写作。</li>
</ul>
<h2 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h2><ul>
<li>无论是思维还是写作中，最常见的含混是模糊（vaguness）。仔细探究起来，模糊的概念相当复杂。过去几十年中哲学家们就集中对这个概念展开了深入研究。不过就应用的层面来讲，不难把握这个概念。词语或短语的模糊是指：与该词语或短语相对应的对象是不明确的。<ul>
<li>“秃头”就是模糊的。帕里斯·希尔顿不是秃头及帕特里克·斯图尔特是秃头都是无可争议的，但对于生活中另外很多人是否秃头就难有定论。“秃头”概念是否可以指上述两类极端人群之间的人，就是不明确的。正因如此，“秃头”是模糊概念。</li>
</ul>
</li>
<li>模糊的程度各不相同。至于何等模糊度是可接受的，除了借助于适度的注意和常识以外并没有一成不变的答案。但可以这样认定：如果某断言不至于因为模糊而不能恰当地表达有用的信息，其模糊度就是可接受的。<ul>
<li>在上面说到的指路的例子中，如果其指引足以让我们顺利找到目的地，指引中的模糊度就是可接受的。如果政治人物在其税收计划中足够清楚地说明该计划将如何实施，我们就不能抱怨它的模糊性。但如果在表达中夹杂着过度的模糊以至于我们难以甚至不能理解其中的断言，具有批判性思维能力的人就会要求表达者负责澄清。</li>
</ul>
</li>
</ul>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><ul>
<li>具有多重含义的语词、短语或句子被称为歧义（ambiguity）。<ul>
<li>“保罗兑付了现金”指别人给了保罗现金还是保罗给了别人现金呢？两者都有可能。“杰西卡在租房子”可以指杰西卡把房子租给别人，也可以指别人把房子租给杰西卡。周五下午，珍妮弗从座位上站起来说：“我这儿的工作已经做完了。”珍妮弗的意思可能指完成了手中项目的工作报告，也可能指她完成了一周的工作可以去度周末了，还有可能指她已经厌倦了这儿的工作打算离开这家公司。如果你访问网站，不难发现各种引人发笑的歧义。对于引人发笑的歧义，通常我们知晓表达者利用歧义的意图。</li>
</ul>
</li>
<li>歧义的最常见情形是语义歧义（semantic ambiguity），即表达断言的语句中含有歧义的语词或短语.例：<ul>
<li>Jessica is cold.</li>
<li>Aunt Delia never used glasses.</li>
<li>例1可能在描述杰西卡的体温低，也可能在描绘杰西卡的个性冷漠；例2可能在说德里亚姑姑的视力好，也可能在说德里亚姑姑直接用瓶子而不用杯子喝啤酒。通过用不带歧义的语词来替换产生歧义的语词就可以消除语句中的歧义，如将例2中的”glasses”替换为”eyeglasses”（眼镜）就可以消除该句的歧义。</li>
</ul>
</li>
<li>组合歧义（grouping ambiguity）是一种特殊的语义歧义。当不能明确区分一个语词指集合体，还是指构成该集合体的个别成员时，就出现了组合歧义。<ul>
<li>语句“秘书挣的钱比医生多”中，如果“秘书”和“医生”分别指这两类从职人员的总体，这个句子或许是真的，因为从事秘书工作的人远比从事医生工作的人多；但若这两个语词分别指个体，这句话显然是假的。</li>
<li>骑越野摩托车的人或许为自己的癖好辩护说：“割草机比越野摩托车制造的污染更多。”因为这个表达中存在歧义，它既可以被解释为真的，也可以被解释为假的。作为总体来说，割草机制造的污染的确较多，因为割草机的数量远多于越野摩托车；但逐个进行比较，显然是越野摩托车制造的污染更多（毋庸讳言，越野摩托车还制造了大量恼人的噪音）。</li>
<li>对组合歧义进一步分析，有两种源于组合歧义的常见谬误：分解谬误与合成谬误。从群体具有某特征推导出群体的每个成员也一定具有该特征，就犯了分解谬误（fallacyof division）。<ul>
<li>1973年的美国棒球联赛中，迈阿密海豚队获得了冠军，该队还参加了1974年的超级碗比赛。迈阿密海豚队是联盟该年度最优秀的球队乃不争的事实，由此就可以推出该队的队员就是联盟最好的队员吗？即由此可得出鲍勃·格里耶瑟是最好的四分卫、拉里·克斯卡是最好的后卫、默克里·莫里斯是最好的接球手吗？当然不能。整体的特征未必为构成整体的各独立部分所具有。正如圆形的建筑物不必由圆砖块建筑而成。</li>
</ul>
</li>
<li>从另一个方向去思考，即由成员都具有某特征为前提推出所有成员构成的整体也一定具有该特征，就犯了合成谬误（fallacy of composition）。<ul>
<li>例如，在民意测验中，众议院的每个议员都获得较高的评价，但如果由此推定民意测验也会给众议院较高评价就是错误的，因为通常在相同的民意测验中，众议院得到的评价较低。人们对部分的评价和对整体的评价未必相同。正如人们可以用方形砖块建造圆形建筑物。在专栏中你会看到更多关于分解谬误与合成谬误的实例。</li>
</ul>
</li>
</ul>
</li>
<li>语形歧义：一个句子的语法结构可以作两种以上的解释时，这个句子就含有语形歧义（syntactic ambiguity）。<ul>
<li>“去加拿大旅行，须携带出生证或驾照和其他附照片的身份证明。”这句话在说跨越美加边境到底有什么要求？按照一种解释，除携带出生证或驾照之外，还得携带其他附照片的身份证明；按照另一种解释，携带其他身份证明就不是必须的。下面用括号分别标出两种不同的解释：<ul>
<li>[须携带出生证或驾照]和[其他附照片的身份证明]</li>
<li>[须携带出生证]或[驾照和其他附照片的身份证明]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li>与模糊及歧义密切相关的一个概念就是抽象（generality），抽象的表达也会引起含混不清。我们已经知道“孩子”是模糊概念，因为我们不知道“孩子”和“非孩子”的界线到底在哪里。“孩子”也是歧义的，因为它既可以指未成年人，又可以指婴儿。这个概念也是抽象的，因为它既指男孩，又指女孩。大致说来，一个断言表达的内容越不具体，该断言就越抽象。就具体语词或短语X而言，”X”所指的范围越广，X越抽象。“摩尔有只狗”比“摩尔有只澳达猎犬”抽象，而更抽象的是“摩尔有宠物”。</li>
<li>模糊、歧义、抽象这些相互联系的有碍清晰思维的诸多概念，可能会让你觉得眼花缭乱。但实际上，重要的是发现问题，即识别表达或断言中哪些是不清晰的以及寻求如何解释它。至于给所发现的问题一个什么样的名称（到底是模糊、歧义还是抽象）并不重要。例如：如果有人随意地使用语词“战争”，你最好的反应就是问对方“你所说的‘战争’指什么”。</li>
</ul>
<h2 id="定义术语"><a href="#定义术语" class="headerlink" title="定义术语"></a>定义术语</h2><ul>
<li><p>定义的目的：定义的目的中最值得注意的有四种。</p>
<ul>
<li>告知词语的日常意义。为了弄清语词的意义，我们往往借助于字典。字典上所给的就是词典定义（lexical definition）。它告诉我们语词的通常含义，如“绢毛猴，名词，南美森林中的小猴，绒猴家族，色彩明亮，脸和脖子周围毛发丛生”。</li>
<li>约定在特定语境下的语词意义。为实现该目的而做出的定义叫约定定义（stipulative definition）。如，“这种情形下，‘桌面’指打开操作系统时显示屏所显示的含有回收站的状态”。也可以通过约定定义来给新发明的语词指派意义。2005年，在新开播的电视节目《科尔伯特报告》中，斯蒂芬·科尔伯特发明了新词汇”truthiness”。该词的约定意义为：未经证据、逻辑、理智或事实等的检验，仅凭直觉或“本能”被认定为真的事物。</li>
<li>减轻模糊、抽象或消除歧义。“本合同中，’dollars’指加元，而不是指美元或澳元。”为实现此种意图的定义被称为精确定义（precising definition）。</li>
<li>用于说服。这种定义为了提供语词的日常意义或各方约定的意义，因而不是真正意义上的定义，它被称为说服定义或修辞定义（persuasive or rhetoricaldefinitions）。尽管这种定义也和其他定义一样被列在定义的名录中，但值得注意的是，这类“定义”不仅仅包含着语言方面的信息，它的意图是影响人们的信念和态度。<ul>
<li>如果一个开明者试图把“保守者”“定义”为：认为生活的重心就是挣钱和盘剥穷人的刻板守旧、心胸狭窄的伪君子。这并不是为了澄清“保守”的意思，而是为了抨击保守者。这样的修辞定义往往借助于语词的情感意义（e-motive meaning）。有的人更愿意称之为修辞力（rhetorical force）。这样的意义包含着对语词所指对象的正面或负面评价。经历了多年对伊拉克的战争之后，美国民众中有的希望“带他们回家以支持部队”，有的希望“匆忙离开”。这两种人都表达了从伊拉克撤回美军的相同愿望，但不同表达的情感意义不同，成语“言外之意”就是描述与语词相关的情感意义的。前面说过的把“堕胎”定义为“谋杀未出生的孩子”就是常被引用的该类型的定义。</li>
</ul>
</li>
</ul>
</li>
<li><p>定义的种类：</p>
<ul>
<li>实指定义（ostensive definition）：即通过指明语词所指的对象或识别语词所指对象的典型例子来下定义。如：“我用‘圣典’指圣经、古兰经这样的文本”、“鼠标就是这个（展示实物）带有按键的东西”。</li>
<li>同义词定义（definition by synonym）：即给出与被定义术语具有相同意义的语词或短语。如：“‘吹毛求疵’与‘挑剔’意思相同”“‘悸动’意味着‘跳动’”。</li>
<li>分析定义（analytical definition）：确定被定义术语所指对象的必要特征从而明确术语所指的对象。这样的定义通常的形式是明确属和种。例如：“俄式茶壶是俄罗斯人用于烧水泡茶的壶”、“猫鼬是食蛇的与麝猫有亲缘关系的雪貂大小的哺乳动物”。字典上的定义大都是分析定义。</li>
</ul>
</li>
<li>定义的注意事项：<ul>
<li>首先，不能通过定义使论辩的任何一方处于不利境地。这里只需说明：如果对于关键术语的定义论辩双方没有形成共识，任何一方都不能仅通过对己有利的定义来赢得辩论。人们应该站在中立的立场来下定义。</li>
<li>其次，定义必须是清晰的。定义是用来澄清歧见而不是为了混淆视听。所以必须用简单清楚的语言来表述定义。如果用比被定义语言更含混的语言来下定义，不可能达成预期的目的。定义要清晰就要求尽可能避免在定义中使用诉求情感的语言。</li>
</ul>
</li>
</ul>
<h2 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h2><ul>
<li>论文通常由四部分组成：<ul>
<li>陈述论题</li>
<li>表明对论题所持的立场</li>
<li>提供支持立场的论证</li>
<li>对支持相反立场的论证展开反驳</li>
</ul>
</li>
<li>论文写作要点：<ul>
<li>论文的开端要通过描述论题的重要性和趣味性来介绍论题，这往往并不容易，纵然你自己未必对该论题感兴趣也要激发读者对它的兴趣。但你的陈述必须是中立的，即不能把你对论题的立场表述为唯一正确的立场。这会让读者怀疑你将展开的论证会成为劝说他的负担。</li>
<li>你对论题所持的立场必须是明确的，而且要尽量做到简明扼要。清晰地陈述论题会为识别你的立场提供捷径。</li>
<li>支持立场的论证要尽量言简意赅，但比简洁更重要的是清楚。毕竟这部分是论文的心脏。陈述的理由必须明显相关，这些理由如果不是显而易见的就需要其他论证的支持。</li>
<li>如果对论题的相反立场有著名的论证，你要列举这样的论证，并提供理由证明它缺乏说服力。你可以指出其前提不必为真，或该前提不能支持其结论。</li>
</ul>
</li>
<li>写作指导：<ul>
<li>中心突出。文章的开篇就要陈述论题、表明立场，但这不等于用呆板的语言罗列清单：“本文将论证X、Y和Z”，然后逐一论证所列各项，最后总结：“本文论证了X、Y和Z”。陈词滥调的文风不可能引人入胜。“你会因为母亲的猫而减少该被继承的遗产吗？”比“本文将讨论动物继承其主人遗产的问题”能让读者更加饶有兴味地继续关注你的论题或立场。</li>
<li>紧扣主题。论文中所表达的要点要与讨论的主题密切相连，各要点只能服务于两个目的：<ul>
<li>（a）对所持立场的说明、解释、澄清、阐述；</li>
<li>（b）对持相反观点者的回应。要删除无关的论述和没有针对性的思想。</li>
</ul>
</li>
<li>按照一定的逻辑顺序谋篇布局。在你为支持自己的观点举例或澄清的时候，要让读者明白你到底在做什么。要让读者明白你给出的语句与你的最终目的之间是什么关系。如果读者在通读你的文章后依然不知所云，抓不住你的要旨，说明你没有适当地组织材料。这类洋洋洒洒的文章或许类似法国哲人的大作，但作为议论文它是不合格的。</li>
<li>结构完整。文章的结构要力求完整：充分支持自己的观点，反驳已知的对立观点，并对可能反驳自己的意见进行回应。许多论题都不可能仅在一篇论文中作穷尽的论述，关键在于要集中探讨论题的某一方面，从而完整地论述它。所以，越明确地限定话题，越容易完整地驾驭它。<ul>
<li>可以从不同层面来理解结构完整——句子要完整，段落要完整（每一段落要紧扣一个观点），整篇文章要有结论。值得注意的是，形成文章的结论和总结文章不是一回事。短篇论文并不需要总结。</li>
</ul>
</li>
</ul>
</li>
<li>如何练习写作：<ul>
<li>初步组织材料后，列出写作提纲。然后，确认提纲是否合乎逻辑、文中逐词逐句是否都适合提纲的需要。有的作者在着手之前就先拟非正式的提纲。我们的建议是：先要识别论题和你的立场，文章开篇就要表明二者。</li>
<li>修改你的作品。修改是让文章优秀的秘诀，即使是专栏作家们也需要不断修改他们的作品。除非你比职业作家更具天赋，对自己的文章要修改、修改、再修改。不要只打算二易其稿或三易其稿，要准备不厌其烦、千推万敲。</li>
<li>如果有人读完你的文章后提出批评，按照他的意见修改。</li>
<li>如果在语法或拼写上有困难，大声朗读文章可以帮你发现默读时错过的问题。</li>
<li>对自己的文章完全满意后，把它搁在一边，隔段时间再进一步修改。</li>
</ul>
</li>
<li><p>写作中好的文风：</p>
<ul>
<li>避免陈词滥调</li>
<li>尽量具体</li>
<li>不要抽象</li>
<li>避免被动语句</li>
<li>不要啰嗦</li>
<li>夸大其词远不如谨慎陈述</li>
<li>保证主语与谓语的一致</li>
<li>为什么运用修辞手段</li>
<li>无论多么相关，插入的定论都不是必需的</li>
<li></li>
</ul>
</li>
<li><p>论文写作的误区：</p>
<ul>
<li>废话连篇：不是直接切入论题，而是大量介绍、评价论题、谈论该论题一直困扰着世世代代的思想者以及对于该论题如何众说纷纭等。</li>
<li>信口开河：写作时不注意组织自己的思想，想到哪儿写到哪儿。</li>
<li>未经思考：不对论题作深入和详细的探讨而写出对论题的第一反应。</li>
<li>不得要领：写作时拐弯抹角。需要评价骑自行车的好处时，大谈自行车的历史；需要介绍自行车的历史时，却通过历史评述骑自行车的益处。</li>
<li>让读者领会：期望读者从作者不合逻辑的推论、转移话题的论述和无关的旁敲侧击中领会作者的意图。</li>
</ul>
</li>
<li><p>有说服力的写作：</p>
<ul>
<li>集中讨论与对手就论题产生的分歧，而不是只关注个人观点。</li>
<li>在反驳对手的观点时不能出言不逊。不能说对手的论证是荒谬、可笑的。</li>
<li>对于对手的好论证，要坦率承认。</li>
<li>在受限的时间和条件下，把注意力集中于最主要的环节。不要过分关心枝节上的分歧。</li>
<li>先陈述强有力的论证。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>批判性思维的前提是清晰的思维</li>
<li>引起断言及论证的含混不清有诸多原因，但主要有模糊、歧义和抽象</li>
<li>模糊有程度之分，关键是相对于特定目的而言不能太模糊</li>
<li>歧义指一个语句有多种解释，而且不能断明其中哪种解释是正确的</li>
<li>歧义主要分为语义歧义、语形歧义、组合歧义和指代歧义</li>
<li>过于抽象的断言指缺乏足够的信息来界定它到底可应用于哪些对象</li>
<li>无论是减少模糊、消除歧义还是运用新词汇或旧词新用，定义都能助一臂之力</li>
<li>定义主要分为同义词定义、实指定义、分析定义</li>
<li>修辞定义并不是为了澄清意义，而是为了表明或影响态度</li>
<li>修辞定义借助术语的修辞力（情感意义）来实现目的</li>
<li>论文写作是批判性思维能力的运用和体现，要训练和掌握论文写作的技能</li>
</ul>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>批判思维</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>GP-tSNE论文重构</title>
    <url>/2020/05/08/GP-tSNEReconstruct/</url>
    <content><![CDATA[<h2 id="GP-tSNE论文重构"><a href="#GP-tSNE论文重构" class="headerlink" title="GP-tSNE论文重构"></a>GP-tSNE论文重构</h2><p>高维数据投影是</p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>论文重构</tag>
        <tag>可理解性</tag>
      </tags>
  </entry>
  <entry>
    <title>论文错误记录</title>
    <url>/2020/05/07/ErrorRecord/</url>
    <content><![CDATA[<h2 id="论文错误记录"><a href="#论文错误记录" class="headerlink" title="论文错误记录"></a>论文错误记录</h2><ul>
<li><p>原句：但是，目前最流行的可视化方法（如t-SNE[]）往往是黑箱方法，因为使用者无法洞察可视化如何表示数据的原始特征</p>
<ul>
<li>问题：最流行的降维方法，不仅仅是t-SNE，还有PCA；无法观察原始特征，和黑箱之间的因果联系未论证。</li>
<li>解析：<ul>
<li>定语缺失，应该说是最流行的的流形学习方法</li>
<li>“流形学习方法（如t-SNE[]）往往是黑箱方法”作为结论，“因为使用者无法洞察可视化如何表示数据的原始特征”作为前提，是以偏概全</li>
</ul>
</li>
</ul>
</li>
<li><p>原句：即使是可视化领域中最新的研究进展，如UMAP[] 也承认其依然存在着可解释性问题。</p>
<ul>
<li>问题：不知道这里的可解释性问题又是什么？最新的进展，和可解释性有什么关系？为什么要用即使？</li>
<li>解析：<ul>
<li>可解释性问题在上文中没有给出直接的定义，我只描述了导致可解释问题的两个情景。</li>
<li>因果关系没写清楚，太含混了</li>
</ul>
</li>
</ul>
</li>
<li><p>原句：其他的方法如AutoEncoder[] 和 parametric t-SNE[] 给出了从原始数据及到二维可视化<br>的参数映射，但这些参数映射都基于复杂的神经网络生成，对人来说依然难以理解</p>
<ul>
<li>问题：其它的方法，什么叫其它的方法？举例不能代表概念。</li>
<li>解析：应该写成给出参数映射的流形学习变体</li>
</ul>
</li>
<li>原句：虽然PCA 和LDA 等线性方法的可视化结果具有很强的可解释性，但它们的可视化仅能表示数据的原始特征的线性组合，这限制了其可视化的质量。<ul>
<li>问题：刚刚在讨论可解释性，为什么忽然又变成了可视化的质量？</li>
<li>解析：要紧扣主题</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>写作错误</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-136.只出现一次的数字</title>
    <url>/2020/05/03/LeetCode-136/</url>
    <content><![CDATA[<h2 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode-136.只出现一次的数字"></a>LeetCode-136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>我们已经通过题目可知：</p>
<ul>
<li>重复的数字都出现了两次</li>
<li>不重复的数字只出现一次</li>
</ul>
<p>因此我们可以采用异或来解决这个问题：</p>
<ul>
<li>异或满足交换律：a^b^c  == a^c^b</li>
<li>当两个值相等时，异或结果为0</li>
<li>0与任何数x异或，结果都为x</li>
<li>所以a^b^b^a^c == a^a^b^b^c == 0^0^c == c</li>
</ul>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        for_each(<span class="built_in">begin</span>(nums),<span class="built_in">end</span>(nums),[&amp;](<span class="keyword">int</span> &amp;x)&#123;ans ^= x;&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-104.二叉树的最大深度</title>
    <url>/2020/05/01/LeetCode-104/</url>
    <content><![CDATA[<h2 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode-104.二叉树的最大深度"></a>LeetCode-104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h2 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h2><p>只需要使用深度搜索遍历树。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">int</span> lv = func(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rv = func(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> lv &gt; rv ? lv : rv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>GPt-SNE论文分析</title>
    <url>/2020/04/27/GPt-SNE/</url>
    <content><![CDATA[<h2 id="GPt-SNE-论文分析"><a href="#GPt-SNE-论文分析" class="headerlink" title="GPt-SNE 论文分析"></a>GPt-SNE 论文分析</h2><p>作者：Andrew Lensen</p>
<p>期刊：IEEE Transactions on Cybernetics</p>
<h2 id="Introduction："><a href="#Introduction：" class="headerlink" title="Introduction："></a>Introduction：</h2><ul>
<li>首先直接指出目前的可视化的作用和目前可视化方法的痛点<ul>
<li>痛点：<ul>
<li>最先进的可视化方法往往是黑盒方法，无法洞察可视化如何编码数据的原始特征</li>
<li>其他方法如Autoencoder和pt-SNE使用复杂神经网络，对人来说依然难以理解</li>
</ul>
</li>
<li>分析：直接指出可视化的痛点，也是一种很好的表达，观点看起来很清晰，之前自己的写作顾虑太多，应该就事论事。其实作者的观点和我是一致的，但是我一没讲清楚，二是不够自信，过多的自我怀疑对工作毫无益处。</li>
</ul>
</li>
<li>接着指出有良好可解释性的线性方法，在降维上固有的局限性：<ul>
<li>痛点：线性方法仅通过对原始特征的线性组合来编码可视化</li>
<li>分析：还是不够自信吧，我们写的太拘谨了，其实我自己写作的时候，就一直在思考为什么不去直接指出线性方法的局限性，我觉得要多坚持自己的想法。</li>
</ul>
</li>
<li>然后介绍基于树的GP（genetic programming）方法，该方法常用于FC（feature construction）中的降维，并且是公认可解释的。最后明确指出，GP方法还并未被用于生成可解释的降维模型即可解释的的可视化。<ul>
<li>分析：觉得自己调研的不够充分，毕竟我都没收集到GP方法。论文写法上来说，我觉得简单直接，我在写作中也要以他为模板，即使技术方案简单也没什么好扭捏的。</li>
</ul>
</li>
<li>接着给出了他们之前的工作GP-MaL（该工作使用GP方法进行降维），并指出了之前工作存在的一些问题。<ul>
<li>分析：这样写，一方面阐述了作者在GP方法上是有底蕴的，让人更相信作者的表达。我觉得我在写作的时候可以多引用作者的论文和表达，体现出我在该研究方向上的理解。</li>
</ul>
</li>
<li>然后给出了论文的技术方案：多目标GP方法。<ul>
<li>分析：Introduction通过前两段才讲清楚问题，但是并没有让人觉得冗余。而我总是追求一句话讲清楚，为了达到这个目标，就在非线性方法的问题和线性方法的问题中做取舍，最后不伦不类，要多反思，不能僵化自己的思维。</li>
</ul>
</li>
<li>最后总结了论文的贡献：<ul>
<li>贡献：<ul>
<li>Propose a holistic set of functions and terminals for creating powerful and interpretable models for visualisation; </li>
<li>Design a multi-objective approach to allow for the evolution of a solution front containing visualisations representing different levels of quality and complexity; </li>
<li>Compare the quality and interpretability of the evolved visualisations with those produced by state-of-the-art visualisation methods on a range of datasets; </li>
<li>Perform an in-depth analysis of the trade-off between visualisation quality and tree complexity to demonstrate the unique advantages of the proposed approach.</li>
</ul>
</li>
<li>分析：我觉得贡献部分写的很平实，我在写贡献部分的时候也要平实，不要故弄玄虚。</li>
</ul>
</li>
</ul>
<h2 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h2><ul>
<li>Dimensionality Reduction：降维是一种通过减少数据集的特征/属性数量来提高理解和性能的过程，随着数据集变得越来越大，深层神经网络变得越来越不可解释，其重要性也在不断增加。解决这个问题的常用技术包括FS（feature select）和FC，他们分别通过删除不需要的特征或创建更少、更复杂的元特征来减少特征空间。GP方法由于其功能性和可解释性而被证明是一种适合FC问题的方法。流形学习（非线性降维）可以被看作是一种无监督的FC方法，其任务是建立一组表示高维特征空间中存在的非线性流形的特征。实现这一任务的一种方法是尝试构建一个函数，将高维空间映射到低维流形；这种方法可以在两者之间提供可理解的映射。<ul>
<li>分析：首先论文简单介绍了降维的意义和目标。与之相比我写的相关工作太冗余了，全都是已有技术的堆砌，没有紧扣主题且逻辑松散。其次论文对流形学习的介绍，用简单明了的语言就把流形学习的意义和目的讲清楚了。我在写作中要多比对自己和论文的表达。</li>
</ul>
</li>
<li>Machine Learning for Performing Visualisation:该段从机器学习的角度分析了常用的可视化方法，如FS和PCA，存在的局限性（除了简单的低维数据外，线性转换无法清晰地显示数据集中的任何低维流形/结构）。而创建最优非线性变化是一个NP难问题，因此提出了许多基于损失函数的非线性降维方法（ISOMAP，LLE）。最后提到了t-SNE，作者认为这是目前最成功的技术（当然，作者这么写的主要原因是作者的模型基于t-SNE），并对t-SNE进行了较为详细的介绍。<ul>
<li>分析：给我的感觉就是详略得当，既能感受到作者在可视化领域和机器学习领域上的积累，又写的很清爽，让人读起来很轻松。相比之下，我写的东西，要不就是全部都详写，要不就是全部都略写，主要还是自己在相关领域的积累太浅，不能把握文章的重点，要在这方面多花功夫。</li>
</ul>
</li>
<li>Multi-objective Optimisation：这部分主要介绍了MO（Multi-objective Optimisation）方法，当一个问题本质上有两个（或多个）冲突目标时使用的一种技术，在这两个目标之间必须通过问题的解决方案进行权衡。在这种情况下，解决方案的质量通常与其他解决方案的目标函数值有关。而目前最流行的的MO方法就是EC方法，这也是论文所采用的方法。<ul>
<li>分析：我在写作过程中没有了解过MO方法，所以还需要进一步深入。从写作上来说，我觉得讲的还是很清晰的，虽然我看完不知道MO方法的细节实现，但是为什么用MO方法，以及MO方法的目的，以及作者如何实现MO方法都已经了解了。所以我在介绍相对冷门的技术的时，也要这样抓住重点来讲。</li>
</ul>
</li>
<li>Related Work：作者把相关工作分成了两部分，一部分是GP方法在流形学习和可视化上的应用，另一部分介绍了其它与可解释性相关的工作。<ul>
<li>因为作者就是第一个提出将GP方法用于在流形学习，所以这一部分写的非常的自信。其中提到了三个优化目标：可分类性，视觉可解释性，语义可解释性。</li>
<li>介绍了参数t-SNE（参数t-SNE是t-SNE的一种变体，它允许在将来的样本上重用学习到的t-SNE表示。 参数化t-SNE使用受限的Boltzmann机器构造从高维空间到低维空间的映射，以构建预训练的前馈神经网络模型。 该神经网络在最大的数据集上使用了10,000多个神经元，从而严重限制了解释该网络的潜力），Autoencoder（自动编码器[3]是另一种基于神经网络的方法，它试图将数据表示压缩到尽可能小的中间隐藏层中，以便可以从简洁的表示中重新创建原始数据。 为此，自动编码器使用许多大小不同的层来编码和解码数据。 这提供了与学习到的表示之间的映射，但是在给定节点数和完全连接的拓扑的情况下进行解释是不现实的），SOM（是无监督神经网络的一种变体，已用于可视化，但是权重的数量随维度而定，因此它们的可解释性受到非平凡数据集的限制）。并指出论文和已有增强可解释性方法的区别，已有方法（如DimReader）通过更改模型参数或数据实例来分析模型，而论文提出了一种可直接解释的降维模型。</li>
<li>分析：这部分内容可以作为我们解释非线性降维相关工作参考的模板，我们不应该为了分类而分类，要紧扣自己的工作，提出符合逻辑的分类，让读者的关注点一直保持在我们的工作上。通过这段，我们可以发现我们的工作和论文工作的区别，所以我认为我们的工作还是有价值的。</li>
</ul>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul>
<li><p>介绍GPt-SNE用于可视化需要解决的技术问题：</p>
<ul>
<li>什么终端和功能节点是合适的</li>
<li>如何构造适应度函数</li>
<li>标准的GP进化过程如何改进</li>
</ul>
</li>
<li><p>GP Architecture：对于每个个体构造两颗GP树，每颗树生成可视化的一个维度（即x轴或y轴）。选择多树表示而不是协作协作进化方法，因为必须紧密耦合（即高度依赖）两棵树才能提供高质量的可视化； 合作协作进化方法倾向于不确定地配对来自不同子种群的解决方案，这大大降低了发生这种耦合的能力。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1587963825918.png" alt="1587963825918"></p>
</li>
<li><p>上表中的Function是功能节点：</p>
<ul>
<li>Arithmetic Function节点通过线性变换来减少输入数目</li>
<li>Non-Linear Function节点给出了两种Sigmoid和ReLU两种激活函数实现非线性变化（作者根据Autoencoder和其他神经网络方法的启发而选择的。（我的观点：神经网络的非线性的确体现在激活函数上））</li>
<li>Conditional Function节点提供了另一种非线性变化，作者认为这种变换由于其不可微性而对GP方法来说是非常独特的，并且期望它们允许一棵树根据其输入表现出不同的行为</li>
</ul>
</li>
<li><p><img src="/2020/04/27/GPt-SNE/1587963903654.png" alt="1587963903654"></p>
<p><img src="/2020/04/27/GPt-SNE/1587963929329.png" alt="1587963929329"></p>
</li>
<li><p>上表中的Terminal是终端节点：数据集中的每个特征都被分配了一个不同的终端，该终端返回给定实例的特征值。</p>
<ul>
<li>$F_i$终端直接返回实例的第$i$个的特征值（虽然这么做为EC搜索过程提供了灵活性，但是确实为大量特征增大了搜索空间。为了解决这个问题，作者使用PCA来选择最重要的特征）</li>
<li>$NF_i$终端给定去噪后的特征值（通常通过求特征值的均值实现）</li>
<li>Constant终端提供一个$[-1,1]$之间的值，以允许树的不同部分对最终输出产生不同的影响</li>
<li>Zero终端仅包含在n+和-功能节点中，因为单独的Zero终端对树没有任何影响</li>
<li>表2中的LIKEHOOD表示从终端集中选择终端的权重</li>
</ul>
</li>
</ul>
</li>
<li><p>Multi-Objective Approach：在机器学习中，模型的潜在性能与达到该性能所需的复杂性之间存在着内在的联系。例如，分离两个类的最简单模型是一个决策边界，它在空间中的某个点上简单地设置阈值，而对于三个线性可分的类，则至少需要两个阈值。而在可视化中也是如此：可视化的表达越细（具体），用于生成可视化的功能就越复杂。要在二维中重建复杂数据集的高维结构，需要两个非常大且复杂的GP树。从树中移除每个节点都会降低树重现高维概率分布的准确性（在t-SNE的情况下）。作为类比，考虑用GP树演化一个非常复杂的多项式函数：演化函数中的分量（节点）越少，可用于逼近函数的拐点就越少。为此作者使用多目标优化的方法来生成一套解决方案，从而在可视化质量和模型可解释性之间进行权衡。</p>
<ul>
<li><p>分析：作者的GP树，通过自底向上的功能节点计算，最后得到（x|y）轴上的投影。与之对比，他们的降维方法是全局的，而我们的降维方法是局部的。他们的降维方法是非线性的，我们的降维方法是全局非线性，局部线性的。</p>
</li>
<li><p>Objective 1 ：Visualisation Quality</p>
<ul>
<li>论文简要介绍了t-SNE的优化原则以及它的Cost Function。并且使用t-SNE的Cost Function作为第一个优化目标（可视化质量）。</li>
</ul>
</li>
<li><p>Objective 2：Model Complexity</p>
<ul>
<li><p>GP中遇到的一个常见问题是生成膨胀的树，其中GP树比达到给定适应度所需的树大得多。传统场景中，由于对树的规模不做限制，因此树可能包含不必要的复杂子树。</p>
</li>
<li><p>论文计算模型复杂度的公式：<img src="/2020/04/27/GPt-SNE/1587980851820.png" alt="1587980851820"></p>
<p>其中$T$是树，$I$是降维模型，$N_i$是树中的节点。</p>
</li>
</ul>
</li>
<li><p>分析：其实我觉得简单直接的方法，在有效的情况下挺好的</p>
</li>
</ul>
</li>
<li><p>Optimisation of Tree Constants：为了进一步提高可视化质量而不引入额外的模型复杂性，论文使用粒子群优化（PSO）[35]在进化过程的最后阶段对每个个体的短暂随机常数（ERC）进行微调。 标准GP无法有效地微调其数字参数（因为它随机搜索参数空间）； 通过采用PSO，论文可以做到这一点。（来自两棵树的）每个ERC都在PSO表示中分配了一个维度，给定维度的值表示给定ERC的值与其原始值相差多少。 论文使用很小范围的初始位置值（[-0.15，0.15]）和较低的最小和最大速度（-0.05和0.05）将PSO搜索集中于微调树中的ERC。 将所有0值（即原始ERC值）初始化为30个粒子之一，以确保PSO搜索不会产生劣等解。  PSO搜索是单目标的（因为树结构是固定的），适应度函数是与GP搜索中的第一个目标相同的代价函数（公式（5））。  PSO仅在GP进化过程的末尾使用，这既是因为其计算成本，又是为了防止GP陷入因进化过程中的微调而导致的局部最小值。</p>
<ul>
<li>分析：这部分提到了一个跟有意思的概念，提高可视化质量而不引入额外的模型复杂性，我要在设计实现方案时多考虑这样的技术。</li>
</ul>
</li>
<li><p>Other Considerrations：这一部分讲述了作者对标准MOEA/D的改动和默认参数的设置。并且作者提到使用多线程技术，和缓存GP树来加快运算。</p>
<ul>
<li>分析：这部分我也在我的技术方案里提到，但我是在技术方案中直接给出的，作者在最后给出这些优化细节，可能更有利于读者理解核心技术。</li>
</ul>
</li>
</ul>
<h2 id="Experiment-setup"><a href="#Experiment-setup" class="headerlink" title="Experiment setup"></a>Experiment setup</h2><ul>
<li>第一部分给出了作者使用的数据集列表，并且介绍了为什么使用这些数据集“这些数据集来自许多不同的领域，包括一般分类、生物学和图像分析。这些数据集大多来自UCI存储库[38]。”<ul>
<li>分析：在介绍实验数据集时，最好引用别人的工作，这样显得客观，但是在算法验证部分，为了帮助用户理解，可以使用人工数据集。</li>
<li><img src="/2020/04/27/GPt-SNE/1588167232568.png" alt="1588167232568"></li>
</ul>
</li>
<li>第二部分作者分析了GP-tSNE方法的特性，包括遗传代数，树的大小，实例覆盖率等。并且指出了这些参数可以充分发挥GP方法的性能（即进一步调整参数不会提高性能）<ul>
<li>分析：可以给出一组合适的参数，并给出使用这组参数的理由，从而指导用户使用。</li>
<li><img src="/2020/04/27/GPt-SNE/1588168104405.png" alt="1588168104405"></li>
</ul>
</li>
</ul>
<ul>
<li>第三部分作者对比了GP-tSNE和t-SNE之间的运算开销。并且分析了导致计算开销高的原因，最后提到作者给出了并行化方案来加速。<ul>
<li>分析：作者的描述“此外，GP-t SNE在一次运行中产生许多可视化，而t-SNE只产生一个可视化。在最大的数据集，图像分割，GPtSNE需要30小时，而t-SNE需要大约两分钟。”，我们在描述我们的技术方案时，也可以参考作者的描述，并且我们的方法相比作者的方法更快。</li>
</ul>
</li>
</ul>
<h2 id="Results-and-Discussion"><a href="#Results-and-Discussion" class="headerlink" title="Results and Discussion"></a>Results and Discussion</h2><ul>
<li><p>这一部分为论文的Case study。因为解决方案本质上是一个降维方法，所以作者主要在对比t-SNE和GP-tSNE的可视化效果（Cost Function 和 可视化视图）。</p>
</li>
<li><p>作者在讲到GP-tSNE的Cost Function大于t-SNE时，用到了一句话“与Iris数据集一样，GP-tSNE在最大复杂度下所获得的成本虽然接近于t-SNE，但它是通过映射而非嵌入产生的。”</p>
<ul>
<li>分析：我们的技术方案的基础是“Local Linear，Global no-Linear”。所以目前的我们的case study是面向无类别流形数据，发现并理解流形数据中的非线性特征。但是在多类简单数据上（简单体现在每个类别能被一个线性子空间表示），我们的方法应该也能有不错的效果。</li>
</ul>
</li>
<li>GP-tSNE和t-SNE的Cost function值的差（横坐标遗传代数）：<img src="/2020/04/27/GPt-SNE/1588241733421.png" alt="1588241733421"><ul>
<li>分析：可以看到，对于不同复杂程度的数据，在不同的遗传代数上收敛。对于我们的解决方案，可以绘制数据的分片大小和重建误差均值的折线图，来展示不同复杂度的数据集对解决方案的影响。</li>
</ul>
</li>
</ul>
<h2 id="Further-Analysis"><a href="#Further-Analysis" class="headerlink" title="Further Analysis"></a>Further Analysis</h2><ul>
<li><p>本部分作者主要论述不同复杂度的模型如何解释。复杂度较低的模型往往是线性的，GP-tSNE可以直接给出模型的两个映射（x和y），并根据映射结合可视化效果来理解模型。</p>
<ul>
<li><img src="/2020/04/27/GPt-SNE/1588324149315.png" alt="1588324149315"></li>
<li>分析：例如上图，其中一棵树包含三个节点，另一棵树包含10个节点，总复杂度为13。即使具有如此低的复杂度，三个类也开始出现，蓝色，紫色和红色类已经与其他类明显分开。 给出可视化$x$轴的树可以表示为$x=f_5+f_{11}+f_{32}+2nf_{14}-f_{21}-nf_{21}$。 y轴的树可以表示为$y=nf_{20}−f_{15}$。 这两棵树在原始特征集中的34个中总共使用了七个独特的特征，但是它们能够很好地分离出数据集的三个类别。 特别是可以通过在图中绘制两条垂直线来区分蓝色，红色和紫色类别。 换句话说，可以将两个阈值应用于$x$轴的输出，以便将类别大致分为三组：红色； 橙色和绿色； 和紫色和蓝色。 假定所有要素的[0，1]范围相同，并且树中减去的唯一要素是$f_{21}$，这表明蓝色和紫色类的$f_{21}$的要素值特别小（因为它们具有较高的$x$值），并且红色类的值特别大（因为它的$x$值低）。皮肤病学数据集中的$f_{21}$对应于“乳头上皮表皮变薄”特征，该特征通常与牛皮癣的皮肤状况有关。在下图的可视化中，红色类别对应于牛皮癣的诊断（类别标签）$-$实际上，红色实例出现在图的左侧，这与从中减去$f_{21}$的值一致。 临床医生可以使用这种分析方法来理解，仅此功能就可以用于以合理的准确性诊断牛皮癣，并且还可以对可视化的准确性提供更大的信心。</li>
</ul>
</li>
<li><p>不过作者的几个案例有点并不连贯，例如在复杂度更高的模型中，$f_{21}$特征就不再起作用了。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1588324797409.png" alt="1588324797409"></p>
</li>
<li><p>分析：我觉得我们做实验的时候要重点对比这一点，如果我们的解决方案选择的特征在不同的模型复杂度上可以得到保持，这可能更有利于用户的理解。</p>
</li>
</ul>
</li>
<li><p>随着模型复杂度的增加，Cost Function上出现明显的收益递减，并且模型中叶开始出现更多的非线性节点。并且作者没有分析复杂度超过100的模型，因为“我们不会尝试对复杂性超过100的模型进行详细分析，因为这些树变得难以解释，并最终像t-SNE一样成为黑匣子。 本文的主要目的是产生可解释的高质量（而不是最先进的）可视化，以便根据其使用的特征对数据集中的关系提供更深入的了解。 如果可视化质量是主要目标，那么考虑到t-SNE之类的方法不受限于寻找从原始特征空间到可视化轴的功能映射，则它们将更为合适。 尽管无法正确解释非常复杂的GP树，但它们对于GP-tSNE算法仍然很重要。”</p>
<ul>
<li>分析：从上述描述可知，作者的可解释的非线性模型的可解释性并不像我们想象的那么有效，对于复杂的模型，依然难以解释，所以我认为我们的技术方案依然是有科研价值的。</li>
</ul>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>在本段作者指出了他们的解决方案在可解释性上存在的局限性，但是同时指出这是解决此类问题的第一个多目标GP方法，因此他们认为他们的研究依然很有科研价值。</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可理解性</tag>
        <tag>非线性降维</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-160.相交链表</title>
    <url>/2020/05/10/LeetCode-160/</url>
    <content><![CDATA[<h2 id="LeetCode-160-相交链表"><a href="#LeetCode-160-相交链表" class="headerlink" title="LeetCode-160.相交链表"></a>LeetCode-160.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<p><img src="/2020/05/10/LeetCode-160/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p><img src="/2020/05/10/LeetCode-160/160_example_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p><img src="/2020/05/10/LeetCode-160/160_example_2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p><img src="/2020/05/10/LeetCode-160/160_example_3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>如果两个链表没有交点，返回 null</li>
<li>在返回结果后，两个链表仍须保持原有的结构</li>
<li>可假定整个链表结构中没有循环</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>因为时间复杂度O(n)和空间复杂度O(1)的要求，所以我们可知，只能遍历固定次数链表，且不能根据数据规模开辟内存空间。</li>
<li>两个链表可能是不等长的，并且如果存在交点，交点肯定不在不等长的那部分。</li>
<li>首先遍历两个链表，确定两个链表的长度，Lengtha，Lengthb。</li>
<li>根据Lengtha和Lengthb的长度调整两个链表为等长的</li>
<li>遍历比较两个链表的首节点是否相等<ul>
<li>不相等将首节点下一个节点置为首节点</li>
<li>相等跳出遍历</li>
</ul>
</li>
<li>如果首节点不为空，则存在交点；如果为空，则不存在交点</li>
</ul>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Lengtha = <span class="number">0</span>,Lengthb = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmpa = headA,*tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmpa)&#123;</span><br><span class="line">            ++Lengtha;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpb)&#123;</span><br><span class="line">            ++Lengthb;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpa = headA,tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(Lengtha != Lengthb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Lengtha &lt; Lengthb)&#123;</span><br><span class="line">                --Lengthb;</span><br><span class="line">                tmpb = tmpb-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --Lengtha;</span><br><span class="line">                tmpa = tmpa-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpa!=tmpb)&#123;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpa)</span><br><span class="line">            <span class="keyword">return</span> tmpa;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-206.反转链表</title>
    <url>/2020/05/02/LeetCode-206/</url>
    <content><![CDATA[<h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode-206.反转链表"></a>LeetCode-206.反转链表</h2><p>反转一个单链表。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>反转链表，就是让后面的节点指向前面的节点。</p>
<p>如果是迭代执行，使用头插就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *h = head,*tmp = h;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    h-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        tmp-&gt;next = h;</span><br><span class="line">        h = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是递归执行，则从尾向头反转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *ans = func(head);</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">func</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *ans = func(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归/非递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-169.多数元素</title>
    <url>/2020/05/04/LeetCode-169/</url>
    <content><![CDATA[<h2 id="LeetCode-169-多数元素"><a href="#LeetCode-169-多数元素" class="headerlink" title="LeetCode-169.多数元素"></a>LeetCode-169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>因为多数元素数量大于n/2，所以我们只需要统计投票数：（因为只有众数的投票数不为0）</p>
<ul>
<li><p>如果当前数字和记录数一致，投票加1</p>
</li>
<li><p>如果当前数字和记录数不一致，投票减1</p>
<ul>
<li>如果减一后投票数为0，则更新记录数</li>
</ul>
</li>
</ul>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record = nums[<span class="number">0</span>],count = <span class="number">1</span>,i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == record)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">if</span>(!count)</span><br><span class="line">                &#123;</span><br><span class="line">                    record = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21.合并两个有序链表</title>
    <url>/2020/05/05/LeetCode-21/</url>
    <content><![CDATA[<h2 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode-21.合并两个有序链表"></a>LeetCode-21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>选取两个链表中较小的头节点作为合并链表的头结点，然后按从小到大顺添加两个链表的头节点到合并链表上</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>,*tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-226.翻转二叉树</title>
    <url>/2020/04/30/LeetCode-226/</url>
    <content><![CDATA[<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode-226.翻转二叉树"></a>LeetCode-226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><h2 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h2><p>这题就是交换二叉树的左右节点。因为你交换二叉树的左右节点，是不会影响到父节点和子节点的。即交换完，你的父节点还是你的父节点，你的子节点还是你的子节点。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *tmp = <span class="literal">nullptr</span>,*tmp2 = <span class="literal">nullptr</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp2 = q.front();</span><br><span class="line">            tmp = tmp2-&gt;left;</span><br><span class="line">            tmp2-&gt;left = tmp2-&gt;right;</span><br><span class="line">            tmp2-&gt;right = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;left)</span><br><span class="line">                q.push(tmp2-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;right)</span><br><span class="line">                q.push(tmp2-&gt;right);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23.合并K个排序链表</title>
    <url>/2020/04/26/LeetCode-23/</url>
    <content><![CDATA[<h2 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23.合并K个排序链表"></a>LeetCode 23.合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="循环合并最后两个链表：花费时间168ms"><a href="#循环合并最后两个链表：花费时间168ms" class="headerlink" title="循环合并最后两个链表：花费时间168ms"></a>循环合并最后两个链表：花费时间168ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *a = <span class="literal">nullptr</span>,*b = <span class="literal">nullptr</span>,*c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        b = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        c = marge(a,b);</span><br><span class="line">        lists.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用分治法：耗时24ms"><a href="#使用分治法：耗时24ms" class="headerlink" title="使用分治法：耗时24ms"></a>使用分治法：耗时24ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">margeFunc</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low+<span class="number">1</span> == high)</span><br><span class="line">    	<span class="keyword">return</span> lists[low];</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    ListNode *ls = margeFunc(lists,low,middle);</span><br><span class="line">    ListNode *rs = margeFunc(lists,middle,high);</span><br><span class="line">    ListNode *s = marge(ls,rs);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">    ans = margeFunc(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用优先队列：耗时48ms"><a href="#使用优先队列：耗时48ms" class="headerlink" title="使用优先队列：耗时48ms"></a>使用优先队列：耗时48ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](ListNode* &amp;a,ListNode* &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)&gt; que(comp);</span><br><span class="line">    ListNode *Head = <span class="literal">nullptr</span>,*temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != lists.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])</span><br><span class="line">        &#123;</span><br><span class="line">			que.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Head)</span><br><span class="line">        &#123;</span><br><span class="line">            Head = temp = que.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = que.top();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            que.push(temp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分需要注意，构造优先队列的第三参数时仿函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-283.移动零</title>
    <url>/2020/05/07/LeetCode-283/</url>
    <content><![CDATA[<h2 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode-283.移动零"></a>LeetCode-283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ul>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ul>
<li>我们使用双指针i，j来解决这个问题</li>
<li>其中i指向数组中第一个为0的位置，j指向i后第一个非0的位置</li>
<li>因为i，j之间只有两种关系：<ul>
<li>i，j相同。此时num[i] == num[j]。因此我们++i,++j来找到第一个不为0的num[i]</li>
<li>i，j不同。此时i，j之间没有非零数，所以当nums[i] != 0时，nums[j] == 0。因此我们++i,++j来找到第一个不为0的num[i]</li>
<li>因此这两种情况都需要++i,++j</li>
</ul>
</li>
</ul>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;j != nums.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j != nums.<span class="built_in">size</span>() &amp;&amp; !nums[j])++j;</span><br><span class="line">                <span class="keyword">if</span>(j != nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-33.搜索旋转排序数组</title>
    <url>/2020/04/27/LeetCode-33/</url>
    <content><![CDATA[<h2 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="LeetCode-33.搜索旋转排序数组"></a>LeetCode-33.搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>1.本质上还是二分查找，但是对排序数组旋转后，需要做一些判断确定下一次的检索区域</p>
<p>2.当middle &lt; target时，我们需要判断low-&gt;middle是否为一个连续区间，如果成立，那么target只会在middle和high之间，因为low-&gt;middle都 &lt; target。如果low-&gt;middle不为一个连续区间，那么middle-&gt;high为一个连续区间，此时我们要判断high是否 &gt;= target，如果成立就在middle-&gt;high区间，反之在low-&gt;middle区间。</p>
<p>3.当middle &gt; target时，我们需要判断middle-&gt;high是否为一个连续区间，如果成立，那么target只会在low和middle之间，因为middle-&gt;high都 &gt; target。如果middle和high不为一个连续区间，那么low-&gt;middle为一个连续区间，此时我们要判断low是否 &lt;= target，如果成立就在low-&gt;middle区间，反之在middle-&gt;high区间。</p>
<p>Tag: 实际实现的时候，middle不被考虑在下一次的检索区域内，因为middle已经和target比较过了。</p>
<h2 id="代码实现：（耗时0ms）"><a href="#代码实现：（耗时0ms）" class="headerlink" title="代码实现：（耗时0ms）"></a>代码实现：（耗时0ms）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = nums.<span class="built_in">size</span>(),middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] == target)</span><br><span class="line">        	<span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt; nums[middle])</span><br><span class="line">            &#123;</span><br><span class="line">            	low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[high<span class="number">-1</span>] &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                	low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                	high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; nums[high<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            	high = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(nums[low] &lt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-437.路径总和III</title>
    <url>/2020/05/09/LeetCode-437/</url>
    <content><![CDATA[<h2 id="LeetCode-437-路径总和III"><a href="#LeetCode-437-路径总和III" class="headerlink" title="LeetCode-437.路径总和III"></a>LeetCode-437.路径总和III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1. 5 -&gt; 3
2. 5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="使用双递归完成："><a href="#使用双递归完成：" class="headerlink" title="使用双递归完成："></a>使用双递归完成：</h3><ul>
<li>第一层递归遍历起始节点</li>
<li>第二层递归遍历结束节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> func(root,sum) + pathSum(root-&gt;left,sum) + pathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (sum ? <span class="number">0</span> : <span class="number">1</span>) + func(root-&gt;left,sum) + func(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用前缀和"><a href="#使用前缀和" class="headerlink" title="使用前缀和"></a>使用前缀和</h3><ul>
<li>前缀和的定义是，路径上到当前节点为止的累加和（包括当前节点）</li>
<li>因此我们可以得到推论：A节点和B节点之间的节点和为B的前缀和与A的前缀和的差值。</li>
<li>那么给定B的前缀和与路径和，我们可以算出A的前缀和（A = B - val)</li>
<li>为了方便检索前缀和，我们可以使用Map管理前缀和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> count = <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> func(root,count,sum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;count,<span class="keyword">int</span> &amp;val,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum == val)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum-val) != count.<span class="built_in">end</span>())</span><br><span class="line">            ans += count[sum-val];</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum) == count.<span class="built_in">end</span>())</span><br><span class="line">            count[sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++count[sum];</span><br><span class="line">        ans += func(root-&gt;left,count,val,sum);</span><br><span class="line">        ans += func(root-&gt;right,count,val,sum);</span><br><span class="line">        --count[sum];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>前缀和</tag>
        <tag>双递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-461.汉明距离</title>
    <url>/2020/04/29/LeetCode-461/</url>
    <content><![CDATA[<h2 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode-461.汉明距离"></a>LeetCode-461.汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>注意：<br>0 ≤ x, y &lt; $2^{31}$.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这题熟悉C++位运算即可。我们通过异或可以将两个数字中不同的位置1，然后计算不同的位的个数即可。</p>
<h2 id="位运算符简介："><a href="#位运算符简介：" class="headerlink" title="位运算符简介："></a>位运算符简介：</h2><p>位逻辑运算符：</p>
<p>​    &amp; （位   “与”）    and<br>​    ^ （位   “异或”）<br>​    | （位    “或”）   or<br>​    ~ （位   “取反”）<br>移位运算符：<br>​      &lt;&lt;（左移）<br>​      &gt;&gt;（右移）</p>
<p>优先级<br>位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != <span class="number">32</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">        	++count;</span><br><span class="line">        ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-448.找到所有数组中消失的数字</title>
    <url>/2020/05/08/LeetCode-448/</url>
    <content><![CDATA[<h2 id="LeetCode-448-找到所有数组中消失的数字"><a href="#LeetCode-448-找到所有数组中消失的数字" class="headerlink" title="LeetCode-448.找到所有数组中消失的数字"></a>LeetCode-448.找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ul>
<li>因为不能使用额外空间，且1 ≤ a[i] ≤ n,所以我们可以直接使用原数组完成hash</li>
<li>将被hash到的位置变成负数，因为1 ≤ a[i] ≤ n,所以值为负就可以确保该位置被hash到</li>
<li>最后统计值&gt;0的位置即可</li>
<li>时间复杂度O(2n),空间复杂度O(1)(如果不算返回值)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            j = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; <span class="number">0</span>)</span><br><span class="line">                nums[j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-617.合并二叉树</title>
    <url>/2020/04/28/LeetCode-617/</url>
    <content><![CDATA[<h2 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode-617.合并二叉树"></a>LeetCode-617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这道题还是很简单的，只需要判断当前合并节点在对应的两棵树上是否都不为空。如果都不为空，则继续遍历左右子树，否则直接返回另一棵不为空的树即可。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1 &amp;&amp; !t2)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">    	<span class="keyword">return</span> t1;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">    	<span class="keyword">return</span> t2;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-538.把二叉搜索树转换为累加树</title>
    <url>/2020/05/06/LeetCode-538/</url>
    <content><![CDATA[<h2 id="LeetCode-538-把二叉搜索树转换为累加树"><a href="#LeetCode-538-把二叉搜索树转换为累加树" class="headerlink" title="LeetCode-538.把二叉搜索树转换为累加树"></a>LeetCode-538.把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<h2 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>因为是二叉搜索树，所以左子树&lt;根节点&lt;右节点</li>
<li>所以转换成累加树，我们只需要从最右向最左遍历树，并且将当前节点的值设为已遍历节点值的和（已遍历节点包括当前节点）</li>
</ul>
<h3 id="递归方法："><a href="#递归方法：" class="headerlink" title="递归方法："></a>递归方法：</h3><ul>
<li>直接按解题思路遍历树即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            val += root-&gt;val;</span><br><span class="line">            root-&gt;val = val;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><ul>
<li>非递归方法先找到当前节点的右子节点</li>
<li>然后再遍历当前的左子节点，如果没有则回溯</li>
<li>回溯过程和遍历左子节点过程要区分开，避免节点重复遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node)&#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            val += node-&gt;val;</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归/非递归</tag>
      </tags>
  </entry>
  <entry>
    <title>PaperExamRecord-2020-5-9</title>
    <url>/2020/05/09/PaperExamRecord-2020-5-9/</url>
    <content><![CDATA[<h2 id="SwissRoll局部线性近似实验分析"><a href="#SwissRoll局部线性近似实验分析" class="headerlink" title="SwissRoll局部线性近似实验分析"></a>SwissRoll局部线性近似实验分析</h2><ul>
<li><h3 id="SwissRoll-ISOMAP分片示意图："><a href="#SwissRoll-ISOMAP分片示意图：" class="headerlink" title="SwissRoll ISOMAP分片示意图："></a>SwissRoll ISOMAP分片示意图：<img src="/2020/05/09/PaperExamRecord-2020-5-9/1589023174018.png" alt="1589023174018"></h3></li>
<li><h3 id="SwissRoll分片树示意图："><a href="#SwissRoll分片树示意图：" class="headerlink" title="SwissRoll分片树示意图："></a>SwissRoll分片树示意图：</h3><p><img src="/2020/05/09/PaperExamRecord-2020-5-9/1589022936862.png" alt="1589022936862"></p>
</li>
</ul>
<ul>
<li><h3 id="SwissRoll三维模型示意图：（图片中的数字对应分片号）"><a href="#SwissRoll三维模型示意图：（图片中的数字对应分片号）" class="headerlink" title="SwissRoll三维模型示意图：（图片中的数字对应分片号）"></a>SwissRoll三维模型示意图：（图片中的数字对应分片号）</h3></li>
</ul>
<p><img src="/2020/05/09/PaperExamRecord-2020-5-9/1589022188714.png" alt="1589022188714"></p>
<ul>
<li><h3 id="局部参数映射列表：维度顺序是（z-y-x"><a href="#局部参数映射列表：维度顺序是（z-y-x" class="headerlink" title="局部参数映射列表：维度顺序是（z,y,x)"></a>局部参数映射列表：维度顺序是（z,y,x)</h3></li>
</ul>
<table>
     <tr>
        <td>分片标号</td>
        <td>原始特征在X轴上的相关性</td>
        <td>原始特征在Y轴上的相关性</td>
     </tr>
     <tr>
        <td>1</td>
        <td>-0.24</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0.01</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.96</td>
        <td>-0.03</td>
     </tr>
     <tr>
        <td>2</td>
        <td>-0.81</td>
        <td>0.04</td>
     </tr>
     <tr>
        <td></td>
        <td>0.02</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.59</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td>3</td>
        <td>-0.99</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.16</td>
        <td>0.05</td>
     </tr>
     <tr>
        <td>4</td>
        <td>-0.62</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.78</td>
        <td>0</td>
     </tr>
     <tr>
        <td>5</td>
        <td>0.2</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.02</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.98</td>
        <td>0</td>
     </tr>
     <tr>
        <td>6</td>
        <td>0.34</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.01</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.94</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td>7</td>
        <td>0.73</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0.03</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.68</td>
        <td>0.02</td>
     </tr>
     <tr>
        <td>8</td>
        <td>1</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.11</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td>9</td>
        <td>0.57</td>
        <td>0.04</td>
     </tr>
     <tr>
        <td></td>
        <td>0.03</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.82</td>
        <td>-0.01</td>
     </tr>
     <tr>
        <td>10</td>
        <td>0.07</td>
        <td>-0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>1</td>
        <td>-0.02</td>
     </tr>
     <tr>
        <td></td>
     </tr>
  </table>

<ul>
<li><h3 id="分析结论："><a href="#分析结论：" class="headerlink" title="分析结论："></a>分析结论：</h3><ul>
<li>ISOMAP在展开SwissRoll数据集时，二维投影的Y轴与数据集本身的第二维(Y）一一对应。<ul>
<li>所有分片的Y轴与SwissRoll的第二维（Y）相关程度都为-1</li>
</ul>
</li>
<li>ISOMAP在展开SwissRoll数据集时，不同分片的X轴与原始特征之间的关系呈现出可解释的规律：<ul>
<li>1,5,6,10等接近水平的分片，X轴与第三维（X）的相关性更强。</li>
<li>3,8等接近垂直的分片，X轴与第一维（Z）的相关性更强</li>
<li>根据分片在三维空间中的分布，X轴与第一维（Z）和第三维（X）的相关性一直在规律性的变化<ul>
<li>1-》2-》3，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直</li>
<li>4-》5，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li>
<li>6-》7-》8，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直<ul>
<li>其中7存在Z和X相关性接近的情况，这是因为7在Z和X上的可分性都很好</li>
</ul>
</li>
<li>8-》9-》10，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li>
<li>根据上述实验结果的分析，我认为我们方法生成的参数映射是连续的，并可以利用参数映射连续性来分析分片之间的非线性变化。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>论文实验</category>
      </categories>
      <tags>
        <tag>局部线性近似</tag>
        <tag>SwissRoll</tag>
      </tags>
  </entry>
</search>
