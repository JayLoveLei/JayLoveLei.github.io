<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GP-tSNE论文重构</title>
    <url>/2020/05/08/GP-tSNEReconstruct/</url>
    <content><![CDATA[<h2 id="GP-tSNE论文重构"><a href="#GP-tSNE论文重构" class="headerlink" title="GP-tSNE论文重构"></a>GP-tSNE论文重构</h2><p>高维数据投影是</p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>论文重构</tag>
        <tag>可理解性</tag>
      </tags>
  </entry>
  <entry>
    <title>批判性思维-阅读笔记</title>
    <url>/2020/05/03/CRITICAL-THINKING/</url>
    <content><![CDATA[<h1 id="批判性思维基础"><a href="#批判性思维基础" class="headerlink" title="批判性思维基础"></a>批判性思维基础</h1><h2 id="什么是批判性思维"><a href="#什么是批判性思维" class="headerlink" title="什么是批判性思维"></a>什么是批判性思维</h2><ul>
<li>但归结起来，批判性思维就是指审慎地运用推理去断定一个断言是否为真</li>
<li>批判性思维技能列表：<ul>
<li>判断信息是否恰当</li>
<li>区分理性的断言与情感的断言</li>
<li>区别事实与观点</li>
<li>识别证据的不足</li>
<li>洞察他人论证的陷阱和漏洞</li>
<li>独立分析数据或信息</li>
<li>识别论证的逻辑错误</li>
<li>发现信息和其来源之间的联系</li>
<li>处理矛盾的、不充分的、模糊的信息</li>
<li>基于数据而不是观点建立令人信服的论证</li>
<li>选择支持力强的数据</li>
<li>避免言过其实的结论</li>
<li>识别证据的漏洞并建议收集其他信息</li>
<li>知道问题往往没有明确答案或唯一解决办法</li>
<li>提出替代方案并在决策时予以考虑</li>
<li>采取行动时考虑所有利益相关的主体</li>
<li>清楚地表达论证及其语境</li>
<li>精准地运用证据为论证辩护</li>
<li>符合逻辑地组织复杂的论证</li>
<li>展开论证时避免无关因素</li>
<li>有序地呈现增强说服力的证据</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="基本概念：断言、论题和论证"><a href="#基本概念：断言、论题和论证" class="headerlink" title="基本概念：断言、论题和论证"></a>基本概念：断言、论题和论证</h2><ul>
<li>构成批判性思维的基本要素是断言（claims），论题（issues）和论证（arguments）</li>
<li>断言：陈述（statements）或断言（我们在相同的意义上使用这两个概念）区分为真的或假的</li>
<li>论题：当我们对一个断言进行审查的时候，即当我们探究断言之真假时，我们就提出了一个论题。批判性思维主要关注这样一类断言：被论证支持或反驳的论题。“论题”实际上就是“问题”（question），我们可以互换地使用这两个概念。“问题”就是指某个特定的断言是否真实。解决问题就是对断言的真假做出回答。</li>
<li>论证：一旦我们清楚了论题是什么，下一步就是评价支持或反驳这个断言的论证，并断定论题的真假。论证是批判性思维的最重要因素，尽管论证可以很复杂，但究其实质，论证的概念很简单：我们从事论证是为了给一个断言的真提供理由。论证由前提（premise）和结论（conclusion）构成。前提是为另一个断言提供理由的断言，被前提支持的断言是论证的结论。</li>
<li>我们将会发现，在实际生活的境况中，重要而且往往困难的是准确识别到底什么是有问题的断言，即论题到底是什么。我们识别论题的困难是由多种原因导致的，从有意混淆到含混的术语以及思想本身的混乱等。</li>
<li>对于如何审查一个断言而言，关键是知道如何支持或反驳这个断言的真假。如果我们不知道如何确定断言的真假，对于如何通过论证支持或反驳断言我们就束手无策。</li>
<li>如果无从知道一个断言何时为真何时为假，谈论断言的真假就没有意义。换句话说，只有针对清楚地表达意思的断言、一个合乎语法的断言，我们才能谈论它的真假。</li>
<li>好论证的标准有待进一步阐述，但目前需要指出两点：第一，支持结论的前提必须是真的。一个论证的前提的真往往需要新的论证来支持，这样，一个论证的前提就是新论证的结论；第二，前提和结论必须是相关的。相关的要求是指：前提为真的确能增加结论为真的可能性。</li>
</ul>
<h2 id="论证与解释"><a href="#论证与解释" class="headerlink" title="论证与解释"></a>论证与解释</h2><ul>
<li>1.洛勒头疼因为他脑袋里有钉子。</li>
<li>2.洛勒该上医疗保险因为他不能支付医疗费。</li>
<li>这两个表达都是“X，因为Y”。论证包含两部分，其中一部分（前提）是据以认为另一部分（结论）为真的理由。表达2是论证，因为洛勒不能支付医疗费是据以认为他该上医疗保险的理由。与之相对，表达1中，洛勒脑袋里有钉子不是据以认为他头疼的理由。对洛勒而言，不需要理由他也能知道自己头疼。“他脑袋里有钉子”不是证明洛勒头疼的理由，而是表明引起他头疼的原因。</li>
<li>从根本上说，论证是为了支持或证明结论，而解释是为了指明某事物的原因、它如何运作或它是如何制作的等。论证一条狗身上有跳蚤和解释狗身上有跳蚤的原因是不同的思维，论证暴力犯罪的增加也不同于解释犯罪率升高的原因。提出对荷兰榆树病的解释也不同于证明该解释是正确的。尽管解释和论证容易被混淆，但这是两种不同的思维。</li>
<li>就像“农民不需要干旱，国家森林不需要修路”，这样的表达是要告诉大家：对于国家森林，修路不是好事。但这只是从不利的角度来描述在国家森林边修路，这样的表达不是论证。有人把论证界定为说服某人接受某种观点，但这并不正确。论证是证明或支持某结论，而说服某人是赢得他同意你的观点。从逻辑的观点看，论证和说服是不同的思维。的确，试图说服别人时往往要运用论证。但论证并不总是用于说服，说服往往也不一定借助于论证。</li>
</ul>
<h2 id="两种好的论证"><a href="#两种好的论证" class="headerlink" title="两种好的论证"></a>两种好的论证</h2><ul>
<li>逻辑学家将好的论证分为两类：好的演绎论证和好的非演绎论证。</li>
<li>好的演绎论证（deductive arguments）被称为“有效的”。一个论证是有效的，指该论证不可能出现前提为真而结论为假的情形。</li>
<li>好的非演绎论证（inductive arguments）的前提并不证明其结论。非演绎论证的前提支持结论。也就是说，如果非演绎论证的前提为真，那么就提高了其结论为真的可能性。</li>
</ul>
<h2 id="识别论证"><a href="#识别论证" class="headerlink" title="识别论证"></a>识别论证</h2><ul>
<li>无论是演绎论证还是非演绎论证，都由两部分构成。其中一个部分提供让我们相信另一部分的理由。论证的根本标识词为“所以”之类的词语。构成论证至少要有两个断言，而且各断言间（或明示的或暗示的）以“所以”等词语连接。</li>
<li>论证的提示词是识别论证的指南。除了“所以”之外，论证之结论的提示词还有：<ul>
<li>由此得出……</li>
<li>这表明……</li>
<li>于是……</li>
<li>因此……</li>
<li>结果……</li>
<li>我的结论是……</li>
</ul>
</li>
<li>论证的前提也有其指示词，如：<ul>
<li>既然……</li>
<li>因为……</li>
<li>由于……</li>
<li>依据……</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>断言：表达意见或信念的陈述；真或假。</li>
<li>论证：由断言按一定结构形成的两部分，其中一部分（前提）为另一部分（结论）的真提供理由。</li>
<li>论题/问题：因探究问题而提出的断言。</li>
<li>有效的演绎论证：该类论证的前提真意味着其结论一定真。</li>
<li>强的非演绎论证：前提为结论提供的支持越多，非演绎论证越强。</li>
<li>价值判断：表达对事物评价的断言。</li>
<li>道德价值判断：表达对事物道德或伦理评价的断言。</li>
<li>修辞：具有心理上的说服力，但并不增加逻辑力量的语言。</li>
<li>影响批判性思维的错误观念：<ul>
<li>假定所有的价值判断都是主观的。</li>
<li>混淆论证和解释。</li>
<li>混淆论证和说服。</li>
<li>混淆修辞与逻辑，误以为心理说服力越强的论证逻辑力量越强。</li>
</ul>
</li>
</ul>
<h1 id="两种推理（论证）"><a href="#两种推理（论证）" class="headerlink" title="两种推理（论证）"></a>两种推理（论证）</h1><h2 id="论证：基本特征"><a href="#论证：基本特征" class="headerlink" title="论证：基本特征"></a>论证：基本特征</h2><ul>
<li>结论指示词：论证中运用下列语词，通常表示就已经给出的前提将要得出结论（“……”表示结论）<ul>
<li>于是……</li>
<li>结果……</li>
<li>所以……</li>
<li>因此……</li>
<li>这表明……</li>
<li>这蕴涵……</li>
<li>这显示……</li>
<li>这证明……</li>
</ul>
</li>
<li>前提指示词：论证中运用下列语词，通常是引入前提。这些词语往往也在给出的结论之后出现。“……”代表实际论证中的前提。<ul>
<li>既然……</li>
<li>因为……</li>
<li>由于……</li>
<li>依据……</li>
</ul>
</li>
</ul>
<h2 id="两种论证"><a href="#两种论证" class="headerlink" title="两种论证"></a>两种论证</h2><ul>
<li>演绎论证：对于一个演绎论证，如果其前提为真，则证明了其结论。乍看起来这很简单。但为了阐明问题，我们先学习演绎逻辑的基本概念：有效。当一个论证满足条件：当其前提为真时，其结论不可能为假，这个论证就是有效的。</li>
<li>非演绎论证：与演绎论证的前提证明结论不同，非演绎论证的前提并不证明结论，非演绎论证的前提支持结论。</li>
</ul>
<h2 id="演绎，非演绎和未表达前提"><a href="#演绎，非演绎和未表达前提" class="headerlink" title="演绎，非演绎和未表达前提"></a>演绎，非演绎和未表达前提</h2><ul>
<li>实际生活中的论证往往包含未表达前提。通过不同的方式补充未表达前提，可以形成非演绎论证，也可以形成演绎论证。通常上下文和语境能帮助我们理解论证者的意图，但也有时候语境不能帮助我们解决问题。后一种情形下，通过考虑各种因素，所补充的未表达前提至少应该是可信的。</li>
</ul>
<h2 id="理解论证的技术"><a href="#理解论证的技术" class="headerlink" title="理解论证的技术"></a>理解论证的技术</h2><ul>
<li>为了理解论证，首先要发现结论或某语篇的主要观点。其次，要找出为得出结论而陈述的种种理由，即寻找前提。接着，再发现针对前提的论证（如果有）。为了展开上述步骤，需要在口头表达或书面论证中准确发现前提或结论并且理解这些断言之间的相互联系——即论证的结构。</li>
</ul>
<h2 id="评估论证"><a href="#评估论证" class="headerlink" title="评估论证"></a>评估论证</h2><ul>
<li>批判性思维要求我们评估论证。评估论证分为两个方面：逻辑和真假</li>
<li>一方面我们从逻辑的角度评估论证：该论证是在证明还是在支持其结论？这是一个有效的演绎论证还是较强的非演绎论证？从理论上说，到目前为止，你已能明白这些问题在表达什么意思；随着深入学习本书，你就能针对实际论证回答这些问题。</li>
<li>另一方面我们从真假的角度评估论证。论证的前提确实为真吗？在第4章中，我们将解释，就像对于缺乏可靠信息来源的前提一样，对于与背景信息以及其他可靠信息相冲突的前提，我们最好提出质疑。在第5章、第6章和第7章中，我们将告诫大家避免落入修辞或心理的误区。在第3章中，我们要提请注意，在接受前提之前必须弄清其表达的准确含义。通常，确定前提的真假依赖于知识、经验、冷静的头脑和乐于深入调查。</li>
</ul>
<h2 id="总结（推理-论证）"><a href="#总结（推理-论证）" class="headerlink" title="总结（推理==论证）"></a>总结（推理==论证）</h2><ul>
<li>论证由前提和结论组成，推理的前提可以不止一个。</li>
<li>同一个命题可以是一个推理的前提，又是另一个推理的结论。</li>
<li>推理分为两种：演绎论证和非演绎论证。</li>
<li>如果演绎推理是可靠的，就可以证明其结论为真。</li>
<li>可靠的推理是前提为真的有效推理。</li>
<li>有效的推理不会出现前提为真而结论为假的可能。</li>
<li>非演绎推理不是证明结论，而是为结论提供支持。</li>
<li>支持程度有高低之分：支持程度决定于前提使得结论为真的可能性的高低。</li>
<li>支持程度高的非演绎推理较强，支持程度低的非演绎推理较弱。</li>
<li>演绎推理和非演绎推理都可能含有未表达的前提。</li>
<li>一个推理是演绎推理还是非演绎推理可能决定于未表达的前提到底是什么。</li>
<li>如果难以把握文章中的论证，试着刻画其论证结构图。</li>
</ul>
<h1 id="清晰地思维、批判性思维与清晰的写作"><a href="#清晰地思维、批判性思维与清晰的写作" class="headerlink" title="清晰地思维、批判性思维与清晰的写作"></a>清晰地思维、批判性思维与清晰的写作</h1><ul>
<li>尽管多种因素都可能导致表达的含混不清，但其中最主要的原因可以归结为如下四点：过度模糊、歧义、过于抽象、未定义术语。本章将在深入探讨模糊、歧义和抽象后阐述定义。</li>
<li>写作的时候也常常需要进行批判性思维，在论文写作时尤其如此。在论文中，需要表达对论题的立场，还要提供支持该立场的论证。优秀的论文通常由四部分构成：陈述论题、表明对论题所持的立场、提供支持立场的论证、对支持相反立场的论证展开反驳。显然，如果论文中的陈述含混不清，当然会削弱论证的力量。本章中，我们还将具体指导如何清晰地写作。</li>
</ul>
<h2 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h2><ul>
<li>无论是思维还是写作中，最常见的含混是模糊（vaguness）。仔细探究起来，模糊的概念相当复杂。过去几十年中哲学家们就集中对这个概念展开了深入研究。不过就应用的层面来讲，不难把握这个概念。词语或短语的模糊是指：与该词语或短语相对应的对象是不明确的。<ul>
<li>“秃头”就是模糊的。帕里斯·希尔顿不是秃头及帕特里克·斯图尔特是秃头都是无可争议的，但对于生活中另外很多人是否秃头就难有定论。“秃头”概念是否可以指上述两类极端人群之间的人，就是不明确的。正因如此，“秃头”是模糊概念。</li>
</ul>
</li>
<li>模糊的程度各不相同。至于何等模糊度是可接受的，除了借助于适度的注意和常识以外并没有一成不变的答案。但可以这样认定：如果某断言不至于因为模糊而不能恰当地表达有用的信息，其模糊度就是可接受的。<ul>
<li>在上面说到的指路的例子中，如果其指引足以让我们顺利找到目的地，指引中的模糊度就是可接受的。如果政治人物在其税收计划中足够清楚地说明该计划将如何实施，我们就不能抱怨它的模糊性。但如果在表达中夹杂着过度的模糊以至于我们难以甚至不能理解其中的断言，具有批判性思维能力的人就会要求表达者负责澄清。</li>
</ul>
</li>
</ul>
<h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><ul>
<li>具有多重含义的语词、短语或句子被称为歧义（ambiguity）。<ul>
<li>“保罗兑付了现金”指别人给了保罗现金还是保罗给了别人现金呢？两者都有可能。“杰西卡在租房子”可以指杰西卡把房子租给别人，也可以指别人把房子租给杰西卡。周五下午，珍妮弗从座位上站起来说：“我这儿的工作已经做完了。”珍妮弗的意思可能指完成了手中项目的工作报告，也可能指她完成了一周的工作可以去度周末了，还有可能指她已经厌倦了这儿的工作打算离开这家公司。如果你访问网站，不难发现各种引人发笑的歧义。对于引人发笑的歧义，通常我们知晓表达者利用歧义的意图。</li>
</ul>
</li>
<li>歧义的最常见情形是语义歧义（semantic ambiguity），即表达断言的语句中含有歧义的语词或短语.例：<ul>
<li>Jessica is cold.</li>
<li>Aunt Delia never used glasses.</li>
<li>例1可能在描述杰西卡的体温低，也可能在描绘杰西卡的个性冷漠；例2可能在说德里亚姑姑的视力好，也可能在说德里亚姑姑直接用瓶子而不用杯子喝啤酒。通过用不带歧义的语词来替换产生歧义的语词就可以消除语句中的歧义，如将例2中的”glasses”替换为”eyeglasses”（眼镜）就可以消除该句的歧义。</li>
</ul>
</li>
<li>组合歧义（grouping ambiguity）是一种特殊的语义歧义。当不能明确区分一个语词指集合体，还是指构成该集合体的个别成员时，就出现了组合歧义。<ul>
<li>语句“秘书挣的钱比医生多”中，如果“秘书”和“医生”分别指这两类从职人员的总体，这个句子或许是真的，因为从事秘书工作的人远比从事医生工作的人多；但若这两个语词分别指个体，这句话显然是假的。</li>
<li>骑越野摩托车的人或许为自己的癖好辩护说：“割草机比越野摩托车制造的污染更多。”因为这个表达中存在歧义，它既可以被解释为真的，也可以被解释为假的。作为总体来说，割草机制造的污染的确较多，因为割草机的数量远多于越野摩托车；但逐个进行比较，显然是越野摩托车制造的污染更多（毋庸讳言，越野摩托车还制造了大量恼人的噪音）。</li>
<li>对组合歧义进一步分析，有两种源于组合歧义的常见谬误：分解谬误与合成谬误。从群体具有某特征推导出群体的每个成员也一定具有该特征，就犯了分解谬误（fallacyof division）。<ul>
<li>1973年的美国棒球联赛中，迈阿密海豚队获得了冠军，该队还参加了1974年的超级碗比赛。迈阿密海豚队是联盟该年度最优秀的球队乃不争的事实，由此就可以推出该队的队员就是联盟最好的队员吗？即由此可得出鲍勃·格里耶瑟是最好的四分卫、拉里·克斯卡是最好的后卫、默克里·莫里斯是最好的接球手吗？当然不能。整体的特征未必为构成整体的各独立部分所具有。正如圆形的建筑物不必由圆砖块建筑而成。</li>
</ul>
</li>
<li>从另一个方向去思考，即由成员都具有某特征为前提推出所有成员构成的整体也一定具有该特征，就犯了合成谬误（fallacy of composition）。<ul>
<li>例如，在民意测验中，众议院的每个议员都获得较高的评价，但如果由此推定民意测验也会给众议院较高评价就是错误的，因为通常在相同的民意测验中，众议院得到的评价较低。人们对部分的评价和对整体的评价未必相同。正如人们可以用方形砖块建造圆形建筑物。在专栏中你会看到更多关于分解谬误与合成谬误的实例。</li>
</ul>
</li>
</ul>
</li>
<li>语形歧义：一个句子的语法结构可以作两种以上的解释时，这个句子就含有语形歧义（syntactic ambiguity）。<ul>
<li>“去加拿大旅行，须携带出生证或驾照和其他附照片的身份证明。”这句话在说跨越美加边境到底有什么要求？按照一种解释，除携带出生证或驾照之外，还得携带其他附照片的身份证明；按照另一种解释，携带其他身份证明就不是必须的。下面用括号分别标出两种不同的解释：<ul>
<li>[须携带出生证或驾照]和[其他附照片的身份证明]</li>
<li>[须携带出生证]或[驾照和其他附照片的身份证明]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li>与模糊及歧义密切相关的一个概念就是抽象（generality），抽象的表达也会引起含混不清。我们已经知道“孩子”是模糊概念，因为我们不知道“孩子”和“非孩子”的界线到底在哪里。“孩子”也是歧义的，因为它既可以指未成年人，又可以指婴儿。这个概念也是抽象的，因为它既指男孩，又指女孩。大致说来，一个断言表达的内容越不具体，该断言就越抽象。就具体语词或短语X而言，”X”所指的范围越广，X越抽象。“摩尔有只狗”比“摩尔有只澳达猎犬”抽象，而更抽象的是“摩尔有宠物”。</li>
<li>模糊、歧义、抽象这些相互联系的有碍清晰思维的诸多概念，可能会让你觉得眼花缭乱。但实际上，重要的是发现问题，即识别表达或断言中哪些是不清晰的以及寻求如何解释它。至于给所发现的问题一个什么样的名称（到底是模糊、歧义还是抽象）并不重要。例如：如果有人随意地使用语词“战争”，你最好的反应就是问对方“你所说的‘战争’指什么”。</li>
</ul>
<h2 id="定义术语"><a href="#定义术语" class="headerlink" title="定义术语"></a>定义术语</h2><ul>
<li><p>定义的目的：定义的目的中最值得注意的有四种。</p>
<ul>
<li>告知词语的日常意义。为了弄清语词的意义，我们往往借助于字典。字典上所给的就是词典定义（lexical definition）。它告诉我们语词的通常含义，如“绢毛猴，名词，南美森林中的小猴，绒猴家族，色彩明亮，脸和脖子周围毛发丛生”。</li>
<li>约定在特定语境下的语词意义。为实现该目的而做出的定义叫约定定义（stipulative definition）。如，“这种情形下，‘桌面’指打开操作系统时显示屏所显示的含有回收站的状态”。也可以通过约定定义来给新发明的语词指派意义。2005年，在新开播的电视节目《科尔伯特报告》中，斯蒂芬·科尔伯特发明了新词汇”truthiness”。该词的约定意义为：未经证据、逻辑、理智或事实等的检验，仅凭直觉或“本能”被认定为真的事物。</li>
<li>减轻模糊、抽象或消除歧义。“本合同中，’dollars’指加元，而不是指美元或澳元。”为实现此种意图的定义被称为精确定义（precising definition）。</li>
<li>用于说服。这种定义为了提供语词的日常意义或各方约定的意义，因而不是真正意义上的定义，它被称为说服定义或修辞定义（persuasive or rhetoricaldefinitions）。尽管这种定义也和其他定义一样被列在定义的名录中，但值得注意的是，这类“定义”不仅仅包含着语言方面的信息，它的意图是影响人们的信念和态度。<ul>
<li>如果一个开明者试图把“保守者”“定义”为：认为生活的重心就是挣钱和盘剥穷人的刻板守旧、心胸狭窄的伪君子。这并不是为了澄清“保守”的意思，而是为了抨击保守者。这样的修辞定义往往借助于语词的情感意义（e-motive meaning）。有的人更愿意称之为修辞力（rhetorical force）。这样的意义包含着对语词所指对象的正面或负面评价。经历了多年对伊拉克的战争之后，美国民众中有的希望“带他们回家以支持部队”，有的希望“匆忙离开”。这两种人都表达了从伊拉克撤回美军的相同愿望，但不同表达的情感意义不同，成语“言外之意”就是描述与语词相关的情感意义的。前面说过的把“堕胎”定义为“谋杀未出生的孩子”就是常被引用的该类型的定义。</li>
</ul>
</li>
</ul>
</li>
<li><p>定义的种类：</p>
<ul>
<li>实指定义（ostensive definition）：即通过指明语词所指的对象或识别语词所指对象的典型例子来下定义。如：“我用‘圣典’指圣经、古兰经这样的文本”、“鼠标就是这个（展示实物）带有按键的东西”。</li>
<li>同义词定义（definition by synonym）：即给出与被定义术语具有相同意义的语词或短语。如：“‘吹毛求疵’与‘挑剔’意思相同”“‘悸动’意味着‘跳动’”。</li>
<li>分析定义（analytical definition）：确定被定义术语所指对象的必要特征从而明确术语所指的对象。这样的定义通常的形式是明确属和种。例如：“俄式茶壶是俄罗斯人用于烧水泡茶的壶”、“猫鼬是食蛇的与麝猫有亲缘关系的雪貂大小的哺乳动物”。字典上的定义大都是分析定义。</li>
</ul>
</li>
<li>定义的注意事项：<ul>
<li>首先，不能通过定义使论辩的任何一方处于不利境地。这里只需说明：如果对于关键术语的定义论辩双方没有形成共识，任何一方都不能仅通过对己有利的定义来赢得辩论。人们应该站在中立的立场来下定义。</li>
<li>其次，定义必须是清晰的。定义是用来澄清歧见而不是为了混淆视听。所以必须用简单清楚的语言来表述定义。如果用比被定义语言更含混的语言来下定义，不可能达成预期的目的。定义要清晰就要求尽可能避免在定义中使用诉求情感的语言。</li>
</ul>
</li>
</ul>
<h2 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h2><ul>
<li>论文通常由四部分组成：<ul>
<li>陈述论题</li>
<li>表明对论题所持的立场</li>
<li>提供支持立场的论证</li>
<li>对支持相反立场的论证展开反驳</li>
</ul>
</li>
<li>论文写作要点：<ul>
<li>论文的开端要通过描述论题的重要性和趣味性来介绍论题，这往往并不容易，纵然你自己未必对该论题感兴趣也要激发读者对它的兴趣。但你的陈述必须是中立的，即不能把你对论题的立场表述为唯一正确的立场。这会让读者怀疑你将展开的论证会成为劝说他的负担。</li>
<li>你对论题所持的立场必须是明确的，而且要尽量做到简明扼要。清晰地陈述论题会为识别你的立场提供捷径。</li>
<li>支持立场的论证要尽量言简意赅，但比简洁更重要的是清楚。毕竟这部分是论文的心脏。陈述的理由必须明显相关，这些理由如果不是显而易见的就需要其他论证的支持。</li>
<li>如果对论题的相反立场有著名的论证，你要列举这样的论证，并提供理由证明它缺乏说服力。你可以指出其前提不必为真，或该前提不能支持其结论。</li>
</ul>
</li>
<li>写作指导：<ul>
<li>中心突出。文章的开篇就要陈述论题、表明立场，但这不等于用呆板的语言罗列清单：“本文将论证X、Y和Z”，然后逐一论证所列各项，最后总结：“本文论证了X、Y和Z”。陈词滥调的文风不可能引人入胜。“你会因为母亲的猫而减少该被继承的遗产吗？”比“本文将讨论动物继承其主人遗产的问题”能让读者更加饶有兴味地继续关注你的论题或立场。</li>
<li>紧扣主题。论文中所表达的要点要与讨论的主题密切相连，各要点只能服务于两个目的：<ul>
<li>（a）对所持立场的说明、解释、澄清、阐述；</li>
<li>（b）对持相反观点者的回应。要删除无关的论述和没有针对性的思想。</li>
</ul>
</li>
<li>按照一定的逻辑顺序谋篇布局。在你为支持自己的观点举例或澄清的时候，要让读者明白你到底在做什么。要让读者明白你给出的语句与你的最终目的之间是什么关系。如果读者在通读你的文章后依然不知所云，抓不住你的要旨，说明你没有适当地组织材料。这类洋洋洒洒的文章或许类似法国哲人的大作，但作为议论文它是不合格的。</li>
<li>结构完整。文章的结构要力求完整：充分支持自己的观点，反驳已知的对立观点，并对可能反驳自己的意见进行回应。许多论题都不可能仅在一篇论文中作穷尽的论述，关键在于要集中探讨论题的某一方面，从而完整地论述它。所以，越明确地限定话题，越容易完整地驾驭它。<ul>
<li>可以从不同层面来理解结构完整——句子要完整，段落要完整（每一段落要紧扣一个观点），整篇文章要有结论。值得注意的是，形成文章的结论和总结文章不是一回事。短篇论文并不需要总结。</li>
</ul>
</li>
</ul>
</li>
<li>如何练习写作：<ul>
<li>初步组织材料后，列出写作提纲。然后，确认提纲是否合乎逻辑、文中逐词逐句是否都适合提纲的需要。有的作者在着手之前就先拟非正式的提纲。我们的建议是：先要识别论题和你的立场，文章开篇就要表明二者。</li>
<li>修改你的作品。修改是让文章优秀的秘诀，即使是专栏作家们也需要不断修改他们的作品。除非你比职业作家更具天赋，对自己的文章要修改、修改、再修改。不要只打算二易其稿或三易其稿，要准备不厌其烦、千推万敲。</li>
<li>如果有人读完你的文章后提出批评，按照他的意见修改。</li>
<li>如果在语法或拼写上有困难，大声朗读文章可以帮你发现默读时错过的问题。</li>
<li>对自己的文章完全满意后，把它搁在一边，隔段时间再进一步修改。</li>
</ul>
</li>
<li><p>写作中好的文风：</p>
<ul>
<li>避免陈词滥调</li>
<li>尽量具体</li>
<li>不要抽象</li>
<li>避免被动语句</li>
<li>不要啰嗦</li>
<li>夸大其词远不如谨慎陈述</li>
<li>保证主语与谓语的一致</li>
<li>为什么运用修辞手段</li>
<li>无论多么相关，插入的定论都不是必需的</li>
<li></li>
</ul>
</li>
<li><p>论文写作的误区：</p>
<ul>
<li>废话连篇：不是直接切入论题，而是大量介绍、评价论题、谈论该论题一直困扰着世世代代的思想者以及对于该论题如何众说纷纭等。</li>
<li>信口开河：写作时不注意组织自己的思想，想到哪儿写到哪儿。</li>
<li>未经思考：不对论题作深入和详细的探讨而写出对论题的第一反应。</li>
<li>不得要领：写作时拐弯抹角。需要评价骑自行车的好处时，大谈自行车的历史；需要介绍自行车的历史时，却通过历史评述骑自行车的益处。</li>
<li>让读者领会：期望读者从作者不合逻辑的推论、转移话题的论述和无关的旁敲侧击中领会作者的意图。</li>
</ul>
</li>
<li><p>有说服力的写作：</p>
<ul>
<li>集中讨论与对手就论题产生的分歧，而不是只关注个人观点。</li>
<li>在反驳对手的观点时不能出言不逊。不能说对手的论证是荒谬、可笑的。</li>
<li>对于对手的好论证，要坦率承认。</li>
<li>在受限的时间和条件下，把注意力集中于最主要的环节。不要过分关心枝节上的分歧。</li>
<li>先陈述强有力的论证。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>批判性思维的前提是清晰的思维</li>
<li>引起断言及论证的含混不清有诸多原因，但主要有模糊、歧义和抽象</li>
<li>模糊有程度之分，关键是相对于特定目的而言不能太模糊</li>
<li>歧义指一个语句有多种解释，而且不能断明其中哪种解释是正确的</li>
<li>歧义主要分为语义歧义、语形歧义、组合歧义和指代歧义</li>
<li>过于抽象的断言指缺乏足够的信息来界定它到底可应用于哪些对象</li>
<li>无论是减少模糊、消除歧义还是运用新词汇或旧词新用，定义都能助一臂之力</li>
<li>定义主要分为同义词定义、实指定义、分析定义</li>
<li>修辞定义并不是为了澄清意义，而是为了表明或影响态度</li>
<li>修辞定义借助术语的修辞力（情感意义）来实现目的</li>
<li>论文写作是批判性思维能力的运用和体现，要训练和掌握论文写作的技能</li>
</ul>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>批判思维</tag>
        <tag>逻辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title>论文错误记录</title>
    <url>/2020/05/07/ErrorRecord/</url>
    <content><![CDATA[<h2 id="论文错误记录"><a href="#论文错误记录" class="headerlink" title="论文错误记录"></a>论文错误记录</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>实例：每篇论文有不同的叫法，data point是最常用的，机器学习的论文可能会叫instance，item</li>
</ul>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="一种写作结构："><a href="#一种写作结构：" class="headerlink" title="一种写作结构："></a>一种写作结构：</h4><ul>
<li>原来的t-sne投影，原始特征跟投影轴之间的关系复杂，难以描述和理解</li>
<li>虽然有一些方法试图可视化这种复杂关系，但还存在xx问题</li>
<li>我们提出t-sne投影的分片线性近似，如何解决了上述问题</li>
<li>我们认为，一个可理解的分片线性近似，需要具有如下的性质1、2、3、</li>
<li>为次，我们提出了xx算法，设计了xx表达，…</li>
</ul>
<h4 id="论文写作的模块："><a href="#论文写作的模块：" class="headerlink" title="论文写作的模块："></a>论文写作的模块：</h4><ul>
<li>背景（重要性）：要结合自己的问题完成背景的写作。<ul>
<li>重要性是什么：重要性就是，看完你的背景介绍，就能感觉到有一个问题需要解决，但是你又不能直接讲出这个问题。</li>
</ul>
</li>
<li>问题：用最简单的语言讲清楚自己的问题，让非专家也能看懂</li>
<li>技术挑战：需要解决某个问题存在的困难，这里的困难就是挑战。</li>
<li>解决方案：<ul>
<li>首先要提炼解决方案的目标</li>
<li>然后给出如何设计系统来完成目标</li>
</ul>
</li>
<li>贡献：<ul>
<li>平实，有什么说什么</li>
</ul>
</li>
</ul>
<h4 id="Related-Work中的分类："><a href="#Related-Work中的分类：" class="headerlink" title="Related Work中的分类："></a>Related Work中的分类：</h4><ul>
<li>每个分类，都按照what、why、how的三个层次来描述</li>
<li>what，是指这个技术是什么</li>
<li>why，是指这个技术能给可视化带来什么好处，能解决哪些问题</li>
<li>how，是具体的案例</li>
<li>如何分类：<ul>
<li>分类要平衡</li>
<li>分类要能告诉我们一定的知识</li>
<li>可以通过根据分析对象的层次来分类。</li>
</ul>
</li>
</ul>
<h4 id="Related-Work要讲清楚的问题："><a href="#Related-Work要讲清楚的问题：" class="headerlink" title="Related Work要讲清楚的问题："></a>Related Work要讲清楚的问题：</h4><ul>
<li>哪些工作跟你的核心问题相关？</li>
<li>这些工作分别有哪些主要类型？</li>
<li>这些工作跟你的工作的联系和区别是什么？为什么不能解决你的问题？</li>
</ul>
<h4 id="识别论证："><a href="#识别论证：" class="headerlink" title="识别论证："></a>识别论证：</h4><ul>
<li>无论是演绎论证还是非演绎论证，都由两部分构成。其中一个部分提供让我们相信另一部分的理由。论证的根本标识词为“所以”之类的词语。构成论证至少要有两个断言，而且各断言间（或明示的或暗示的）以“所以”等词语连接。</li>
<li>论证的提示词是识别论证的指南。除了“所以”之外，论证之结论的提示词还有：<ul>
<li>由此得出……</li>
<li>这表明……</li>
<li>于是……</li>
<li>因此……</li>
<li>结果……</li>
<li>我的结论是……</li>
</ul>
</li>
<li>论证的前提也有其指示词，如：<ul>
<li>既然……</li>
<li>因为……</li>
<li>由于……</li>
<li>依据……</li>
</ul>
</li>
</ul>
<h4 id="Case-Study："><a href="#Case-Study：" class="headerlink" title="Case Study："></a>Case Study：</h4><ul>
<li>系统能解决什么问题</li>
<li>Case怎么验证要解决的问题</li>
<li>Case怎么设计</li>
</ul>
<h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><p>* </p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>写作错误</tag>
      </tags>
  </entry>
  <entry>
    <title>GPt-SNE论文分析</title>
    <url>/2020/04/27/GPt-SNE/</url>
    <content><![CDATA[<h2 id="GPt-SNE-论文分析"><a href="#GPt-SNE-论文分析" class="headerlink" title="GPt-SNE 论文分析"></a>GPt-SNE 论文分析</h2><p>作者：Andrew Lensen</p>
<p>期刊：IEEE Transactions on Cybernetics</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>首先直接指出目前的可视化的作用和目前可视化方法的痛点<ul>
<li>痛点：<ul>
<li>最先进的可视化方法往往是黑盒方法，无法洞察可视化如何编码数据的原始特征</li>
<li>其他方法如Autoencoder和pt-SNE使用复杂神经网络，对人来说依然难以理解</li>
</ul>
</li>
<li>分析：直接指出可视化的痛点，也是一种很好的表达，观点看起来很清晰，之前自己的写作顾虑太多，应该就事论事。其实作者的观点和我是一致的，但是我一没讲清楚，二是不够自信，过多的自我怀疑对工作毫无益处。</li>
</ul>
</li>
<li>接着指出有良好可解释性的线性方法，在降维上固有的局限性：<ul>
<li>痛点：线性方法仅通过对原始特征的线性组合来编码可视化</li>
<li>分析：还是不够自信吧，我们写的太拘谨了，其实我自己写作的时候，就一直在思考为什么不去直接指出线性方法的局限性，我觉得要多坚持自己的想法。</li>
</ul>
</li>
<li>然后介绍基于树的GP（genetic programming）方法，该方法常用于FC（feature construction）中的降维，并且是公认可解释的。最后明确指出，GP方法还并未被用于生成可解释的降维模型即可解释的的可视化。<ul>
<li>分析：觉得自己调研的不够充分，毕竟我都没收集到GP方法。论文写法上来说，我觉得简单直接，我在写作中也要以他为模板，即使技术方案简单也没什么好扭捏的。</li>
</ul>
</li>
<li>接着给出了他们之前的工作GP-MaL（该工作使用GP方法进行降维），并指出了之前工作存在的一些问题。<ul>
<li>分析：这样写，一方面阐述了作者在GP方法上是有底蕴的，让人更相信作者的表达。我觉得我在写作的时候可以多引用作者的论文和表达，体现出我在该研究方向上的理解。</li>
</ul>
</li>
<li>然后给出了论文的技术方案：多目标GP方法。<ul>
<li>分析：Introduction通过前两段才讲清楚问题，但是并没有让人觉得冗余。而我总是追求一句话讲清楚，为了达到这个目标，就在非线性方法的问题和线性方法的问题中做取舍，最后不伦不类，要多反思，不能僵化自己的思维。</li>
</ul>
</li>
<li>最后总结了论文的贡献：<ul>
<li>贡献：<ul>
<li>Propose a holistic set of functions and terminals for creating powerful and interpretable models for visualisation; </li>
<li>Design a multi-objective approach to allow for the evolution of a solution front containing visualisations representing different levels of quality and complexity; </li>
<li>Compare the quality and interpretability of the evolved visualisations with those produced by state-of-the-art visualisation methods on a range of datasets; </li>
<li>Perform an in-depth analysis of the trade-off between visualisation quality and tree complexity to demonstrate the unique advantages of the proposed approach.</li>
</ul>
</li>
<li>分析：我觉得贡献部分写的很平实，我在写贡献部分的时候也要平实，不要故弄玄虚。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h2><ul>
<li>Dimensionality Reduction：降维是一种通过减少数据集的特征/属性数量来提高理解和性能的过程，随着数据集变得越来越大，深层神经网络变得越来越不可解释，其重要性也在不断增加。解决这个问题的常用技术包括FS（feature select）和FC，他们分别通过删除不需要的特征或创建更少、更复杂的元特征来减少特征空间。GP方法由于其功能性和可解释性而被证明是一种适合FC问题的方法。流形学习（非线性降维）可以被看作是一种无监督的FC方法，其任务是建立一组表示高维特征空间中存在的非线性流形的特征。实现这一任务的一种方法是尝试构建一个函数，将高维空间映射到低维流形；这种方法可以在两者之间提供可理解的映射。<ul>
<li>分析：首先论文简单介绍了降维的意义和目标。与之相比我写的相关工作太冗余了，全都是已有技术的堆砌，没有紧扣主题且逻辑松散。其次论文对流形学习的介绍，用简单明了的语言就把流形学习的意义和目的讲清楚了。我在写作中要多比对自己和论文的表达。</li>
</ul>
</li>
<li>Machine Learning for Performing Visualisation:该段从机器学习的角度分析了常用的可视化方法，如FS和PCA，存在的局限性（除了简单的低维数据外，线性转换无法清晰地显示数据集中的任何低维流形/结构）。而创建最优非线性变化是一个NP难问题，因此提出了许多基于损失函数的非线性降维方法（ISOMAP，LLE）。最后提到了t-SNE，作者认为这是目前最成功的技术（当然，作者这么写的主要原因是作者的模型基于t-SNE），并对t-SNE进行了较为详细的介绍。<ul>
<li>分析：给我的感觉就是详略得当，既能感受到作者在可视化领域和机器学习领域上的积累，又写的很清爽，让人读起来很轻松。相比之下，我写的东西，要不就是全部都详写，要不就是全部都略写，主要还是自己在相关领域的积累太浅，不能把握文章的重点，要在这方面多花功夫。</li>
</ul>
</li>
<li>Multi-objective Optimisation：这部分主要介绍了MO（Multi-objective Optimisation）方法，当一个问题本质上有两个（或多个）冲突目标时使用的一种技术，在这两个目标之间必须通过问题的解决方案进行权衡。在这种情况下，解决方案的质量通常与其他解决方案的目标函数值有关。而目前最流行的的MO方法就是EC方法，这也是论文所采用的方法。<ul>
<li>分析：我在写作过程中没有了解过MO方法，所以还需要进一步深入。从写作上来说，我觉得讲的还是很清晰的，虽然我看完不知道MO方法的细节实现，但是为什么用MO方法，以及MO方法的目的，以及作者如何实现MO方法都已经了解了。所以我在介绍相对冷门的技术的时，也要这样抓住重点来讲。</li>
</ul>
</li>
<li>Related Work：作者把相关工作分成了两部分，一部分是GP方法在流形学习和可视化上的应用，另一部分介绍了其它与可解释性相关的工作。<ul>
<li>因为作者就是第一个提出将GP方法用于在流形学习，所以这一部分写的非常的自信。其中提到了三个优化目标：可分类性，视觉可解释性，语义可解释性。</li>
<li>介绍了参数t-SNE（参数t-SNE是t-SNE的一种变体，它允许在将来的样本上重用学习到的t-SNE表示。 参数化t-SNE使用受限的Boltzmann机器构造从高维空间到低维空间的映射，以构建预训练的前馈神经网络模型。 该神经网络在最大的数据集上使用了10,000多个神经元，从而严重限制了解释该网络的潜力），Autoencoder（自动编码器[3]是另一种基于神经网络的方法，它试图将数据表示压缩到尽可能小的中间隐藏层中，以便可以从简洁的表示中重新创建原始数据。 为此，自动编码器使用许多大小不同的层来编码和解码数据。 这提供了与学习到的表示之间的映射，但是在给定节点数和完全连接的拓扑的情况下进行解释是不现实的），SOM（是无监督神经网络的一种变体，已用于可视化，但是权重的数量随维度而定，因此它们的可解释性受到非平凡数据集的限制）。并指出论文和已有增强可解释性方法的区别，已有方法（如DimReader）通过更改模型参数或数据实例来分析模型，而论文提出了一种可直接解释的降维模型。</li>
<li>分析：这部分内容可以作为我们解释非线性降维相关工作参考的模板，我们不应该为了分类而分类，要紧扣自己的工作，提出符合逻辑的分类，让读者的关注点一直保持在我们的工作上。通过这段，我们可以发现我们的工作和论文工作的区别，所以我认为我们的工作还是有价值的。</li>
</ul>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul>
<li><p>介绍GPt-SNE用于可视化需要解决的技术问题：</p>
<ul>
<li>什么终端和功能节点是合适的</li>
<li>如何构造适应度函数</li>
<li>标准的GP进化过程如何改进</li>
</ul>
</li>
<li><p>GP Architecture：对于每个个体构造两颗GP树，每颗树生成可视化的一个维度（即x轴或y轴）。选择多树表示而不是协作协作进化方法，因为必须紧密耦合（即高度依赖）两棵树才能提供高质量的可视化； 合作协作进化方法倾向于不确定地配对来自不同子种群的解决方案，这大大降低了发生这种耦合的能力。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1587963825918.png" alt="1587963825918"></p>
</li>
<li><p>上表中的Function是功能节点：</p>
<ul>
<li>Arithmetic Function节点通过线性变换来减少输入数目</li>
<li>Non-Linear Function节点给出了两种Sigmoid和ReLU两种激活函数实现非线性变化（作者根据Autoencoder和其他神经网络方法的启发而选择的。（我的观点：神经网络的非线性的确体现在激活函数上））</li>
<li>Conditional Function节点提供了另一种非线性变化，作者认为这种变换由于其不可微性而对GP方法来说是非常独特的，并且期望它们允许一棵树根据其输入表现出不同的行为</li>
</ul>
</li>
<li><p><img src="/2020/04/27/GPt-SNE/1587963903654.png" alt="1587963903654"></p>
<p><img src="/2020/04/27/GPt-SNE/1587963929329.png" alt="1587963929329"></p>
</li>
<li><p>上表中的Terminal是终端节点：数据集中的每个特征都被分配了一个不同的终端，该终端返回给定实例的特征值。</p>
<ul>
<li>$F_i$终端直接返回实例的第$i$个的特征值（虽然这么做为EC搜索过程提供了灵活性，但是确实为大量特征增大了搜索空间。为了解决这个问题，作者使用PCA来选择最重要的特征）</li>
<li>$NF_i$终端给定去噪后的特征值（通常通过求特征值的均值实现）</li>
<li>Constant终端提供一个$[-1,1]$之间的值，以允许树的不同部分对最终输出产生不同的影响</li>
<li>Zero终端仅包含在n+和-功能节点中，因为单独的Zero终端对树没有任何影响</li>
<li>表2中的LIKEHOOD表示从终端集中选择终端的权重</li>
</ul>
</li>
</ul>
</li>
<li><p>Multi-Objective Approach：在机器学习中，模型的潜在性能与达到该性能所需的复杂性之间存在着内在的联系。例如，分离两个类的最简单模型是一个决策边界，它在空间中的某个点上简单地设置阈值，而对于三个线性可分的类，则至少需要两个阈值。而在可视化中也是如此：可视化的表达越细（具体），用于生成可视化的功能就越复杂。要在二维中重建复杂数据集的高维结构，需要两个非常大且复杂的GP树。从树中移除每个节点都会降低树重现高维概率分布的准确性（在t-SNE的情况下）。作为类比，考虑用GP树演化一个非常复杂的多项式函数：演化函数中的分量（节点）越少，可用于逼近函数的拐点就越少。为此作者使用多目标优化的方法来生成一套解决方案，从而在可视化质量和模型可解释性之间进行权衡。</p>
<ul>
<li><p>分析：作者的GP树，通过自底向上的功能节点计算，最后得到（x|y）轴上的投影。与之对比，他们的降维方法是全局的，而我们的降维方法是局部的。他们的降维方法是非线性的，我们的降维方法是全局非线性，局部线性的。</p>
</li>
<li><p>Objective 1 ：Visualisation Quality</p>
<ul>
<li>论文简要介绍了t-SNE的优化原则以及它的Cost Function。并且使用t-SNE的Cost Function作为第一个优化目标（可视化质量）。</li>
</ul>
</li>
<li><p>Objective 2：Model Complexity</p>
<ul>
<li><p>GP中遇到的一个常见问题是生成膨胀的树，其中GP树比达到给定适应度所需的树大得多。传统场景中，由于对树的规模不做限制，因此树可能包含不必要的复杂子树。</p>
</li>
<li><p>论文计算模型复杂度的公式：<img src="/2020/04/27/GPt-SNE/1587980851820.png" alt="1587980851820"></p>
<p>其中$T$是树，$I$是降维模型，$N_i$是树中的节点。</p>
</li>
</ul>
</li>
<li><p>分析：其实我觉得简单直接的方法，在有效的情况下挺好的</p>
</li>
</ul>
</li>
<li><p>Optimisation of Tree Constants：为了进一步提高可视化质量而不引入额外的模型复杂性，论文使用粒子群优化（PSO）[35]在进化过程的最后阶段对每个个体的短暂随机常数（ERC）进行微调。 标准GP无法有效地微调其数字参数（因为它随机搜索参数空间）； 通过采用PSO，论文可以做到这一点。（来自两棵树的）每个ERC都在PSO表示中分配了一个维度，给定维度的值表示给定ERC的值与其原始值相差多少。 论文使用很小范围的初始位置值（[-0.15，0.15]）和较低的最小和最大速度（-0.05和0.05）将PSO搜索集中于微调树中的ERC。 将所有0值（即原始ERC值）初始化为30个粒子之一，以确保PSO搜索不会产生劣等解。  PSO搜索是单目标的（因为树结构是固定的），适应度函数是与GP搜索中的第一个目标相同的代价函数（公式（5））。  PSO仅在GP进化过程的末尾使用，这既是因为其计算成本，又是为了防止GP陷入因进化过程中的微调而导致的局部最小值。</p>
<ul>
<li>分析：这部分提到了一个跟有意思的概念，提高可视化质量而不引入额外的模型复杂性，我要在设计实现方案时多考虑这样的技术。</li>
</ul>
</li>
<li><p>Other Considerrations：这一部分讲述了作者对标准MOEA/D的改动和默认参数的设置。并且作者提到使用多线程技术，和缓存GP树来加快运算。</p>
<ul>
<li>分析：这部分我也在我的技术方案里提到，但我是在技术方案中直接给出的，作者在最后给出这些优化细节，可能更有利于读者理解核心技术。</li>
</ul>
</li>
</ul>
<h2 id="Experiment-setup"><a href="#Experiment-setup" class="headerlink" title="Experiment setup"></a>Experiment setup</h2><ul>
<li>第一部分给出了作者使用的数据集列表，并且介绍了为什么使用这些数据集“这些数据集来自许多不同的领域，包括一般分类、生物学和图像分析。这些数据集大多来自UCI存储库[38]。”<ul>
<li>分析：在介绍实验数据集时，最好引用别人的工作，这样显得客观，但是在算法验证部分，为了帮助用户理解，可以使用人工数据集。</li>
<li><img src="/2020/04/27/GPt-SNE/1588167232568.png" alt="1588167232568"></li>
</ul>
</li>
<li>第二部分作者分析了GP-tSNE方法的特性，包括遗传代数，树的大小，实例覆盖率等。并且指出了这些参数可以充分发挥GP方法的性能（即进一步调整参数不会提高性能）<ul>
<li>分析：可以给出一组合适的参数，并给出使用这组参数的理由，从而指导用户使用。</li>
<li><img src="/2020/04/27/GPt-SNE/1588168104405.png" alt="1588168104405"></li>
</ul>
</li>
</ul>
<ul>
<li>第三部分作者对比了GP-tSNE和t-SNE之间的运算开销。并且分析了导致计算开销高的原因，最后提到作者给出了并行化方案来加速。<ul>
<li>分析：作者的描述“此外，GP-t SNE在一次运行中产生许多可视化，而t-SNE只产生一个可视化。在最大的数据集，图像分割，GPtSNE需要30小时，而t-SNE需要大约两分钟。”，我们在描述我们的技术方案时，也可以参考作者的描述，并且我们的方法相比作者的方法更快。</li>
</ul>
</li>
</ul>
<h2 id="Results-and-Discussion"><a href="#Results-and-Discussion" class="headerlink" title="Results and Discussion"></a>Results and Discussion</h2><ul>
<li><p>这一部分为论文的Case study。因为解决方案本质上是一个降维方法，所以作者主要在对比t-SNE和GP-tSNE的可视化效果（Cost Function 和 可视化视图）。</p>
</li>
<li><p>作者在讲到GP-tSNE的Cost Function大于t-SNE时，用到了一句话“与Iris数据集一样，GP-tSNE在最大复杂度下所获得的成本虽然接近于t-SNE，但它是通过映射而非嵌入产生的。”</p>
<ul>
<li>分析：我们的技术方案的基础是“Local Linear，Global no-Linear”。所以目前的我们的case study是面向无类别流形数据，发现并理解流形数据中的非线性特征。但是在多类简单数据上（简单体现在每个类别能被一个线性子空间表示），我们的方法应该也能有不错的效果。</li>
</ul>
</li>
<li>GP-tSNE和t-SNE的Cost function值的差（横坐标遗传代数）：<img src="/2020/04/27/GPt-SNE/1588241733421.png" alt="1588241733421"><ul>
<li>分析：可以看到，对于不同复杂程度的数据，在不同的遗传代数上收敛。对于我们的解决方案，可以绘制数据的分片大小和重建误差均值的折线图，来展示不同复杂度的数据集对解决方案的影响。</li>
</ul>
</li>
</ul>
<h2 id="Further-Analysis"><a href="#Further-Analysis" class="headerlink" title="Further Analysis"></a>Further Analysis</h2><ul>
<li><p>本部分作者主要论述不同复杂度的模型如何解释。复杂度较低的模型往往是线性的，GP-tSNE可以直接给出模型的两个映射（x和y），并根据映射结合可视化效果来理解模型。</p>
<ul>
<li><img src="/2020/04/27/GPt-SNE/1588324149315.png" alt="1588324149315"></li>
<li>分析：例如上图，其中一棵树包含三个节点，另一棵树包含10个节点，总复杂度为13。即使具有如此低的复杂度，三个类也开始出现，蓝色，紫色和红色类已经与其他类明显分开。 给出可视化$x$轴的树可以表示为$x=f_5+f_{11}+f_{32}+2nf_{14}-f_{21}-nf_{21}$。 y轴的树可以表示为$y=nf_{20}−f_{15}$。 这两棵树在原始特征集中的34个中总共使用了七个独特的特征，但是它们能够很好地分离出数据集的三个类别。 特别是可以通过在图中绘制两条垂直线来区分蓝色，红色和紫色类别。 换句话说，可以将两个阈值应用于$x$轴的输出，以便将类别大致分为三组：红色； 橙色和绿色； 和紫色和蓝色。 假定所有要素的[0，1]范围相同，并且树中减去的唯一要素是$f_{21}$，这表明蓝色和紫色类的$f_{21}$的要素值特别小（因为它们具有较高的$x$值），并且红色类的值特别大（因为它的$x$值低）。皮肤病学数据集中的$f_{21}$对应于“乳头上皮表皮变薄”特征，该特征通常与牛皮癣的皮肤状况有关。在下图的可视化中，红色类别对应于牛皮癣的诊断（类别标签）$-$实际上，红色实例出现在图的左侧，这与从中减去$f_{21}$的值一致。 临床医生可以使用这种分析方法来理解，仅此功能就可以用于以合理的准确性诊断牛皮癣，并且还可以对可视化的准确性提供更大的信心。</li>
</ul>
</li>
<li><p>不过作者的几个案例有点并不连贯，例如在复杂度更高的模型中，$f_{21}$特征就不再起作用了。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1588324797409.png" alt="1588324797409"></p>
</li>
<li><p>分析：我觉得我们做实验的时候要重点对比这一点，如果我们的解决方案选择的特征在不同的模型复杂度上可以得到保持，这可能更有利于用户的理解。</p>
</li>
</ul>
</li>
<li><p>随着模型复杂度的增加，Cost Function上出现明显的收益递减，并且模型中叶开始出现更多的非线性节点。并且作者没有分析复杂度超过100的模型，因为“我们不会尝试对复杂性超过100的模型进行详细分析，因为这些树变得难以解释，并最终像t-SNE一样成为黑匣子。 本文的主要目的是产生可解释的高质量（而不是最先进的）可视化，以便根据其使用的特征对数据集中的关系提供更深入的了解。 如果可视化质量是主要目标，那么考虑到t-SNE之类的方法不受限于寻找从原始特征空间到可视化轴的功能映射，则它们将更为合适。 尽管无法正确解释非常复杂的GP树，但它们对于GP-tSNE算法仍然很重要。”</p>
<ul>
<li>分析：从上述描述可知，作者的可解释的非线性模型的可解释性并不像我们想象的那么有效，对于复杂的模型，依然难以解释，所以我认为我们的技术方案依然是有科研价值的。</li>
</ul>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>在本段作者指出了他们的解决方案在可解释性上存在的局限性，但是同时指出这是解决此类问题的第一个多目标GP方法，因此他们认为他们的研究依然很有科研价值。</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可理解性</tag>
        <tag>非线性降维</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1.两数之和</title>
    <url>/2020/05/18/LeetCode-1/</url>
    <content><![CDATA[<h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode-1.两数之和"></a>LeetCode-1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>在建立HashTable的过程中，判断当前HashTable是否存在满足条件的元素</li>
<li>时间复杂度为O(n)，空间复杂度也为O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,j,len;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,len = nums.<span class="built_in">size</span>();i != len;++i)&#123;</span><br><span class="line">            j = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(j) != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans.push_back(m[j]);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>HeapSort.堆排序</title>
    <url>/2020/05/12/HeapSort/</url>
    <content><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>来源百度百科：</p>
<blockquote>
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p>
</blockquote>
<p>简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法</p>
<ul>
<li>最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子</li>
<li>那么处于最小堆的根节点的元素一定是这个堆中的最小值（此处我们考虑小根堆）</li>
</ul>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul>
<li><p>在原数组上构造堆时，我们需要从最后一个父节点( (len-1)/2 )开始调整堆。</p>
</li>
<li><p>调整堆的原理：</p>
<ul>
<li>找到子节点中的最小节点</li>
<li>比较最小子节点和父节点的大小<ul>
<li>如果父节点大于最小子节点，则交换父节点和最小子节点，并在最小子节点上再次调整堆</li>
<li>如果父节点小于最小子节点，则调整完成</li>
</ul>
</li>
</ul>
</li>
<li>调整好堆以后，我们逐次输出根节点（最小节点）<ul>
<li>交换根节点和最末节点，并将堆的大小减一</li>
<li>从根节点调整堆</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustheap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; len &amp;&amp; arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeheap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        adjustheap(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr || len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    makeheap(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        adjustheap(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[len - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">100</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    heapsort(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-104.二叉树的最大深度</title>
    <url>/2020/05/01/LeetCode-104/</url>
    <content><![CDATA[<h2 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode-104.二叉树的最大深度"></a>LeetCode-104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>只需要使用深度搜索遍历树。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">int</span> lv = func(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rv = func(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> lv &gt; rv ? lv : rv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-101.对称二叉树</title>
    <url>/2020/05/15/LeetCode-101/</url>
    <content><![CDATA[<h2 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode-101.对称二叉树"></a>LeetCode-101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ul>
<li>若一棵树的左右子树镜像对称，则该树镜像对称</li>
<li>判断两棵树镜像对称的要求：<ul>
<li>两棵树的根节点的值相同</li>
<li>两颗树中任一颗树的左子树与另一棵树的右子树镜像对称</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> func(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(TreeNode *lchild, TreeNode* rchild)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!lchild || !rchild)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lchild &amp;&amp; !rchild) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lchild-&gt;val == rchild-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> func(lchild-&gt;left,rchild-&gt;right) &amp;&amp; func(lchild-&gt;right,rchild-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><ul>
<li>使用队列存储待遍历的节点，将根节点的左右子树压入队列</li>
<li>当队列为空时循环结束。<ul>
<li>每次提取两个结点并比较它们的值。</li>
<li>若树不对称（即从队列中取出两个不相等的连续结点），返回false</li>
<li>将两个结点的左右子结点按相反的顺序插入队列中。</li>
</ul>
</li>
<li>返回true</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> func2(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func2</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        TreeNode *left,*right;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            left = q.front(),q.pop();</span><br><span class="line">            right = q.front(),q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!left || !right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left != right)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(left-&gt;left),q.push(right-&gt;right);</span><br><span class="line">                q.push(right-&gt;left),q.push(left-&gt;right);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归/非递归</tag>
        <tag>镜像树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-105.从前序和中序遍历序列构造二叉树</title>
    <url>/2020/06/04/LeetCode-105/</url>
    <content><![CDATA[<h2 id="LeetCode-105-从前序和中序遍历序列构造二叉树"><a href="#LeetCode-105-从前序和中序遍历序列构造二叉树" class="headerlink" title="LeetCode-105.从前序和中序遍历序列构造二叉树"></a>LeetCode-105.从前序和中序遍历序列构造二叉树</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>通过前序遍历，我们能找到根节点</li>
<li>通过根节点和中序遍历，我们能之后左子树有几个节点</li>
<li>然后我们可以把前序遍历和中序遍历分成左子树和右子树两部分，然后递归1~3</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>(),inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder,<span class="keyword">int</span> ps,<span class="keyword">int</span> pe,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder,<span class="keyword">int</span> is,<span class="keyword">int</span> ie)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ps &gt;= pe)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = is;i != ie;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == preorder[ps])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i -= is;</span><br><span class="line">        root-&gt;left = func(preorder,ps+<span class="number">1</span>,ps+i+<span class="number">1</span>,inorder,is,is+i);</span><br><span class="line">        root-&gt;right = func(preorder,ps+i+<span class="number">1</span>,pe,inorder,is+i+<span class="number">1</span>,ie);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-114.二叉树展开为链表</title>
    <url>/2020/05/29/LeetCode-114/</url>
    <content><![CDATA[<h2 id="LeetCode-114-二叉树展开为链表"><a href="#LeetCode-114-二叉树展开为链表" class="headerlink" title="LeetCode-114.二叉树展开为链表"></a>LeetCode-114.二叉树展开为链表</h2><p>给定一个二叉树，原地将它展开为一个单链表。</p>
<p> 例如，给定二叉树</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>将其展开为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>首先我们可以看出展开过程就是对二叉树的先序遍历（根左右）</li>
<li>由先序遍历可知，根是最优先的，其次是左子树，最后是右子树</li>
<li>我们首先把左子树插入到右子树的位置</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>在新的右子树的根节点上一直重复上边3~4的过程，直到新的右子树为 null</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                pre = root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right)&#123;  </span><br><span class="line">                    pre = pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-141.环形链表</title>
    <url>/2020/05/19/LeetCode-141/</url>
    <content><![CDATA[<h2 id="LeetCode-141-环形链表"><a href="#LeetCode-141-环形链表" class="headerlink" title="LeetCode-141.环形链表"></a>LeetCode-141.环形链表</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/19/LeetCode-141/circularlinkedlist.png" alt="img"></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/19/LeetCode-141/circularlinkedlist_test2.png" alt="img"></p>
<h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/19/LeetCode-141/circularlinkedlist_test3.png" alt="img"></p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用快慢指针</li>
<li><p>如果存在环，那么快指针会追上慢指针。</p>
</li>
<li><p>如果没有环，那么快指针会遍历到空指针</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *quick,*slow;</span><br><span class="line">        quick = slow = head;</span><br><span class="line">        <span class="keyword">while</span>(quick &amp;&amp; slow)&#123;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(quick)</span><br><span class="line">                quick = quick-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(quick == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-136.只出现一次的数字</title>
    <url>/2020/05/03/LeetCode-136/</url>
    <content><![CDATA[<h2 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode-136.只出现一次的数字"></a>LeetCode-136.只出现一次的数字</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们已经通过题目可知：</p>
<ul>
<li>重复的数字都出现了两次</li>
<li>不重复的数字只出现一次</li>
</ul>
<p>因此我们可以采用异或来解决这个问题：</p>
<ul>
<li>异或满足交换律：a^b^c  == a^c^b</li>
<li>当两个值相等时，异或结果为0</li>
<li>0与任何数x异或，结果都为x</li>
<li>所以a^b^b^a^c == a^a^b^b^c == 0^0^c == c</li>
</ul>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        for_each(<span class="built_in">begin</span>(nums),<span class="built_in">end</span>(nums),[&amp;](<span class="keyword">int</span> &amp;x)&#123;ans ^= x;&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-155.最小栈</title>
    <url>/2020/05/13/LeetCode-155/</url>
    <content><![CDATA[<h2 id="LeetCode-155-最小栈"><a href="#LeetCode-155-最小栈" class="headerlink" title="LeetCode-155.最小栈"></a>LeetCode-155.最小栈</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>实现一个能在常数时间能检索到最小元素的栈，那么需要这么设计数据结构</p>
<ul>
<li>用数组实现一个数据栈来存储数据</li>
<li>用数组实现一个最小数栈来存储最小数<ul>
<li>因为两个最小数之间的数字都不会是最小数，所以当Pop出一个最小数，那么新的最小数栈的栈顶就是当前的最小数</li>
</ul>
</li>
<li>需要注意动态扩容的问题</li>
</ul>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">int</span> *data,*<span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>,msize;</span><br><span class="line">    <span class="keyword">int</span> length,mlength;</span><br><span class="line">    MinStack() :data(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]),<span class="built_in">min</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]),<span class="built_in">size</span>(<span class="number">128</span>),msize(<span class="number">128</span>),length(<span class="number">0</span>),mlength(<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mlength == <span class="number">0</span> || x &lt;= <span class="built_in">min</span>[mlength - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mlength == msize)&#123;</span><br><span class="line">                msize *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> *newdata = <span class="keyword">new</span> <span class="keyword">int</span>[msize];</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i != mlength;++i)</span><br><span class="line">                    newdata[i] = <span class="built_in">min</span>[i];</span><br><span class="line">                <span class="keyword">delete</span>[] <span class="built_in">min</span>;</span><br><span class="line">                <span class="built_in">min</span> = newdata;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">min</span>[mlength++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="built_in">size</span>)&#123;</span><br><span class="line">            <span class="built_in">size</span> *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> *newdata = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i != length;++i)</span><br><span class="line">                newdata[i] = data[i];</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = newdata;</span><br><span class="line">        &#125;</span><br><span class="line">        data[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[--length] == <span class="built_in">min</span>[mlength<span class="number">-1</span>])&#123;</span><br><span class="line">                --mlength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> data[length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mlength &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>[mlength<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-160.相交链表</title>
    <url>/2020/05/10/LeetCode-160/</url>
    <content><![CDATA[<h2 id="LeetCode-160-相交链表"><a href="#LeetCode-160-相交链表" class="headerlink" title="LeetCode-160.相交链表"></a>LeetCode-160.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<p><img src="/2020/05/10/LeetCode-160/160_statement.png" alt="img"></p>
<p>在节点 c1 开始相交。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p><img src="/2020/05/10/LeetCode-160/160_example_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p><img src="/2020/05/10/LeetCode-160/160_example_2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p><img src="/2020/05/10/LeetCode-160/160_example_3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>如果两个链表没有交点，返回 null</li>
<li>在返回结果后，两个链表仍须保持原有的结构</li>
<li>可假定整个链表结构中没有循环</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为时间复杂度O(n)和空间复杂度O(1)的要求，所以我们可知，只能遍历固定次数链表，且不能根据数据规模开辟内存空间。</li>
<li>两个链表可能是不等长的，并且如果存在交点，交点肯定不在不等长的那部分。</li>
<li>首先遍历两个链表，确定两个链表的长度，Lengtha，Lengthb。</li>
<li>根据Lengtha和Lengthb的长度调整两个链表为等长的</li>
<li>遍历比较两个链表的首节点是否相等<ul>
<li>不相等将首节点下一个节点置为首节点</li>
<li>相等跳出遍历</li>
</ul>
</li>
<li>如果首节点不为空，则存在交点；如果为空，则不存在交点</li>
</ul>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Lengtha = <span class="number">0</span>,Lengthb = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmpa = headA,*tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmpa)&#123;</span><br><span class="line">            ++Lengtha;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpb)&#123;</span><br><span class="line">            ++Lengthb;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpa = headA,tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(Lengtha != Lengthb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Lengtha &lt; Lengthb)&#123;</span><br><span class="line">                --Lengthb;</span><br><span class="line">                tmpb = tmpb-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --Lengtha;</span><br><span class="line">                tmpa = tmpa-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpa!=tmpb)&#123;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpa)</span><br><span class="line">            <span class="keyword">return</span> tmpa;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-169.多数元素</title>
    <url>/2020/05/04/LeetCode-169/</url>
    <content><![CDATA[<h2 id="LeetCode-169-多数元素"><a href="#LeetCode-169-多数元素" class="headerlink" title="LeetCode-169.多数元素"></a>LeetCode-169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为多数元素数量大于n/2，所以我们只需要统计投票数：（因为只有众数的投票数不为0）</p>
<ul>
<li><p>如果当前数字和记录数一致，投票加1</p>
</li>
<li><p>如果当前数字和记录数不一致，投票减1</p>
<ul>
<li>如果减一后投票数为0，则更新记录数</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record = nums[<span class="number">0</span>],count = <span class="number">1</span>,i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == record)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">if</span>(!count)</span><br><span class="line">                &#123;</span><br><span class="line">                    record = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-198.打家劫舍</title>
    <url>/2020/05/20/LeetCode-198/</url>
    <content><![CDATA[<h2 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode-198.打家劫舍"></a>LeetCode-198.打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下</strong>，能够偷窃到的最高金额。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>假设我们从左往右偷</li>
<li>对于任一房屋，我们能偷到的最高金额是$f(x) = max(f(x-2) + nums[x],f(x-1))$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        a = nums[<span class="number">0</span>],b = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> i,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>;i != len;++i)&#123;</span><br><span class="line">            c = <span class="built_in">max</span>(a+nums[i],b);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-121.买卖股票的最佳时机</title>
    <url>/2020/05/12/LeetCode-121/</url>
    <content><![CDATA[<h2 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode-121.买卖股票的最佳时机"></a>LeetCode-121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">(注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。)</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>可以用动态规划实现，那么就会涉及到状态转移方程。</p>
</li>
<li><p>状态转移方程：计算到每一天的最低股价 = 前一天的股价 &lt; 当天的股价 ？ 前一天的股价 ： 当天的股价。</p>
</li>
<li><p>最大利润为最低股价和当前股价之间的差值的最大值</p>
</li>
</ul>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = prices[<span class="number">0</span>],<span class="built_in">min</span> = prices[<span class="number">0</span>],ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                ans = ans &gt; <span class="built_in">max</span> - <span class="built_in">min</span> ? ans : <span class="built_in">max</span> - <span class="built_in">min</span>;</span><br><span class="line">                <span class="built_in">min</span> = prices[i];</span><br><span class="line">                <span class="built_in">max</span> = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i] &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">                <span class="built_in">max</span> = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans = ans &gt; <span class="built_in">max</span> - <span class="built_in">min</span> ? ans : <span class="built_in">max</span>-<span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20.有效的括号</title>
    <url>/2020/05/22/LeetCode-20/</url>
    <content><![CDATA[<h2 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode-20.有效的括号"></a>LeetCode-20.有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用stack来存储左括号，使用map来管理左右括号之间的关系</li>
<li>遇到右括号，检测是否和栈顶的左括号对应<ul>
<li>如果栈为空或不对应就返回false</li>
</ul>
</li>
<li>遍历结束栈为空返回true，不为空返回false</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; m;</span><br><span class="line">        m[<span class="string">')'</span>] = <span class="string">'('</span>, m[<span class="string">']'</span>] = <span class="string">'['</span>, m[<span class="string">'&#125;'</span>] = <span class="string">'&#123;'</span>;</span><br><span class="line">        <span class="keyword">int</span> i,len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span> )&#123;</span><br><span class="line">                q.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.empty() || q.top() != m[s[i]])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-206.反转链表</title>
    <url>/2020/05/02/LeetCode-206/</url>
    <content><![CDATA[<h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode-206.反转链表"></a>LeetCode-206.反转链表</h2><p>反转一个单链表。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>反转链表，就是让后面的节点指向前面的节点。</p>
<p>如果是迭代执行，使用头插就行</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *h = head,*tmp = h;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    h-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        tmp-&gt;next = h;</span><br><span class="line">        h = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果是递归执行，则从尾向头反转</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *ans = func(head);</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">func</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *ans = func(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归/非递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-208.实现Trie（前缀树）</title>
    <url>/2020/06/04/LeetCode-208/</url>
    <content><![CDATA[<h2 id="LeetCode-208-实现Trie（前缀树）"><a href="#LeetCode-208-实现Trie（前缀树）" class="headerlink" title="LeetCode-208.实现Trie（前缀树）"></a>LeetCode-208.实现Trie（前缀树）</h2><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>Trie 树是一个有根的树，其结点具有以下字段：</p>
<ul>
<li>最多 RR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。</li>
<li>本文中假定 RR 为 26，小写拉丁字母的数量。</li>
<li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li>
</ul>
<p><img src="/2020/06/04/LeetCode-208/Trim" alt="Trim树"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie *nodes[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nodes, <span class="number">0</span>, <span class="keyword">sizeof</span>(Trie*)*<span class="number">26</span>);</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Trie()&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != <span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(nodes[i])</span><br><span class="line">                <span class="keyword">delete</span> nodes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : <span class="keyword">word</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;nodes[c-<span class="string">'a'</span>])</span><br><span class="line">                node-&gt;nodes[c-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;nodes[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : <span class="keyword">word</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;nodes[c-<span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;nodes[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : prefix)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;nodes[c-<span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;nodes[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21.合并两个有序链表</title>
    <url>/2020/05/05/LeetCode-21/</url>
    <content><![CDATA[<h2 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode-21.合并两个有序链表"></a>LeetCode-21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>选取两个链表中较小的头节点作为合并链表的头结点，然后按从小到大顺添加两个链表的头节点到合并链表上</p>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>,*tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-22.括号生成</title>
    <url>/2020/05/26/LeetCode-22/</url>
    <content><![CDATA[<h2 id="LeetCode-22-括号生成"><a href="#LeetCode-22-括号生成" class="headerlink" title="LeetCode-22.括号生成"></a>LeetCode-22.括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ul>
<li>一个有效的括号组合，即字符串中括号都是成对出现的，且在每个右括号之前都有与之对应的左括号</li>
<li>我们用一个变量use统计，目前有多少未对应的右括号</li>
<li>递归遍历所有可能性，当括号对个数==n时，判断use是否==0，如果等于0，则该括号对是有效的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> use = <span class="number">0</span>;</span><br><span class="line">        func(ans,s,n,use);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ans,<span class="built_in">string</span> &amp;s,<span class="keyword">int</span> &amp;n,<span class="keyword">int</span> &amp;use)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == n * <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!use)</span><br><span class="line">                ans.push_back(s);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(use &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                s.append(<span class="string">")"</span>);</span><br><span class="line">                --use;</span><br><span class="line">                func(ans,s,n,use);</span><br><span class="line">                s = s.substr(<span class="number">0</span>,s.length() - <span class="number">1</span>);</span><br><span class="line">                ++use;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(use &lt; n)&#123;</span><br><span class="line">                s.append(<span class="string">"("</span>);</span><br><span class="line">                ++use;</span><br><span class="line">                func(ans,s,n,use);</span><br><span class="line">                s = s.substr(<span class="number">0</span>,s.length() - <span class="number">1</span>);</span><br><span class="line">                --use;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><ul>
<li><p>我们可以观察到递归方法中，系统栈帮我们记录了回溯的位置，并且是深度搜索</p>
</li>
<li><p>我们将遍历过程看成一颗二叉树，对于每一个位置，只有左右括号两条路径</p>
</li>
<li>在这颗二叉树上，我们可以使用栈来实现广度搜索，具体做法是用栈存储即将要遍历的节点，和该节点上的use值</li>
<li>当要遍历的节点括号对个数==n时，判断use是否==0，如果等于0，则该括号对是有效的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        tmp.first = <span class="string">""</span>,tmp.second = <span class="number">0</span>;</span><br><span class="line">        s.push(tmp);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp.first.length() == n*<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tmp.second)</span><br><span class="line">                    ans.push_back(tmp.first);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    tmp.first.append(<span class="string">")"</span>);</span><br><span class="line">                    --tmp.second;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                    tmp.first = tmp.first.substr(<span class="number">0</span>,tmp.first.length() - <span class="number">1</span>);</span><br><span class="line">                    ++tmp.second;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.second &lt; n)&#123;</span><br><span class="line">                    tmp.first.append(<span class="string">"("</span>);</span><br><span class="line">                    ++tmp.second;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>递归/非递归</tag>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-234.回文链表</title>
    <url>/2020/05/21/LeetCode-234/</url>
    <content><![CDATA[<h2 id="LeetCode-234-回文链表"><a href="#LeetCode-234-回文链表" class="headerlink" title="LeetCode-234.回文链表"></a>LeetCode-234.回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用快慢指针找到链表的中间节点</li>
<li>在慢指针遍历过程中，反转前半部分的链表</li>
<li>遍历反转后的前半部分链表和后半部分链表是否一致</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow = <span class="literal">nullptr</span>,*fast = <span class="literal">nullptr</span>,*phead = <span class="literal">nullptr</span>,*phead2 = <span class="literal">nullptr</span>;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            phead2 = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            phead2-&gt;next = phead;</span><br><span class="line">            phead = phead2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast) slow = slow-&gt;next; </span><br><span class="line">        <span class="keyword">while</span>(phead)&#123;</span><br><span class="line">            <span class="keyword">if</span>(phead-&gt;val != slow-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            phead = phead-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23.合并K个排序链表</title>
    <url>/2020/04/26/LeetCode-23/</url>
    <content><![CDATA[<h2 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23.合并K个排序链表"></a>LeetCode 23.合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="循环合并最后两个链表"><a href="#循环合并最后两个链表" class="headerlink" title="循环合并最后两个链表"></a>循环合并最后两个链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *a = <span class="literal">nullptr</span>,*b = <span class="literal">nullptr</span>,*c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        b = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        c = marge(a,b);</span><br><span class="line">        lists.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用分治法"><a href="#使用分治法" class="headerlink" title="使用分治法"></a>使用分治法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">margeFunc</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low+<span class="number">1</span> == high)</span><br><span class="line">    	<span class="keyword">return</span> lists[low];</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    ListNode *ls = margeFunc(lists,low,middle);</span><br><span class="line">    ListNode *rs = margeFunc(lists,middle,high);</span><br><span class="line">    ListNode *s = marge(ls,rs);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">    ans = margeFunc(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用优先队列"><a href="#使用优先队列" class="headerlink" title="使用优先队列"></a>使用优先队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](ListNode* &amp;a,ListNode* &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)&gt; que(comp);</span><br><span class="line">    ListNode *Head = <span class="literal">nullptr</span>,*temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != lists.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])</span><br><span class="line">        &#123;</span><br><span class="line">			que.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Head)</span><br><span class="line">        &#123;</span><br><span class="line">            Head = temp = que.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = que.top();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            que.push(temp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分需要注意，构造优先队列的第三参数时仿函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-226.翻转二叉树</title>
    <url>/2020/04/30/LeetCode-226/</url>
    <content><![CDATA[<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode-226.翻转二叉树"></a>LeetCode-226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>输入：</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><h3 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h3><p>这题就是交换二叉树的左右节点。因为你交换二叉树的左右节点，是不会影响到父节点和子节点的。即交换完，你的父节点还是你的父节点，你的子节点还是你的子节点。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *tmp = <span class="literal">nullptr</span>,*tmp2 = <span class="literal">nullptr</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp2 = q.front();</span><br><span class="line">            tmp = tmp2-&gt;left;</span><br><span class="line">            tmp2-&gt;left = tmp2-&gt;right;</span><br><span class="line">            tmp2-&gt;right = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;left)</span><br><span class="line">                q.push(tmp2-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;right)</span><br><span class="line">                q.push(tmp2-&gt;right);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-238.除自身以外数组的乘积</title>
    <url>/2020/06/02/LeetCode-238/</url>
    <content><![CDATA[<h2 id="LeetCode-238-除自身以外数组的乘积"><a href="#LeetCode-238-除自身以外数组的乘积" class="headerlink" title="LeetCode-238.除自身以外数组的乘积"></a>LeetCode-238.除自身以外数组的乘积</h2><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明</strong>: 请<strong>不要使用除法</strong>，且在 O(n) 时间复杂度内完成此题。</p>
<p><strong>进阶</strong>：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h4><ol>
<li>要计算除自身以外的数组的乘积，我们可以把乘积分成两部分的乘积，即前缀与后缀的乘积</li>
<li>分别使用两个数组来保存前缀和后缀的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;int&gt; front(len,1),back(len,1),ans(len,1);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            front[i] *= front[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>];</span><br><span class="line">            back[len-i<span class="number">-1</span>] *= back[len-i] * nums[len-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            ans[i] = front[i] * back[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="空间复杂度O-1"><a href="#空间复杂度O-1" class="headerlink" title="空间复杂度O(1)"></a>空间复杂度O(1)</h4><ol>
<li>其实我们可以直接使用两个常数保存前缀和后缀，因为每一个前缀只与上一个前缀有关（同理，每一个后缀只与后一个后缀有关）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = nums.<span class="built_in">size</span>(),front = <span class="number">1</span>,back = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(len,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            front *=  nums[i<span class="number">-1</span>];</span><br><span class="line">            ans[i] *= front;</span><br><span class="line">            back *= nums[len-i];</span><br><span class="line">            ans[len-i<span class="number">-1</span>] *= back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-283.移动零</title>
    <url>/2020/05/07/LeetCode-283/</url>
    <content><![CDATA[<h2 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode-283.移动零"></a>LeetCode-283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>我们使用双指针i，j来解决这个问题</li>
<li>其中i指向数组中第一个为0的位置，j指向i后第一个非0的位置</li>
<li>因为i，j之间只有两种关系：<ul>
<li>i，j相同。此时num[i] == num[j]。因此我们++i,++j来找到第一个不为0的num[i]</li>
<li>i，j不同。此时i，j之间没有非零数，所以当nums[i] != 0时，nums[j] == 0。因此我们++i,++j来找到第一个不为0的num[i]</li>
<li>因此这两种情况都需要++i,++j</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;j != nums.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j != nums.<span class="built_in">size</span>() &amp;&amp; !nums[j])++j;</span><br><span class="line">                <span class="keyword">if</span>(j != nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-287.寻找重复数</title>
    <url>/2020/06/05/LeetCode-287/</url>
    <content><![CDATA[<h2 id="LeetCode-287-寻找重复数"><a href="#LeetCode-287-寻找重复数" class="headerlink" title="LeetCode-287.寻找重复数"></a>LeetCode-287.寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>我们使$cnt[i]$表示$nums[]$数组中小于等于$i$的数有多少个,假设我们重复的数是$target$，那么$[1,target-1]$的所有数满足$cnt[i] \le i,[targer,n]$里的所有数满足$cnt[i]&gt;i$，具有单调性。</p>
</li>
<li><p>我们使用二分查找在$[1,n]$之间找到这个$target$即可</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low,high,middle,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        low = <span class="number">1</span>,high = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count,i,ans;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>,count = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= middle)</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt;= middle)&#123;</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = middle;</span><br><span class="line">                high = middle <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-300.最长上升子序列</title>
    <url>/2020/06/01/LeetCode-300/</url>
    <content><![CDATA[<h2 id="LeetCode-300-最长上升子序列"><a href="#LeetCode-300-最长上升子序列" class="headerlink" title="LeetCode-300.最长上升子序列"></a>LeetCode-300.最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n2) 。</li>
</ol>
<p><strong>进阶: </strong>你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ol>
<li>我们使用Count[i]记录以第i个数为结尾的最长上升子序列，很明显Count[i] = max(Count[j]+1)，其中0 &lt;= j &lt; i;</li>
<li>时间复杂度为O(n^2)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,len = nums.<span class="built_in">size</span>(),ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(len,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    count[i] = <span class="built_in">max</span>(count[i],count[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,count[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="贪心-二分查找"><a href="#贪心-二分查找" class="headerlink" title="贪心+二分查找"></a>贪心+二分查找</h4><ol>
<li>我们假设ans是以上升子序列的末尾最小值数组，即ans[1]表示，长度为1的上升子序列的末尾最小值。</li>
<li>当ans.back() &lt; nums[i]时，我们直接把nums[i]加到ans中</li>
<li>当ans.back() &gt; nums[i]时，我们把找到ans中对应的最小值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,low,high,mid,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.back() &lt; nums[i])&#123;</span><br><span class="line">                ans.push_back(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = <span class="number">0</span>,high = ans.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                    mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ans[mid] &gt;= nums[i])&#123;</span><br><span class="line">                        high = mid;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        low = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[low] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-39.组合总和</title>
    <url>/2020/05/30/LeetCode-39/</url>
    <content><![CDATA[<h2 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode-39.组合总和"></a>LeetCode-39.组合总和</h2><p>给定一个<strong>无重复元素</strong>的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>利用系统栈存储之前的遍历路径</li>
<li>利用条件提前剪枝</li>
</ol>
<a id="more"></a>
<h4 id="递归实现（第一种版本）"><a href="#递归实现（第一种版本）" class="headerlink" title="递归实现（第一种版本）"></a>递归实现（第一种版本）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        func(ans,tmp,candidates,target,loc);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> &amp;target,<span class="keyword">int</span> loc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(loc &lt; candidates.<span class="built_in">size</span>())&#123;</span><br><span class="line">            tmp.push_back(candidates[loc]);</span><br><span class="line">            target -= candidates[loc];</span><br><span class="line">            <span class="keyword">if</span>(!target)&#123;</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                func(ans,tmp,candidates,target,loc);</span><br><span class="line">                func(ans,tmp,candidates,target,loc+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            target += candidates[loc];</span><br><span class="line">            <span class="keyword">if</span>(tmp.empty() || tmp.back() != candidates[loc])</span><br><span class="line">                func(ans,tmp,candidates,target,loc+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现（第二种版本）"><a href="#递归实现（第二种版本）" class="headerlink" title="递归实现（第二种版本）"></a>递归实现（第二种版本）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">        func(ans,tmp,candidates,target,loc);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates,<span class="keyword">int</span> &amp;target,<span class="keyword">int</span> loc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!target)&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = loc,len = candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                target -= candidates[i];</span><br><span class="line">                func(ans,tmp,candidates,target,i);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                target += candidates[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归版本（还没有做好）"><a href="#非递归版本（还没有做好）" class="headerlink" title="非递归版本（还没有做好）"></a>非递归版本（还没有做好）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; loc;</span><br><span class="line">        loc.first = <span class="number">0</span>,loc.second = <span class="number">0</span>;</span><br><span class="line">        s.push(loc);</span><br><span class="line">        <span class="keyword">int</span> len = candidates.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            loc = s.top();</span><br><span class="line">            <span class="keyword">if</span>(target &gt; candidates[loc.first + loc.second])&#123;</span><br><span class="line">                tmp.push_back(candidates[loc.first + loc.second]);</span><br><span class="line">                target -= candidates[loc.first + loc.second];</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == candidates[loc.first + loc.second])</span><br><span class="line">                    ans.push_back(tmp); </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-33.搜索旋转排序数组</title>
    <url>/2020/04/27/LeetCode-33/</url>
    <content><![CDATA[<h2 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="LeetCode-33.搜索旋转排序数组"></a>LeetCode-33.搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.本质上还是二分查找，但是对排序数组旋转后，需要做一些判断确定下一次的检索区域</p>
<p>2.当middle &lt; target时，我们需要判断low-&gt;middle是否为一个连续区间，如果成立，那么target只会在middle和high之间，因为low-&gt;middle都 &lt; target。如果low-&gt;middle不为一个连续区间，那么middle-&gt;high为一个连续区间，此时我们要判断high是否 &gt;= target，如果成立就在middle-&gt;high区间，反之在low-&gt;middle区间。</p>
<p>3.当middle &gt; target时，我们需要判断middle-&gt;high是否为一个连续区间，如果成立，那么target只会在low和middle之间，因为middle-&gt;high都 &gt; target。如果middle和high不为一个连续区间，那么low-&gt;middle为一个连续区间，此时我们要判断low是否 &lt;= target，如果成立就在low-&gt;middle区间，反之在middle-&gt;high区间。</p>
<p>Tag: 实际实现的时候，middle不被考虑在下一次的检索区域内，因为middle已经和target比较过了。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = nums.<span class="built_in">size</span>(),middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] == target)</span><br><span class="line">        	<span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt; nums[middle])</span><br><span class="line">            &#123;</span><br><span class="line">            	low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[high<span class="number">-1</span>] &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                	low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                	high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; nums[high<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            	high = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(nums[low] &lt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-338.比特位计数</title>
    <url>/2020/05/27/LeetCode-338/</url>
    <content><![CDATA[<h3 id="LeetCode-338-比特位计数"><a href="#LeetCode-338-比特位计数" class="headerlink" title="LeetCode-338.比特位计数"></a>LeetCode-338.比特位计数</h3><p>给定一个非负整数 $num$。对于 $0 ≤ i ≤ num$ 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul>
<li>给出时间复杂度为$O(n*sizeof(integer))$的解答非常容易。但你可以在线性时间$O(n)$内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为$O(n)$。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li>
</ul>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>通过举例我们可以发现，二进制数中1的个数是有规律的</li>
<li>状态转移方程为$ans[i] = ans[i-subnum]+1$，其中$subnum = pow(2,subnum的有效位数)$ </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>,j,subnum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= num)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = subnum;j != <span class="number">0</span> &amp;&amp; i &lt;= num;--j,++i)&#123;</span><br><span class="line">                ans[i] = ans[i-subnum]+<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            subnum *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划-位运算"><a href="#动态规划-位运算" class="headerlink" title="动态规划+位运算"></a>动态规划+位运算</h4><ul>
<li>我们可以在位运算上存在以下状态转移方程$ans[i] = ans[i&gt;&gt;1] + (i\ \ mod\ \ 2)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= num;++i)&#123;</span><br><span class="line">            ans[i] = ans[i&gt;&gt;<span class="number">1</span>] + i%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-448.找到所有数组中消失的数字</title>
    <url>/2020/05/08/LeetCode-448/</url>
    <content><![CDATA[<h2 id="LeetCode-448-找到所有数组中消失的数字"><a href="#LeetCode-448-找到所有数组中消失的数字" class="headerlink" title="LeetCode-448.找到所有数组中消失的数字"></a>LeetCode-448.找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为不能使用额外空间，且1 ≤ a[i] ≤ n,所以我们可以直接使用原数组完成hash</li>
<li>将被hash到的位置变成负数，因为1 ≤ a[i] ≤ n,所以值为负就可以确保该位置被hash到</li>
<li>最后统计值&gt;0的位置即可</li>
<li>时间复杂度O(2n),空间复杂度O(1)(如果不算返回值)</li>
</ul>
<a id="more"></a>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            j = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; <span class="number">0</span>)</span><br><span class="line">                nums[j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-46.全排列</title>
    <url>/2020/05/25/LeetCode-46/</url>
    <content><![CDATA[<h2 id="LeetCode-46-全排列"><a href="#LeetCode-46-全排列" class="headerlink" title="LeetCode-46.全排列"></a>LeetCode-46.全排列</h2><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ul>
<li>递归的终止条件是，当前的排列数组大小和原始序列一致</li>
<li>在递归的过程中，使用系统栈记录回溯的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">use</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        func(nums,ans,tmp,use);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;use)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.<span class="built_in">size</span>() == use.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i,len = use.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!use[i])&#123;</span><br><span class="line">                    use[i] = <span class="literal">true</span>;</span><br><span class="line">                    tmp.push_back(nums[i]);</span><br><span class="line">                    func(nums,ans,tmp,use);</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                    use[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><ul>
<li>根据递归方法，我们可知系统栈存储的是回溯的位置</li>
<li>因此非递归我们需要用stack存储回溯的位置</li>
<li>每次回溯至一个可以继续遍历的位置终止，如果回溯到头都找不到该位置，则结束遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">use</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; loc;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i,len = use.<span class="built_in">size</span>();</span><br><span class="line">        loc.first = <span class="number">1</span>,loc.second = <span class="number">0</span>;</span><br><span class="line">        s.push(loc);</span><br><span class="line">        tmp.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        use[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            loc = s.top();</span><br><span class="line">            <span class="comment">//回溯部分</span></span><br><span class="line">            <span class="keyword">if</span>(loc.first == len)&#123;</span><br><span class="line">                ans.push_back(tmp);</span><br><span class="line">                use[loc.second] = <span class="literal">false</span>;</span><br><span class="line">                s.pop();</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(i = loc.second + <span class="number">1</span>;i &lt; len;++i)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!use[i])&#123;</span><br><span class="line">                            use[i] = <span class="literal">true</span>;</span><br><span class="line">                            loc.second = i;</span><br><span class="line">                            tmp.push_back(nums[i]);</span><br><span class="line">                            s.push(loc);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(use[loc.second] || (loc.first == <span class="number">1</span> &amp;&amp; loc.second == len<span class="number">-1</span>))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    loc = s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    use[loc.second] = <span class="literal">false</span>;</span><br><span class="line">                    tmp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遍历部分</span></span><br><span class="line">                ++loc.first;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!use[i])&#123;</span><br><span class="line">                        use[i] = <span class="literal">true</span>;</span><br><span class="line">                        loc.second = i;</span><br><span class="line">                        s.push(loc);</span><br><span class="line">                        tmp.push_back(nums[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递归/非递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-437.路径总和III</title>
    <url>/2020/05/09/LeetCode-437/</url>
    <content><![CDATA[<h2 id="LeetCode-437-路径总和III"><a href="#LeetCode-437-路径总和III" class="headerlink" title="LeetCode-437.路径总和III"></a>LeetCode-437.路径总和III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1. 5 -&gt; 3
2. 5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre><h3 id="使用双递归完成"><a href="#使用双递归完成" class="headerlink" title="使用双递归完成"></a>使用双递归完成</h3><ul>
<li>第一层递归遍历起始节点</li>
<li>第二层递归遍历结束节点</li>
</ul>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> func(root,sum) + pathSum(root-&gt;left,sum) + pathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (sum ? <span class="number">0</span> : <span class="number">1</span>) + func(root-&gt;left,sum) + func(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用前缀和"><a href="#使用前缀和" class="headerlink" title="使用前缀和"></a>使用前缀和</h3><ul>
<li>前缀和的定义是，路径上到当前节点为止的累加和（包括当前节点）</li>
<li>因此我们可以得到推论：A节点和B节点之间的节点和为B的前缀和与A的前缀和的差值。</li>
<li>那么给定B的前缀和与路径和，我们可以算出A的前缀和（A = B - val)</li>
<li>为了方便检索前缀和，我们可以使用Map管理前缀和。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> count = <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> func(root,count,sum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;count,<span class="keyword">int</span> &amp;val,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum == val)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum-val) != count.<span class="built_in">end</span>())</span><br><span class="line">            ans += count[sum-val];</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum) == count.<span class="built_in">end</span>())</span><br><span class="line">            count[sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++count[sum];</span><br><span class="line">        ans += func(root-&gt;left,count,val,sum);</span><br><span class="line">        ans += func(root-&gt;right,count,val,sum);</span><br><span class="line">        --count[sum];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>前缀和</tag>
        <tag>双递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-461.汉明距离</title>
    <url>/2020/04/29/LeetCode-461/</url>
    <content><![CDATA[<h2 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode-461.汉明距离"></a>LeetCode-461.汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>注意：<br>0 ≤ x, y &lt; $2^{31}$.</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题熟悉C++位运算即可。我们通过异或可以将两个数字中不同的位置1，然后计算不同的位的个数即可。</p>
<a id="more"></a>
<h3 id="位运算符简介"><a href="#位运算符简介" class="headerlink" title="位运算符简介"></a>位运算符简介</h3><p>位逻辑运算符：</p>
<p>​    &amp; （位   “与”）    and<br>​    ^ （位   “异或”）<br>​    | （位    “或”）   or<br>​    ~ （位   “取反”）<br>移位运算符：<br>​      &lt;&lt;（左移）<br>​      &gt;&gt;（右移）</p>
<p>优先级<br>位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != <span class="number">32</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">        	++count;</span><br><span class="line">        ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-48.选择图像</title>
    <url>/2020/05/31/LeetCode-48/</url>
    <content><![CDATA[<h2 id="LeetCode-48-选择图像"><a href="#LeetCode-48-选择图像" class="headerlink" title="LeetCode-48.选择图像"></a>LeetCode-48.选择图像</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>每4个数字的交换构成一次90度的旋转，例如例1中的{1,3,9,7}</li>
<li>按规律顺序交换这些数字，即可完成一轮旋转</li>
<li>完成了外圈的数字旋转后，再完成内圈的数字旋转</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>(),col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x,y,i,j,k;</span><br><span class="line">        x = <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt; <span class="number">1</span> &amp;&amp; col &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i != row<span class="number">-1</span>;++i)&#123;</span><br><span class="line">                k = matrix[x][y+i];</span><br><span class="line">                matrix[x][y+i] = matrix[x+row<span class="number">-1</span>-i][y];</span><br><span class="line">                matrix[x+row<span class="number">-1</span>-i][y] = matrix[x+row<span class="number">-1</span>][y+col<span class="number">-1</span>-i];</span><br><span class="line">                matrix[x+row<span class="number">-1</span>][y+col<span class="number">-1</span>-i] = matrix[x+i][y+col<span class="number">-1</span>];</span><br><span class="line">                matrix[x+i][y+col<span class="number">-1</span>] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            row -= <span class="number">2</span>,col -= <span class="number">2</span>;</span><br><span class="line">            ++x,++y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-53.最大子序和</title>
    <url>/2020/05/14/LeetCode-53/</url>
    <content><![CDATA[<h2 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode-53.最大子序和"></a>LeetCode-53.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><ul>
<li>如果当前子数组和&gt;0，子数组尾部添加新的数</li>
<li>如果当前子数组和&lt;0，子数组头部减少存在的数</li>
<li>最后返回最大子数组和</li>
<li>时间复杂度为$O(n)$,空间复杂度为$O(1)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start,<span class="built_in">end</span>,sum,len = nums.<span class="built_in">size</span>(),ans;</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        start = <span class="built_in">end</span> = sum = <span class="number">0</span>;</span><br><span class="line">        ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(start != len &amp;&amp; <span class="built_in">end</span> != len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[<span class="built_in">end</span>];</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start != <span class="built_in">end</span> &amp;&amp; sum &gt; ans)</span><br><span class="line">                ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>状态转移方程为$ F(i) = max(F(i-1) + a_i,a_i)$,其中：<ul>
<li>$F(i)$为以第$i$个数为结尾的最大子数组和</li>
<li>$a_i$为第$i$个数的值</li>
</ul>
</li>
<li>因为状态转移方程只需要上一个位置的结尾的最大子数组和</li>
<li>所以时间复杂度为$O(n)$,空间复杂度为$O(1)$。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last,now,ans;</span><br><span class="line">        last = now = ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            now = <span class="built_in">max</span>(nums[i],last+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(now &gt; ans)</span><br><span class="line">                ans = now;</span><br><span class="line">            last = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分治（线段树）"><a href="#分治（线段树）" class="headerlink" title="分治（线段树）"></a>分治（线段树）</h4><ul>
<li><p>为了合并两个子区域，每个子区域我们需要维护以下属性</p>
<ul>
<li>$lSum$ 表示 $[l,r)$ 内以 $l$ 为左端点的最大子段和</li>
<li>$rSum$ 表示 $[l,r)$  内以 $r-1$ 为右端点的最大子段和</li>
<li>$mSum$ 表示 $[l,r)$  内的最大子段和</li>
<li>$iSum$ 表示 $[l,r)$ 的区间和。</li>
</ul>
</li>
<li><p>Divide阶段：</p>
<ul>
<li>将$[l,r)$划分成$[l,m)$和$[m,r)$两个部分，其中$m=(l+r)/2$</li>
<li>当$l + 1 == r$时，返回$[l,r)$ 子区域</li>
</ul>
</li>
<li>Combine阶段：<ul>
<li>合并$l$子区域和$r$子区域，新的子区域的属性值如下：<ul>
<li>$lSum = max(l.lSum,l.iSum+r.lSum)$</li>
<li>$rSum = max(r.rSum,l.rSum+r.iSum)$</li>
<li>$mSum = max(l.rSum+r.lSum,max(l.mSum,r.mSum))$，因为新区间的最大子段和如果不跨区间，那么就是$max(l.mSum,r.mSum)$；如果跨区间，那么就是$l.rSum+r.lSum$</li>
<li>$iSum = l.iSum + r.iSum$</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">states</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> isum,lsum,rsum,msum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">states <span class="title">Combine</span><span class="params">(states &amp;l, states &amp;r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> isum,lsum,rsum,msum;</span><br><span class="line">        isum = l.isum + r.isum;</span><br><span class="line">        lsum = <span class="built_in">max</span>(l.lsum,l.isum + r.lsum);</span><br><span class="line">        rsum = <span class="built_in">max</span>(r.rsum,l.rsum + r.isum);</span><br><span class="line">        msum = <span class="built_in">max</span>(l.rsum + r.lsum,<span class="built_in">max</span>(l.msum,r.msum));</span><br><span class="line">        <span class="keyword">return</span> (states)&#123;isum,lsum,rsum,msum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">states <span class="title">Divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span> == r)</span><br><span class="line">            <span class="keyword">return</span> (states)&#123;nums[l],nums[l],nums[l],nums[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        states ls = Divide(nums,l,m);</span><br><span class="line">        states rs = Divide(nums,m,r);</span><br><span class="line">        <span class="keyword">return</span> Combine(ls,rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Divide(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()).msum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>分治</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-538.把二叉搜索树转换为累加树</title>
    <url>/2020/05/06/LeetCode-538/</url>
    <content><![CDATA[<h2 id="LeetCode-538-把二叉搜索树转换为累加树"><a href="#LeetCode-538-把二叉搜索树转换为累加树" class="headerlink" title="LeetCode-538.把二叉搜索树转换为累加树"></a>LeetCode-538.把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为是二叉搜索树，所以左子树&lt;根节点&lt;右节点</li>
<li>所以转换成累加树，我们只需要从最右向最左遍历树，并且将当前节点的值设为已遍历节点值的和（已遍历节点包括当前节点）</li>
</ul>
<a id="more"></a>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><ul>
<li>直接按解题思路遍历树即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            val += root-&gt;val;</span><br><span class="line">            root-&gt;val = val;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><ul>
<li>非递归方法先找到当前节点的右子节点</li>
<li>然后再遍历当前的左子节点，如果没有则回溯</li>
<li>回溯过程和遍历左子节点过程要区分开，避免节点重复遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node)&#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            val += node-&gt;val;</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>递归/非递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-543.二叉树的直径</title>
    <url>/2020/05/16/LeetCode-543/</url>
    <content><![CDATA[<h2 id="LeetCode-543-二叉树的直径"><a href="#LeetCode-543-二叉树的直径" class="headerlink" title="LeetCode-543.二叉树的直径"></a>LeetCode-543.二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>对于每一个节点，最长路径可能横跨这个节点的左右子树，或者只是经过这个节点的左右子树中的一个</li>
</ul>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        func(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *root,<span class="keyword">int</span> &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = func(root-&gt;left,ans);</span><br><span class="line">        <span class="keyword">int</span> right = func(root-&gt;right,ans);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,left+right+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ans = max(left+right+1,ans);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul>
<li>这里max(ans,left+right+1)和max(left+right+1,ans)的时间开销不同，需要调研一下</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-581.最短无序连续子数组</title>
    <url>/2020/05/23/LeetCode-581/</url>
    <content><![CDATA[<h2 id="LeetCode-581-最短无序连续子数组"><a href="#LeetCode-581-最短无序连续子数组" class="headerlink" title="LeetCode-581.最短无序连续子数组"></a>LeetCode-581.最短无序连续子数组</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<p>说明 :</p>
<ul>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li>
</ul>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="通过栈找到无序子数组的左边界和右边界"><a href="#通过栈找到无序子数组的左边界和右边界" class="headerlink" title="通过栈找到无序子数组的左边界和右边界"></a>通过栈找到无序子数组的左边界和右边界</h4><p><img src="/2020/05/23/LeetCode-581/61276ef77b0f1338b09332c278ad2751874b9bbc36161be9a7de9c974b1de859-image.png" alt="image.png"></p>
<ul>
<li>使用栈存储递增的值，如果遇到一个比栈顶小的值，那么该值为无序值，通过弹出栈顶找到无序值的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,l,r,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,l = len<span class="number">-1</span>;i != len;++i)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[s.top()] &gt; nums[i])&#123;</span><br><span class="line">               l = <span class="built_in">min</span>(l,s.top());</span><br><span class="line">               s.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) s.pop();</span><br><span class="line">        <span class="keyword">for</span>(i = len<span class="number">-1</span>,r = <span class="number">0</span>;i != <span class="number">-1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i])&#123;</span><br><span class="line">               r = <span class="built_in">max</span>(r,s.top());</span><br><span class="line">               s.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r &lt;= l? <span class="number">0</span> : r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不使用额外空间"><a href="#不使用额外空间" class="headerlink" title="不使用额外空间"></a>不使用额外空间</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,l,r,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        l = <span class="number">1e9</span>,r = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                l = <span class="built_in">min</span>(l,nums[i]);</span><br><span class="line">                r = <span class="built_in">max</span>(r,nums[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; nums[i])&#123;</span><br><span class="line">                l = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = len<span class="number">-1</span>;i != <span class="number">-1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r &gt; nums[i])&#123;</span><br><span class="line">                r = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r &gt; l ? r - l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-617.合并二叉树</title>
    <url>/2020/04/28/LeetCode-617/</url>
    <content><![CDATA[<h2 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode-617.合并二叉树"></a>LeetCode-617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题还是很简单的，只需要判断当前合并节点在对应的两棵树上是否都不为空。如果都不为空，则继续遍历左右子树，否则直接返回另一棵不为空的树即可。</p>
<a id="more"></a>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1 &amp;&amp; !t2)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">    	<span class="keyword">return</span> t1;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">    	<span class="keyword">return</span> t2;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-70.爬楼梯</title>
    <url>/2020/05/17/LeetCode-70/</url>
    <content><![CDATA[<h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode-70.爬楼梯"></a>LeetCode-70.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为每次只能爬1或2个台阶，所以每一级台阶的上法 = 低一级台阶的上法 + 低两阶台阶的上法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,i;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span>(a = <span class="number">1</span>,b = <span class="number">2</span>,i = <span class="number">3</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-78.子集</title>
    <url>/2020/05/24/LeetCode-78/</url>
    <content><![CDATA[<h2 id="LeetCode-78-子集"><a href="#LeetCode-78-子集" class="headerlink" title="LeetCode-78.子集"></a>LeetCode-78.子集</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><ul>
<li>对于数组中的每一个数字，我们都有可以选择使用或忽视</li>
<li>当遍历到最后一个数字时，把当前结果放进返回的容器中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        func(nums,ans,<span class="number">0</span>,tmp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans,<span class="keyword">int</span> loc,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loc == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            func(nums,ans,loc+<span class="number">1</span>,tmp);</span><br><span class="line">            tmp.push_back(nums[loc]);</span><br><span class="line">            func(nums,ans,loc+<span class="number">1</span>,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4><ul>
<li>我们可以把遍历过程想成一颗二叉树，每一个数字是否使用产生了两颗不同的左右子树</li>
<li>我们广度遍历这两颗左右子树即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        tmp.second = <span class="number">0</span>;</span><br><span class="line">        q.push(tmp);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp.second == len)&#123;</span><br><span class="line">                ans.push_back(tmp.first);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++tmp.second;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">                tmp.first.push_back(nums[tmp.second<span class="number">-1</span>]);</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>递归/非递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-94.二叉树的中序遍历</title>
    <url>/2020/05/28/LeetCode-94/</url>
    <content><![CDATA[<h2 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode-94.二叉树的中序遍历"></a>LeetCode-94.二叉树的中序遍历</h2><p>给定一个二叉树，返回它的中序 遍历。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶</strong>: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<a id="more"></a>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>中序遍历的非递归算法，我们需要分解遍历的过程：</p>
<ol>
<li>若当前节点非空，使当前节点变为当前节点的最左子节点，并用栈记录遍历过的节点，用于之后的回溯</li>
<li>若当前节点为空，则从栈顶取出回溯节点</li>
<li>把当前节点的值加入返回值数组</li>
<li>使当前节点变为当前节点的右节点</li>
<li>若当前节点为空，且栈也为空，则遍历结束；否则循环步骤1~5。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        TreeNode *tmp = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || tmp)&#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                s.push(tmp);</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            ans.push_back(tmp-&gt;val);</span><br><span class="line">            tmp = tmp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>PaperExamRecord-Iris</title>
    <url>/2020/05/14/PaperExamRecord-Iris/</url>
    <content><![CDATA[<h2 id="Iris局部线性近似实验分析"><a href="#Iris局部线性近似实验分析" class="headerlink" title="Iris局部线性近似实验分析"></a>Iris局部线性近似实验分析</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul>
<li>验证算法在低维多类数据集上的有效性</li>
</ul>
<h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul>
<li>多次实验，观察实验结果是否一致</li>
<li>观测实验结果是否和前人对Iris数据集的分析一致</li>
</ul>
<h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul>
<li>在Iris数据集上使用t-SNE方法投影到二维</li>
<li>使用算法将t-SNE投影简化成包含3个局部投影的投影集合（Iris数据集中存在三种类型的花）</li>
</ul>
<a id="more"></a>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="Iris-t-SNE分片示意图"><a href="#Iris-t-SNE分片示意图" class="headerlink" title="Iris t-SNE分片示意图"></a>Iris t-SNE分片示意图</h4><p><img src="/2020/05/14/PaperExamRecord-Iris/1589463841875.png" alt="1589463841875"></p>
<h4 id="Iris分片树示意图"><a href="#Iris分片树示意图" class="headerlink" title="Iris分片树示意图"></a>Iris分片树示意图</h4><p><img src="/2020/05/14/PaperExamRecord-Iris/1589463951813.png" alt="1589463951813"></p>
<h4 id="局部参数映射列表"><a href="#局部参数映射列表" class="headerlink" title="局部参数映射列表"></a>局部参数映射列表</h4><div class="table-container">
<table>
<thead>
<tr>
<th>分片标号</th>
<th>sepal length和投影的相关性</th>
<th>sepal breadth和投影的相关性</th>
<th>petal length和投影的相关性</th>
<th>petal breadth和投影的相关性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.34</td>
<td>0.28</td>
<td>1.24</td>
<td>0.5</td>
</tr>
<tr>
<td>2</td>
<td>0.28</td>
<td>0.60</td>
<td>1.19</td>
<td>0.36</td>
</tr>
<tr>
<td>3</td>
<td>0.58</td>
<td>0.16</td>
<td>0.98</td>
<td>0.83</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Iris数据集前人分析-1"><a href="#Iris数据集前人分析-1" class="headerlink" title="Iris数据集前人分析$^1$"></a>Iris数据集前人分析$^1$</h4><ul>
<li>Fisher在线性判别分析的实验中给出的最佳参数（相关性）如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>sepal length</th>
<th>sepal breadth</th>
<th>petal length</th>
<th>petal breadth</th>
</tr>
</thead>
<tbody>
<tr>
<td>-3.308998</td>
<td>-2.759132</td>
<td>8.866048</td>
<td>9.392551</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Fisher线性判别分析结果</p>
<p><img src="/2020/05/14/PaperExamRecord-Iris/1589465223247.png" alt="1589465223247"></p>
</li>
<li><p>Fisher认为petal length和petal breadth相比sepal length和sepal breadth能够更好地区分Iris</p>
</li>
</ul>
<h3 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><ul>
<li>多次实验得到的实验结果一致</li>
<li>t-SNE在投影Iris数据集上呈现出和Fisher线性判别分析模型相同的模式<ul>
<li>所有分片的投影的petal length和petal breadth相关性大于sepal length和sepal breadth的相关性，这和Fisher线性判别分析的结论一致</li>
</ul>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1]Fisher R A. The use of multiple measurements in taxonomic problems[J]. Annals of eugenics, 1936, 7(2): 179-188.</p>
]]></content>
      <categories>
        <category>论文实验</category>
      </categories>
      <tags>
        <tag>局部线性近似</tag>
        <tag>Iris</tag>
      </tags>
  </entry>
  <entry>
    <title>PaperExamRecord-SwissRoll</title>
    <url>/2020/05/09/PaperExamRecord-SwissRoll/</url>
    <content><![CDATA[<h2 id="SwissRoll局部线性近似实验分析"><a href="#SwissRoll局部线性近似实验分析" class="headerlink" title="SwissRoll局部线性近似实验分析"></a>SwissRoll局部线性近似实验分析</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul>
<li>验证算法在三维流形数据集上的有效性</li>
</ul>
<h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul>
<li>多次实验，观察实验结果是否一致</li>
<li>实验结果分析得到的结论是否存在异常</li>
</ul>
<h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul>
<li>在SwissRoll三维流形数据集上使用ISOMAP方法投影到二维</li>
<li>使用算法将ISOMAP投影简化成包含10个局部投影的投影集合</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="SwissRoll-ISOMAP分片示意图"><a href="#SwissRoll-ISOMAP分片示意图" class="headerlink" title="SwissRoll ISOMAP分片示意图"></a>SwissRoll ISOMAP分片示意图</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589023174018.png" alt="1589023174018"></p>
<h4 id="SwissRoll分片树示意图"><a href="#SwissRoll分片树示意图" class="headerlink" title="SwissRoll分片树示意图"></a>SwissRoll分片树示意图</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589022936862.png" alt="1589022936862"></p>
<h4 id="SwissRoll三维模型示意图（图片中的数字对应分片号）"><a href="#SwissRoll三维模型示意图（图片中的数字对应分片号）" class="headerlink" title="SwissRoll三维模型示意图（图片中的数字对应分片号）"></a>SwissRoll三维模型示意图（图片中的数字对应分片号）</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589022188714.png" alt="1589022188714"></p>
<a id="more"></a>
<h4 id="局部参数映射列表-维度顺序是（z-y-x"><a href="#局部参数映射列表-维度顺序是（z-y-x" class="headerlink" title="局部参数映射列表 维度顺序是（z,y,x)"></a>局部参数映射列表 维度顺序是（z,y,x)</h4><table>
     <tr>
        <td>分片标号</td>
        <td>原始特征在X轴上的相关性</td>
        <td>原始特征在Y轴上的相关性</td>
     </tr>
     <tr>
        <td>1</td>
        <td>-0.24</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0.01</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.96</td>
        <td>-0.03</td>
     </tr>
     <tr>
        <td>2</td>
        <td>-0.81</td>
        <td>0.04</td>
     </tr>
     <tr>
        <td></td>
        <td>0.02</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.59</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td>3</td>
        <td>-0.99</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.16</td>
        <td>0.05</td>
     </tr>
     <tr>
        <td>4</td>
        <td>-0.62</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.78</td>
        <td>0</td>
     </tr>
     <tr>
        <td>5</td>
        <td>0.2</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.02</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.98</td>
        <td>0</td>
     </tr>
     <tr>
        <td>6</td>
        <td>0.34</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.01</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.94</td>
        <td>0.03</td>
     </tr>
     <tr>
        <td>7</td>
        <td>0.73</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0.03</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>-0.68</td>
        <td>0.02</td>
     </tr>
     <tr>
        <td>8</td>
        <td>1</td>
        <td>0</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.11</td>
        <td>0.01</td>
     </tr>
     <tr>
        <td>9</td>
        <td>0.57</td>
        <td>0.04</td>
     </tr>
     <tr>
        <td></td>
        <td>0.03</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>0.82</td>
        <td>-0.01</td>
     </tr>
     <tr>
        <td>10</td>
        <td>0.07</td>
        <td>-0.01</td>
     </tr>
     <tr>
        <td></td>
        <td>0</td>
        <td>-1</td>
     </tr>
     <tr>
        <td></td>
        <td>1</td>
        <td>-0.02</td>
     </tr>
  </table>

<h3 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><ul>
<li>多次实验得到的实验结果一致，且实验结果中没有发现异常</li>
<li>ISOMAP在展开SwissRoll数据集时，二维投影的Y轴与数据集本身的第二维(Y）一一对应。<ul>
<li>所有分片的Y轴与SwissRoll的第二维（Y）相关程度都为-1</li>
</ul>
</li>
<li>ISOMAP在展开SwissRoll数据集时，不同分片的X轴与原始特征之间的关系呈现出可解释的规律：<ul>
<li>1,5,6,10等接近水平的分片，X轴与第三维（X）的相关性更强。</li>
<li>3,8等接近垂直的分片，X轴与第一维（Z）的相关性更强</li>
<li>根据分片在三维空间中的分布，X轴与第一维（Z）和第三维（X）的相关性一直在规律性的变化<ul>
<li>1-》2-》3，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直</li>
<li>4-》5，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li>
<li>6-》7-》8，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直<ul>
<li>其中7存在Z和X相关性接近的情况，这是因为7在Z和X上的可分性都很好</li>
</ul>
</li>
<li>8-》9-》10，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li>
<li>根据上述实验结果的分析，我认为我们方法生成的参数映射是连续的，并可以利用参数映射连续性来分析分片之间的非线性变化。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>论文实验</category>
      </categories>
      <tags>
        <tag>局部线性近似</tag>
        <tag>SwissRoll</tag>
      </tags>
  </entry>
  <entry>
    <title>实践论（论认识和实践的关系——知和行的关系）读书笔记</title>
    <url>/2020/05/23/ShiJianLun/</url>
    <content><![CDATA[<h2 id="实践论（论认识和实践的关系——知和行的关系）读书笔记"><a href="#实践论（论认识和实践的关系——知和行的关系）读书笔记" class="headerlink" title="实践论（论认识和实践的关系——知和行的关系）读书笔记"></a>实践论（论认识和实践的关系——知和行的关系）读书笔记</h2><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>教条主义和经验主义在党内盛行</li>
</ul>
<h3 id="写作的目的"><a href="#写作的目的" class="headerlink" title="写作的目的"></a>写作的目的</h3><ul>
<li>用马克思主义的认识论观点去揭露党内的教条主义和经验主义</li>
</ul>
<a id="more"></a>
<h3 id="要点记录："><a href="#要点记录：" class="headerlink" title="要点记录："></a>要点记录：</h3><ul>
<li>只有在社会实践过程中（物质生产过程中， 阶级斗争过程中，科学实验过程中），人们达到了思想中所预想的结果时，人们的认识才被证实了。</li>
<li>理论对于实践的依赖关系，理论的基础是实践，又转过来为实践服务。判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。</li>
<li>认识的两个个阶段：<ul>
<li>认识的感性阶段：看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系（在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论）</li>
<li>认知的理性阶段：概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。（在这个阶段中，使用判断和推理的方法， 就可产生出合乎论理的结论来）</li>
</ul>
</li>
<li>认识的真正任务在于经过感觉而到达于思维，到达于逐步了解客观事物的内部矛盾，了解它的规律性，了解这一过程和那一过程间的内部联系，即到达于论理的认识。</li>
<li>认识过程中两个阶段的特性，在低级阶段，认识表现为感性的，在高级阶段，认识表现为论理的，但任何阶段，都是统一的认识过程中的阶段。感性和理性二者的性质不同，但又不是互相分离的，它们在实践的基础上统一起来了。我们的实践证明：感觉到了的东西，我们不能立刻理解它，只有理解了的东西才更深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。这些问题的解决，一点 也不能离开实践。无论何人要认识什么事物，除了同那个事物接触，即生活于 （实践于）那个事物的环境中，是没有法子解决的。</li>
<li>认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。 第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。 只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据 这样的材料造出正确的概念和论理来。 </li>
<li>理性认识依赖于感性认识的问题</li>
<li>如果以为认识可以停顿在低级的感性阶段，以为只有感性认识可靠，而理性认识是靠不住的，这便是重复了历史上的“经验论”的错误。这种理论的错误，在于不知道感觉材料固然是客观外界某些真实性的反映 （我这里不来说经验只是所谓内省体验的那种唯心的经验论），但它们仅是片面的和表面的东西，这种反映是不完全的，是没有反映事物本质的。</li>
<li>认识从实践始，经过实践得到了理论的认识，还须再回到实践去。认识的能动作用，不但表现于从感性的认识到理性的认识之能动的飞跃， 更重要的还须表现于从理性的认识到革命的实践这一个飞跃。</li>
<li>抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命 的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性 这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能 完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去， 应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被 称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科 学实践所证实的时候。</li>
</ul>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>实践论</tag>
      </tags>
  </entry>
  <entry>
    <title>实践论学习报告</title>
    <url>/2020/05/30/ShiJianLunDiaoYan/</url>
    <content><![CDATA[<h2 id="实践论学习报告"><a href="#实践论学习报告" class="headerlink" title="实践论学习报告"></a>实践论学习报告</h2><p>实践论学习报告会结合我在Introduction，Related Work和论文评审三个部分的实际工作展开。</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>《实践论》中对认识的两个阶段是这么描述的：</p>
<ul>
<li>认识的感性阶段：看到过程中各个事物的现象方面，看到各个事物的片面，看到各个事物之间的外部联系（在这个阶段中，人们还不能造成深刻的概念，作出合乎论理（即合乎逻辑）的结论）</li>
<li>认知的理性阶段：概念这种东西已经不是事物的现象，不是事物的各个片面，不是它们的外部联系，而是抓着了事物的本质，事物的全体，事物的内部联系了。（在这个阶段中，使用判断和推理的方法， 就可产生出合乎论理的结论来）</li>
</ul>
<p>在写作Introduction的过程中，我重复了很多遍，主要的原因是对问题依然停留在感性的认识上。我一直没有思考“可理解性”到底是什么背景下的问题，什么是可理解性，它为什么重要，我们为什么要解决可理解性问题，那么多降维方法都不能提供很好的可理解性为什么还流行？直到我认真的开始分析的写作逻辑，我对这些问题才开始有理性上的认识。当然，我的运气很好，我第一篇认真分析的论文，就和我的工作十分相关，因此在分析理解作者表述的过程中，让我对问题的背景也有更深刻的认识。并且我通过对作者写作逻辑的模仿，把我的“可解释性”科学问题的定义，分解成以下调研任务:</p>
<ol>
<li>可视分析背景的调研。</li>
<li>调研可视分析的目的，主要技术，需要解决的问题。</li>
<li>可视分析的数据模型阶段，存在哪些问题，对可视分析造成了什么影响？</li>
<li>增强数据模型的可解释性是否有利于解决这些问题？</li>
<li>有哪些工作尝试解决数据模型的可解释性问题？</li>
<li>解决可解释性问题需要克服那些挑战？</li>
</ol>
<p>做这些调研分析，是为了支持我以下的写作目的：</p>
<ol>
<li>可视分析主要解决什么问题，使用了那些技术（DR）？</li>
<li>DR作用于可视分析的流程中的那些阶段？（数据模型，可视化）</li>
<li>在数据模型阶段里，存在哪些可解释性的问题，可解释性问题对可视分析造成了什么影响？</li>
<li>有哪些相关工作尝试去解决数据模型的可解释性问题，他们的工作还存在那些问题？</li>
<li>我们要解决可解释性问题，需要克服那些挑战？</li>
<li>为了解决这些挑战，我们如何设计我们的技术方案?</li>
</ol>
<a id="more"></a>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><p>《实践论》中对认识是这么描述的，“认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。 第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。 只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。”，而相关工作就是对认识的总结和提炼。</p>
<p>我在这里讲一下如何学习别人相关工作的写作吧。相关工作的学习在我看来有两种层次（两种层次根据你的需求来定）。第一种层次：这篇论文和你的工作直接相关，你读他的相关工作，主要目的是检查自己调研的文献是否有缺失，自己对相关工作的分类是否不够客观。在这个层次，我们需要快速的检索我们所需的内容，不需要花太多的时间去分析，理解，重构。第二种层次：这篇论文可能和你的工作并不直接相关，但是这篇论文逻辑很清晰，甚至你可以在这篇论文上找到你写作逻辑上的问题的标准答案。例如在我的论文的相关工作部分，降维技术和可解释性这部分的写作是比较困难的。困难体现在，一方面我要讲清楚降维技术，另一方面我又要紧紧围绕可解释性来描述。这对于不擅长写作的我来说是几乎无计可施的，因此我参考了Visual Interaction with Dimensionality Reduction: A Structured Literature Analysis论文的Related Work2.2节（Surveys of DR and Interaction Techniques）。通过名字可知，在这段内容里作者结合了降维技术和交互，那么我完全可以提炼出作者的写作逻辑，模仿作者的写法，写我的降维技术和可解释性部分的相关工作。</p>
<p>我简单的总结一下我在提炼作者的写作逻辑时，得到的有价值的经验吧：</p>
<ol>
<li>相关工作的写作一定要回答清楚以下问题：<ol>
<li>那些工作跟你的核心问题相关？</li>
<li>这些工作分别有哪些主要类型？</li>
<li>这些工作跟你的工作的联系和区别是什么？为什么不能解决你的问题？</li>
</ol>
</li>
<li>大到相关工作中的不同章节，小到相关工作中的每一个分类，我们都应该按照What，Why，How来对应。（这里Why和What可以交换顺序，亦或是多个What解决同一个How，这都是可行的）。所以我们在分析自己写的相关工作时，需要评审自己写的每一句话所起的作用，从而检查自己是否漏了What，Why，How中的某一个。</li>
</ol>
<h3 id="论文评审"><a href="#论文评审" class="headerlink" title="论文评审"></a>论文评审</h3><p>《实践论》中对检验知识（真理）是这么描述的“抓着了世界的规律性的认识，必须把它再回到改造世界的实践中去，再用到生产的实践、革命的阶级斗争和民族斗争的实践以及科学实验的实践中去。这就是检验理论和发展理论的过程，是整个认识过程的继续。理论的东西之是否符合于客观真理性这个问题，在前面说的由感性到理性之认识运动中是没有完全解决的，也不能完全解决的。要完全地解决这个问题，只有把理性的认识再回到社会实践中去， 应用理论于实践，看它是否能够达到预想的目的。许多自然科学理论之所以被称为真理，不但在于自然科学家们创立这些学说的时候，而且在于为尔后的科学实践所证实的时候。”</p>
<p>对论文评审的过程，其实就是检验自己的科研基础，写作逻辑知识的过程。我的实际评审过程是这样的，把论文中的每一个部分都按句进行分割。然后对每一个部分进行以下分析：</p>
<ol>
<li>第一轮，先从句子的语义上，了解作者要讲什么？<ol>
<li>如果能够理解清楚，那么接着分析下一句。</li>
<li>如果不能够理解，标注这一句话，再分析下一句。</li>
</ol>
</li>
<li>第二轮，结合上下文（前后句子），分析上一轮中所有不能理解的句子<ol>
<li>如果都能够理解，那么分析下一部分</li>
<li>如果不能理解，那么进行第三轮</li>
</ol>
</li>
<li>第三轮，给每一个句子标注他的成分（背景，问题，相关工作，挑战，技术方案，贡献），并整理每个句子之间的写作逻辑（What，Why，How）<ol>
<li>如果出现了成分的缺失，记录下来，这是论文写作上的错误</li>
<li>如果出现了写作逻辑的缺失，记录下来，这时论文表达不够清晰</li>
</ol>
</li>
</ol>
<p>我主要在Introduction和Related Work部分挖掘可能存在的问题（主要原因是，我写作精力大部分也花在这两块上）。对于Method，User Study和Case Study，我主要看作者能不能解决问题，有没有偷换概念，细节上就没有那么关注了。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实践论</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Interaction with Dimensionality Reduction - A Structured Literature Analysis - Reconstruct</title>
    <url>/2020/05/28/Visual-Reconstruct/</url>
    <content><![CDATA[<h2 id="Visual-Interaction-with-Dimensionality-Reduction-A-Structured-Literature-Analysis-Reconstruct"><a href="#Visual-Interaction-with-Dimensionality-Reduction-A-Structured-Literature-Analysis-Reconstruct" class="headerlink" title="Visual Interaction with Dimensionality Reduction: A Structured Literature Analysis-Reconstruct"></a>Visual Interaction with Dimensionality Reduction: A Structured Literature Analysis-Reconstruct</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li><p>Dimensionality Reduction (DR) is one of the major data abstraction techniques in Visual Analytics (VA). </p>
<p>因为论文的问题是降维算法，所以背景介绍要和降维方法直接相关。</p>
</li>
<li><p>In a typical setup, data is processed by a DR algorithm, and the output is visualized and presented to the analyst (Figure 1).</p>
<p>因为上文描述了DR和VA的关系，所以在这里需要概括整个VA管线中DR起的作用。（讲了DR的Why）</p>
<p><img src="/2020/05/28/Visual-Reconstruct/image-20200528002112048.png" alt="image-20200528002112048"></p>
<a id="more"></a>
</li>
<li><p>DR aims at representing multidimensional data in low-dimensional spaces, while preserving most of its relevant structure, such as outliers, clusters, or underlying manifolds [36]. </p>
<p>在讲清楚DR在VA中的作用后，我们要深入到DR部分，讲清楚DR的目的。（讲了DR的What）</p>
</li>
<li><p>DR is commonly applied to map data from many dimensions down to just 3 or 2, so that salient structures or patterns can be perceived while exploring data visually, for example distances between data points in a scatterplot. It is also used as preprocessing for other algorithms, to improve performance by mitigating the curse of dimensionality [15]. </p>
<p>在讲清楚DR的目的后，要结合DR的目的讲清楚DR的应用场景（讲了DR的How）</p>
</li>
<li><p>Faced with a plethora of existing DR methods [54], it can be difﬁcult for analysts to choose a good one, interpret the results, and apply DR to the best advantage in a broader VA process. </p>
<p>因为DR在VA管线中很重要，所以通过交互选择合适的DR是一个有价值的问题</p>
</li>
<li><p>A common approach to overcome this challenge is to involve analysts more closely, enabling them to investigate and adapt standard methods through interactive visualizations [39]. </p>
<p>介绍解决这个问题的常用方法</p>
</li>
<li><p>In such situations, tight integration of algorithmic techniques and visualizations is essential. Contributing tools that support this duality is one of the major goals of VA [34]. Indeed, many VA applications have been proposed that offer solutions for speciﬁc DR methods and analysis problems. In these examples, the goal is usually to support the analyst in steering the underlying algorithms through effective interactions in a visual interface (e.g., [6]), a concept that has become known as “semantic interaction” [18]. </p>
<p>介绍解决这个问题一些的相关工作</p>
</li>
<li><p>Despite these efforts, more general solutions that blend machine learning and VA still do not exist. Yet, it is these more general tools that are needed to deal successfully with real-world challenges [21, 48]. </p>
<p>然而上述相关工作由于一些原因，没能很好的解决问题</p>
</li>
<li><p>Aiming at a more general understanding of how to integrate algorithmic and visual components, a wide variety of theoretical VA models and frameworks have been proposed [12,20,34,47,48]. </p>
<p>而另一些相关工作克服了这些困难</p>
</li>
<li><p>These models, however, often focus on high-level, abstract views, and fail to successfully characterize how a strong interplay between algorithms and visualizations would be realized and exploited. </p>
<p>但是这些相关工作依然存在着问题</p>
</li>
<li><p>To better understand the integration of DR and visual user interfaces, we formed an interdisciplinary group of VA and machine learning researchers. The motivating questions considered were“Exactly how do analysts interact with the DR pipeline?” and “How can we incorporate our ﬁndings into the interactive DR process?”. </p>
<p>综上所述，我们总结了上述问题的具体挑战（两个问句）</p>
</li>
<li><p>To answer these questions, we conducted a semi-automated review of 1850 papers from the visualization and VA literature. </p>
<p>In the ﬁrst step, 377 relevant papers were selected and subsequently reviewed to identify speciﬁc examples of how DR interactions are realized, and to get a comprehensive, well-grounded understanding of the overall area. </p>
<p>我们如何解决上述问题</p>
</li>
<li><p>We summarize our main ﬁndings in the form of seven guiding scenarios that describe ways of combining DR with visualization (to an extent, inspired by previous work on guiding scenarios for visualization evaluation [35]) (Section 4). </p>
<p>概述第4段的内容</p>
</li>
<li><p>We also present some relevant statistics about DR and interaction techniques (Section 5). </p>
<p>概述第5段的内容</p>
</li>
<li><p>To relate our work to existing theoretical models in VA, we incorporate the ﬁndings of the literature study in a conceptual process for interactive DR [47]. We illustrate how such models describe and support reasoning about dedicated systems, and enumerate ﬁve open research opportunities derived from our analysis (Section 6). </p>
<p>概述第6段的内容</p>
</li>
<li><p>Finally, we consider limitations of our work, and outline topics we plan to address in the future (Section 7 and 8).</p>
<p>概述第8段的内容</p>
</li>
</ol>
<h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="概述分类"><a href="#概述分类" class="headerlink" title="概述分类"></a>概述分类</h4><ol>
<li><p>This study is related to previous work in several ways: it is concerned with general theoretical models of VA and their relationship to machine learning; it makes use of DR methods; it adopts basic ways of interacting with data visualizations; and it is related to the general idea of self-reﬂection in the visualization and VA community. </p>
<p>有哪些工作和你的核心问题相关？</p>
</li>
</ol>
<h4 id="Theoretical-Models"><a href="#Theoretical-Models" class="headerlink" title="Theoretical Models"></a>Theoretical Models</h4><ol>
<li><p>In the standard VA model [34], the discovery process is characterized by interaction between data, models of the data, visualizations, and the analyst. </p>
<p>概述VA过程中交互的作用。（Why）</p>
</li>
<li><p>User interaction in this framework is aimed at model building and parameter refinement.</p>
<p>常见的交互的定义（What）（这些工作分别有哪些主要类型）</p>
</li>
<li><p>Sacha et al. [48] extended it to describe the human knowledge generation process. The extended model clarifies the role of the analyst in knowledge generation, and highlights the importance of tight integration of human and machine by enabling interaction with the system. </p>
<p>有哪些相关工作（How）</p>
</li>
<li><p>The previous models apply to VA in a generic manner. In contrast, the study presented here focuses specifically on interacting with DR methods. </p>
<p>这些相关工作和你的工作的区别</p>
</li>
<li><p>Another framework describes the problem of DR as a two-stage process [12]: it first maps high-dimensional data to a lower dimensional space, then allows another stage to reduce it to 2D for visualization. While this framework generalizes specific DR methods, it focuses on a specific application to clustered data and is limited to the two-stage process as described.</p>
<p>另一种交互的定义（What）（这些工作分别有哪些主要类型）</p>
</li>
<li><p>The framework for observation-level interaction with statistical models [20] focuses on interaction by direct manipulation of visualization by different projection techniques. Therefore, it yields a generic approach toward interacting with the output of DR methods, which is one part of our human-in-the-loop process model; i.e., observation-level interaction directly fits in our proposed process of interaction with DR methods. </p>
<p>有哪些相关工作（How）</p>
</li>
<li><p>Another general model is semantic interaction [18], taking acquired interaction data as a means to build user models and guide the VA system.</p>
<p>还有什么交互的定义（What）（这些工作分别有哪些主要类型）</p>
</li>
</ol>
<h4 id="Surveys-of-DR-and-Interaction-Techniques"><a href="#Surveys-of-DR-and-Interaction-Techniques" class="headerlink" title="Surveys of DR and Interaction Techniques"></a>Surveys of DR and Interaction Techniques</h4><ol>
<li><p>DR maps data into fewer dimensions aiming to preserve structure like cluster gaps or local manifold continuity. </p>
<p>DR是什么（What）</p>
</li>
<li><p>In linear DR output axes are linear combinations of original features, for example directions of largest variation in principal component analysis (PCA), maximally statistically independent directions in independent component analysis (ICA) [26], directions of maximal between-class and minimal within-class variation in linear discriminant analysis (LDA), or directions of maximal correlation between feature subsets in canonical correlation analysis (CCA). </p>
<p>线性DR是什么（What），怎么做（How）</p>
</li>
<li><p>Nonlinear DR finds either a mapping function or only output coordinates for the data set, interpreted through proximities or distances of output data; for example, mappings are sought to preserve pairwise data distances in multidimensional scaling (MDS), small distances in Sammon mapping, distances along a neighborhood graph in Isomap, or neighborhood relationships in neighbor embedding methods [54, 55]. Some methods seek mappings onto a regular grid of units as in self-organizing maps (SOMs) or generative topographic mapping (GTM). Details on PCA, MDS, Sammon mapping, Isomap, SOM, and GTM are available in books such as [36] and for LDA and CCA in [1]. </p>
<p>非线性DR是什么（What），怎么做（How）</p>
</li>
<li><p>Van der Maaten et al. [54] offer a comparative review of the state of the art in DR techniques, focusing on the performance of nonlinear techniques from the machine learning perspective. Similarly, Wismuller ¨ et al. [57] survey nonlinear DR, manifold and topological learning techniques. Bengio et al. [3] give an overview on representation learning in the context of deep learning. </p>
<p>其他的DR综述做了什么工作</p>
</li>
<li><p>However, all the aforementioned works do not take into account VA or user interaction. </p>
<p>这些综述和我们工作的区别</p>
</li>
<li><p>A survey by Liu et al. [39] covers visualization of high-dimensional data, including DR as one of the main techniques. They include a short discussion of interaction, and embed examples into the traditional visualization pipeline. </p>
<p>另一些更相关的综述做了什么工作</p>
</li>
<li><p>However, they focus on general interaction techniques and not specifically how users interact with DR. </p>
<p>这些综述和我们工作的区别</p>
</li>
<li><p>Furthermore, they enumerate interactive model manipulation as a future research opportunity. Similarly, Buja et al. [9] review interaction techniques in the general setting of highdimensional data visualization. Hoffman and Grinstein [24] and Bertini and Lalanne [4] discuss visualization methods for high-dimensional data mining, including projection and interaction methods. Keim [33] structures such visualization approaches according to the type of data to be visualized, the actual visualization technique, and the interaction and distortion method. </p>
<p>此外还有那些相关的工作</p>
</li>
<li><p>However, none of these surveys performed a systematic exploration of the existing literature, nor did they focus on interaction techniques for DR.</p>
<p>这些工作为什么不能解决我的问题</p>
</li>
</ol>
<h4 id="Interaction-Taxonomies"><a href="#Interaction-Taxonomies" class="headerlink" title="Interaction Taxonomies"></a>Interaction Taxonomies</h4><ol>
<li><p>Our study addresses interaction in the context of DR. Therefore, related work includes general models of interaction for visualization. </p>
<p>那些工作和我们的核心问题相关</p>
</li>
<li><p>For example, Yi et al. [58] identify seven interaction method categories: select, explore, reconfigure, encode, abstract/elaborate, filter, and connect. Brehmer and Munzner [7] provide a comprehensive description of visualization tasks, leading to a multi-level typology of abstract tasks (which includes the ones by Yi et al.). </p>
<p>有哪些相关工作（How）</p>
</li>
<li><p>However, model interactions only arise in tasks they call “aggregate” or “derive” tasks. </p>
<p>这些相关工作与我的工作的区别</p>
</li>
<li><p>Von Landesberger et al. [56] define an interaction taxonomy that is suitable for tracking and analyzing user actions in VA, and provides two types of data processing interactions: data changes, such as editing or selecting data, and processing changes, such as scheme or parameter changes. </p>
<p>还有那些相关工作</p>
</li>
<li><p>In contrast, our work focuses less on a general description of user tasks, but rather on the process of interacting with DR methods.</p>
<p>这些相关工作为什么不能解决我的问题</p>
</li>
</ol>
<h4 id="Self-Reflection-in-the-Visualization-and-VA-Community"><a href="#Self-Reflection-in-the-Visualization-and-VA-Community" class="headerlink" title="Self-Reflection in the Visualization and VA Community"></a>Self-Reflection in the Visualization and VA Community</h4><ol>
<li><p>Because our study is based on a systematic review, coding, and analysis of previous work in the visualization and VA community, it is also related to previous work on self-reflection of empirical studies in information visualization [35], evaluation in visualization research in general [28], or affordance in human computation and human-computer interaction [14]. </p>
<p>有哪些工作和我们的核心问题相关</p>
</li>
<li><p>While we adopt the methodology of systematic analysis of previous work, our paper has a very different focus.</p>
<p>这些相关工作为什么不能解决我的问题</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>论文重构</tag>
        <tag>可视分析</tag>
      </tags>
  </entry>
</search>
