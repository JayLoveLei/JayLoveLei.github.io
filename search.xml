<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GPt-SNE</title>
    <url>/2020/04/27/GPt-SNE/</url>
    <content><![CDATA[<h1 id="GPt-SNE-论文重构与分析"><a href="#GPt-SNE-论文重构与分析" class="headerlink" title="GPt-SNE 论文重构与分析"></a>GPt-SNE 论文重构与分析</h1><h2 id="Introduction："><a href="#Introduction：" class="headerlink" title="Introduction："></a>Introduction：</h2><ul>
<li>首先直接指出目前的可视化的作用和目前可视化方法的痛点<ul>
<li>痛点：<ul>
<li>最先进的可视化方法往往是黑盒方法，无法洞察可视化如何编码数据的原始特征</li>
<li>其他方法如Autoencoder和pt-SNE使用复杂神经网络，对人来说依然难以理解</li>
</ul>
</li>
<li>分析：直接指出可视化的痛点，也是一种很好的表达，观点看起来很清晰，之前自己的写作顾虑太多，应该就事论事。其实作者的观点和我是一致的，但是我一没讲清楚，二是不够自信，过多的自我怀疑对工作毫无益处。</li>
</ul>
</li>
<li>接着指出有良好可解释性的线性方法，在降维上固有的局限性：<ul>
<li>痛点：线性方法仅通过对原始特征的线性组合来编码可视化</li>
<li>分析：还是不够自信吧，我们写的太拘谨了，其实我自己写作的时候，就一直在思考为什么不去直接指出线性方法的局限性，我觉得要多坚持自己的想法。</li>
</ul>
</li>
<li>然后介绍基于树的GP（genetic programming）方法，该方法常用于FC（feature construction）中的降维，并且是公认可解释的。最后明确指出，GP方法还并未被用于生成可解释的降维模型即可解释的的可视化。<ul>
<li>分析：觉得自己调研的不够充分，毕竟我都没收集到GP方法。论文写法上来说，我觉得简单直接，我在写作中也要以他为模板，即使技术方案简单也没什么好扭捏的。</li>
</ul>
</li>
<li>接着给出了他们之前的工作GP-MaL（该工作使用GP方法进行降维），并指出了之前工作存在的一些问题。<ul>
<li>分析：这样写，一方面阐述了作者在GP方法上是有底蕴的，让人更相信作者的表达。我觉得我在写作的时候可以多引用作者的论文和表达，体现出我在该研究方向上的理解。</li>
</ul>
</li>
<li>然后给出了论文的技术方案：多目标GP方法。<ul>
<li>分析：Introduction通过前两段才讲清楚问题，但是并没有让人觉得冗余。而我总是追求一句话讲清楚，为了达到这个目标，就在非线性方法的问题和线性方法的问题中做取舍，最后不伦不类，要多反思，不能僵化自己的思维。</li>
</ul>
</li>
<li>最后总结了论文的贡献：<ul>
<li>贡献：<ul>
<li>Propose a holistic set of functions and terminals for creating powerful and interpretable models for visualisation; </li>
<li>Design a multi-objective approach to allow for the evolution of a solution front containing visualisations representing different levels of quality and complexity; </li>
<li>Compare the quality and interpretability of the evolved visualisations with those produced by state-of-the-art visualisation methods on a range of datasets; </li>
<li>Perform an in-depth analysis of the trade-off between visualisation quality and tree complexity to demonstrate the unique advantages of the proposed approach.</li>
</ul>
</li>
<li>分析：我觉得贡献部分写的很平实，我在写贡献部分的时候也要平实，不要故弄玄虚。</li>
</ul>
</li>
</ul>
<h2 id="BackGround"><a href="#BackGround" class="headerlink" title="BackGround"></a>BackGround</h2><ul>
<li>Dimensionality Reduction：降维是一种通过减少数据集的特征/属性数量来提高理解和性能的过程，随着数据集变得越来越大，深层神经网络变得越来越不可解释，其重要性也在不断增加。解决这个问题的常用技术包括FS（feature select）和FC，他们分别通过删除不需要的特征或创建更少、更复杂的元特征来减少特征空间。GP方法由于其功能性和可解释性而被证明是一种适合FC问题的方法。流形学习（非线性降维）可以被看作是一种无监督的FC方法，其任务是建立一组表示高维特征空间中存在的非线性流形的特征。实现这一任务的一种方法是尝试构建一个函数，将高维空间映射到低维流形；这种方法可以在两者之间提供可理解的映射。<ul>
<li>分析：首先论文简单介绍了降维的意义和目标。与之相比我写的相关工作太冗余了，全都是已有技术的堆砌，没有紧扣主题且逻辑松散。其次论文对流形学习的介绍，用简单明了的语言就把流形学习的意义和目的讲清楚了。我在写作中要多比对自己和论文的表达。</li>
</ul>
</li>
<li>Machine Learning for Performing Visualisation:该段从机器学习的角度分析了常用的可视化方法，如FS和PCA，存在的局限性（除了简单的低维数据外，线性转换无法清晰地显示数据集中的任何低维流形/结构）。而创建最优非线性变化是一个NP难问题，因此提出了许多基于损失函数的非线性降维方法（ISOMAP，LLE）。最后提到了t-SNE，作者认为这是目前最成功的技术（当然，作者这么写的主要原因是作者的模型基于t-SNE），并对t-SNE进行了较为详细的介绍。<ul>
<li>分析：给我的感觉就是详略得当，既能感受到作者在可视化领域和机器学习领域上的积累，又写的很清爽，让人读起来很轻松。相比之下，我写的东西，要不就是全部都详写，要不就是全部都略写，主要还是自己在相关领域的积累太浅，不能把握文章的重点，要在这方面多花功夫。</li>
</ul>
</li>
<li>Multi-objective Optimisation：这部分主要介绍了MO（Multi-objective Optimisation）方法，当一个问题本质上有两个（或多个）冲突目标时使用的一种技术，在这两个目标之间必须通过问题的解决方案进行权衡。在这种情况下，解决方案的质量通常与其他解决方案的目标函数值有关。而目前最流行的的MO方法就是EC方法，这也是论文所采用的方法。<ul>
<li>分析：我在写作过程中没有了解过MO方法，所以还需要进一步深入。从写作上来说，我觉得讲的还是很清晰的，虽然我看完不知道MO方法的细节实现，但是为什么用MO方法，以及MO方法的目的，以及作者如何实现MO方法都已经了解了。所以我在介绍相对冷门的技术的时，也要这样抓住重点来讲。</li>
</ul>
</li>
<li>Related Work：作者把相关工作分成了两部分，一部分是GP方法在流形学习和可视化上的应用，另一部分介绍了其它与可解释性相关的工作。<ul>
<li>因为作者就是第一个提出将GP方法用于在流形学习，所以这一部分写的非常的自信。其中提到了三个优化目标：可分类性，视觉可解释性，语义可解释性。</li>
<li>介绍了参数t-SNE（参数t-SNE是t-SNE的一种变体，它允许在将来的样本上重用学习到的t-SNE表示。 参数化t-SNE使用受限的Boltzmann机器构造从高维空间到低维空间的映射，以构建预训练的前馈神经网络模型。 该神经网络在最大的数据集上使用了10,000多个神经元，从而严重限制了解释该网络的潜力），Autoencoder（自动编码器[3]是另一种基于神经网络的方法，它试图将数据表示压缩到尽可能小的中间隐藏层中，以便可以从简洁的表示中重新创建原始数据。 为此，自动编码器使用许多大小不同的层来编码和解码数据。 这提供了与学习到的表示之间的映射，但是在给定节点数和完全连接的拓扑的情况下进行解释是不现实的），SOM（是无监督神经网络的一种变体，已用于可视化，但是权重的数量随维度而定，因此它们的可解释性受到非平凡数据集的限制）。并指出论文和已有增强可解释性方法的区别，已有方法（如DimReader）通过更改模型参数或数据实例来分析模型，而论文提出了一种可直接解释的降维模型。</li>
<li>分析：这部分内容可以作为我们解释非线性降维相关工作参考的模板，我们不应该为了分类而分类，要紧扣自己的工作，提出符合逻辑的分类，让读者的关注点一直保持在我们的工作上。通过这段，我们可以发现我们的工作和论文工作的区别，所以我认为我们的工作还是有价值的。</li>
</ul>
</li>
</ul>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><ul>
<li><p>介绍GPt-SNE用于可视化需要解决的技术问题：</p>
<ul>
<li>什么终端和功能节点是合适的</li>
<li>如何构造适应度函数</li>
<li>标准的GP进化过程如何改进</li>
</ul>
</li>
<li><p>GP Architecture：对于每个个体构造两颗GP树，每颗树生成可视化的一个维度（即x轴或y轴）。选择多树表示而不是协作协作进化方法，因为必须紧密耦合（即高度依赖）两棵树才能提供高质量的可视化； 合作协作进化方法倾向于不确定地配对来自不同子种群的解决方案，这大大降低了发生这种耦合的能力。</p>
<ul>
<li><p><img src="/2020/04/27/GPt-SNE/1587963825918.png" alt="1587963825918"></p>
</li>
<li><p>上表中的Function是功能节点：</p>
<ul>
<li>Arithmetic Function节点通过线性变换来减少输入数目</li>
<li>Non-Linear Function节点给出了两种Sigmoid和ReLU两种激活函数实现非线性变化（作者根据Autoencoder和其他神经网络方法的启发而选择的。（我的观点：神经网络的非线性的确体现在激活函数上））</li>
<li>Conditional Function节点提供了另一种非线性变化，作者认为这种变换由于其不可微性而对GP方法来说是非常独特的，并且期望它们允许一棵树根据其输入表现出不同的行为</li>
</ul>
</li>
<li><p><img src="/2020/04/27/GPt-SNE/1587963903654.png" alt="1587963903654"></p>
<p><img src="/2020/04/27/GPt-SNE/1587963929329.png" alt="1587963929329"></p>
</li>
<li><p>上表中的Terminal是终端节点：数据集中的每个特征都被分配了一个不同的终端，该终端返回给定实例的特征值。</p>
<ul>
<li>$F_i$终端直接返回实例的第$i$个的特征值（虽然这么做为EC搜索过程提供了灵活性，但是确实为大量特征增大了搜索空间。为了解决这个问题，作者使用PCA来选择最重要的特征）</li>
<li>$NF_i$终端给定去噪后的特征值（通常通过求特征值的均值实现）</li>
<li>Constant终端提供一个$[-1,1]$之间的值，以允许树的不同部分对最终输出产生不同的影响</li>
<li>Zero终端仅包含在n+和-功能节点中，因为单独的Zero终端对树没有任何影响</li>
<li>表2中的LIKEHOOD表示从终端集中选择终端的权重</li>
</ul>
</li>
</ul>
</li>
<li><p>Multi-Objective Approach：在机器学习中，模型的潜在性能与达到该性能所需的复杂性之间存在着内在的联系。例如，分离两个类的最简单模型是一个决策边界，它在空间中的某个点上简单地设置阈值，而对于三个线性可分的类，则至少需要两个阈值。而在可视化中也是如此：可视化的表达越细（具体），用于生成可视化的功能就越复杂。要在二维中重建复杂数据集的高维结构，需要两个非常大且复杂的GP树。从树中移除每个节点都会降低树重现高维概率分布的准确性（在t-SNE的情况下）。作为类比，考虑用GP树演化一个非常复杂的多项式函数：演化函数中的分量（节点）越少，可用于逼近函数的拐点就越少。为此作者使用多目标优化的方法来生成一套解决方案，从而在可视化质量和模型可解释性之间进行权衡。</p>
<ul>
<li><p>分析：作者的GP树，通过自底向上的功能节点计算，最后得到（x|y）轴上的投影。与之对比，他们的降维方法是全局的，而我们的降维方法是局部的。他们的降维方法是非线性的，我们的降维方法是全局非线性，局部线性的。</p>
</li>
<li><p>Objective 1 ：Visualisation Quality</p>
<ul>
<li>论文简要介绍了t-SNE的优化原则以及它的Cost Function。并且使用t-SNE的Cost Function作为第一个优化目标（可视化质量）。</li>
</ul>
</li>
<li><p>Objective 2：Model Complexity</p>
<ul>
<li><p>GP中遇到的一个常见问题是生成膨胀的树，其中GP树比达到给定适应度所需的树大得多。传统场景中，由于对树的规模不做限制，因此树可能包含不必要的复杂子树。</p>
</li>
<li><p>论文计算模型复杂度的公式：<img src="/2020/04/27/GPt-SNE/1587980851820.png" alt="1587980851820"></p>
<p>其中$T$是树，$I$是降维模型，$N_i$是树中的节点。</p>
</li>
</ul>
</li>
<li><p>分析：其实我觉得简单直接的方法，在有效的情况下挺好的</p>
</li>
</ul>
</li>
<li><p>Optimisation of Tree Constants：为了进一步提高可视化质量而不引入额外的模型复杂性，论文使用粒子群优化（PSO）[35]在进化过程的最后阶段对每个个体的短暂随机常数（ERC）进行微调。 标准GP无法有效地微调其数字参数（因为它随机搜索参数空间）； 通过采用PSO，论文可以做到这一点。（来自两棵树的）每个ERC都在PSO表示中分配了一个维度，给定维度的值表示给定ERC的值与其原始值相差多少。 论文使用很小范围的初始位置值（[-0.15，0.15]）和较低的最小和最大速度（-0.05和0.05）将PSO搜索集中于微调树中的ERC。 将所有0值（即原始ERC值）初始化为30个粒子之一，以确保PSO搜索不会产生劣等解。  PSO搜索是单目标的（因为树结构是固定的），适应度函数是与GP搜索中的第一个目标相同的代价函数（公式（5））。  PSO仅在GP进化过程的末尾使用，这既是因为其计算成本，又是为了防止GP陷入因进化过程中的微调而导致的局部最小值。</p>
<ul>
<li>分析：这部分提到了一个跟有意思的概念，提高可视化质量而不引入额外的模型复杂性，我要在设计实现方案时多考虑这样的技术。</li>
</ul>
</li>
<li><p>Other Considerrations：这一部分讲述了作者对标准MOEA/D的改动和默认参数的设置。并且作者提到使用多线程技术，和缓存GP树来加快运算。</p>
<ul>
<li>分析：这部分我也在我的技术方案里提到，但我是在技术方案中直接给出的，作者在最后给出这些优化细节，可能更有利于读者理解核心技术。</li>
</ul>
</li>
</ul>
<h2 id="Experiment-setup"><a href="#Experiment-setup" class="headerlink" title="Experiment setup"></a>Experiment setup</h2><ul>
<li>第一部分给出了作者使用的数据集列表，并且介绍了为什么使用这些数据集“这些数据集来自许多不同的领域，包括一般分类、生物学和图像分析。这些数据集大多来自UCI存储库[38]。”<ul>
<li>分析：在介绍实验数据集时，最好引用别人的工作，这样显得客观，但是在算法验证部分，为了帮助用户理解，可以使用人工数据集。</li>
<li><img src="/2020/04/27/GPt-SNE/1588167232568.png" alt="1588167232568"></li>
</ul>
</li>
<li>第二部分作者分析了GP-tSNE方法的特性，包括遗传代数，树的大小，实例覆盖率等。并且指出了这些参数可以充分发挥GP方法的性能（即进一步调整参数不会提高性能）<ul>
<li>分析：可以给出一组合适的参数，并给出使用这组参数的理由，从而指导用户使用。</li>
<li><img src="/2020/04/27/GPt-SNE/1588168104405.png" alt="1588168104405"></li>
</ul>
</li>
</ul>
<ul>
<li>第三部分作者对比了GP-tSNE和t-SNE之间的运算开销。并且分析了导致计算开销高的原因，最后提到作者给出了并行化方案来加速。<ul>
<li>分析：作者的描述“此外，GP-t SNE在一次运行中产生许多可视化，而t-SNE只产生一个可视化。在最大的数据集，图像分割，GPtSNE需要30小时，而t-SNE需要大约两分钟。”，我们在描述我们的技术方案时，也可以参考作者的描述，并且我们的方法相比作者的方法更快。</li>
</ul>
</li>
</ul>
<h2 id="Results-and-Discussion"><a href="#Results-and-Discussion" class="headerlink" title="Results and Discussion"></a>Results and Discussion</h2><ul>
<li><p>这一部分为论文的Case study。因为解决方案本质上是一个降维方法，所以作者主要在对比t-SNE和GP-tSNE的可视化效果（Cost Function 和 可视化视图）。</p>
</li>
<li><p>作者在讲到GP-tSNE的Cost Function大于t-SNE时，用到了一句话“与Iris数据集一样，GP-tSNE在最大复杂度下所获得的成本虽然接近于t-SNE，但它是通过映射而非嵌入产生的。”</p>
<ul>
<li>分析：我们的技术方案的基础是“Local Linear，Global no-Linear”。所以目前的我们的case study是面向无类别流形数据，发现并理解流形数据中的非线性特征。但是在多类简单数据上（简单体现在每个类别能被一个线性子空间表示），我们的方法应该也能有不错的效果。</li>
</ul>
</li>
<li>GP-tSNE和t-SNE的Cost function值的差（横坐标遗传代数）：<img src="/2020/04/27/GPt-SNE/1588241733421.png" alt="1588241733421"><ul>
<li>分析：可以看到，对于不同复杂程度的数据，在不同的遗传代数上收敛。对于我们的解决方案，可以绘制数据的分片大小和重建误差均值的折线图，来展示不同复杂度的数据集对解决方案的影响。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>可理解性</tag>
        <tag>非线性降维</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-104.二叉树的最大深度</title>
    <url>/2020/05/01/LeetCode-104/</url>
    <content><![CDATA[<h2 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode-104.二叉树的最大深度"></a>LeetCode-104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h2 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h2><p>只需要使用深度搜索遍历树。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">int</span> lv = func(root-&gt;left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rv = func(root-&gt;right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> lv &gt; rv ? lv : rv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-226.翻转二叉树</title>
    <url>/2020/04/30/LeetCode-226/</url>
    <content><![CDATA[<h2 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode-226.翻转二叉树"></a>LeetCode-226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>输入：</p>
<pre><code>      4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>输出：</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><h2 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h2><p>这题就是交换二叉树的左右节点。因为你交换二叉树的左右节点，是不会影响到父节点和子节点的。即交换完，你的父节点还是你的父节点，你的子节点还是你的子节点。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode *tmp = <span class="literal">nullptr</span>,*tmp2 = <span class="literal">nullptr</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp2 = q.front();</span><br><span class="line">            tmp = tmp2-&gt;left;</span><br><span class="line">            tmp2-&gt;left = tmp2-&gt;right;</span><br><span class="line">            tmp2-&gt;right = tmp;</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;left)</span><br><span class="line">                q.push(tmp2-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp2-&gt;right)</span><br><span class="line">                q.push(tmp2-&gt;right);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23.合并K个排序链表</title>
    <url>/2020/04/26/LeetCode-23/</url>
    <content><![CDATA[<h2 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23.合并K个排序链表"></a>LeetCode 23.合并K个排序链表</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="循环合并最后两个链表：花费时间168ms"><a href="#循环合并最后两个链表：花费时间168ms" class="headerlink" title="循环合并最后两个链表：花费时间168ms"></a>循环合并最后两个链表：花费时间168ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *a = <span class="literal">nullptr</span>,*b = <span class="literal">nullptr</span>,*c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        b = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        c = marge(a,b);</span><br><span class="line">        lists.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用分治法：耗时24ms"><a href="#使用分治法：耗时24ms" class="headerlink" title="使用分治法：耗时24ms"></a>使用分治法：耗时24ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!a)</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">margeFunc</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low+<span class="number">1</span> == high)</span><br><span class="line">    	<span class="keyword">return</span> lists[low];</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    ListNode *ls = margeFunc(lists,low,middle);</span><br><span class="line">    ListNode *rs = margeFunc(lists,middle,high);</span><br><span class="line">    ListNode *s = marge(ls,rs);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">    ans = margeFunc(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用优先队列：耗时48ms"><a href="#使用优先队列：耗时48ms" class="headerlink" title="使用优先队列：耗时48ms"></a>使用优先队列：耗时48ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](ListNode* &amp;a,ListNode* &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)&gt; que(comp);</span><br><span class="line">    ListNode *Head = <span class="literal">nullptr</span>,*temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != lists.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])</span><br><span class="line">        &#123;</span><br><span class="line">			que.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Head)</span><br><span class="line">        &#123;</span><br><span class="line">            Head = temp = que.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = que.top();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            que.push(temp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分需要注意，构造优先队列的第三参数时仿函数。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-33.搜索旋转排序数组</title>
    <url>/2020/04/27/LeetCode-33/</url>
    <content><![CDATA[<h2 id="LeetCode-33-搜索旋转排序数组"><a href="#LeetCode-33-搜索旋转排序数组" class="headerlink" title="LeetCode-33.搜索旋转排序数组"></a>LeetCode-33.搜索旋转排序数组</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>1.本质上还是二分查找，但是对排序数组旋转后，需要做一些判断确定下一次的检索区域</p>
<p>2.当middle &lt; target时，我们需要判断low-&gt;middle是否为一个连续区间，如果成立，那么target只会在middle和high之间，因为low-&gt;middle都 &lt; target。如果low-&gt;middle不为一个连续区间，那么middle-&gt;high为一个连续区间，此时我们要判断high是否 &gt;= target，如果成立就在middle-&gt;high区间，反之在low-&gt;middle区间。</p>
<p>3.当middle &gt; target时，我们需要判断middle-&gt;high是否为一个连续区间，如果成立，那么target只会在low和middle之间，因为middle-&gt;high都 &gt; target。如果middle和high不为一个连续区间，那么low-&gt;middle为一个连续区间，此时我们要判断low是否 &lt;= target，如果成立就在low-&gt;middle区间，反之在middle-&gt;high区间。</p>
<p>Tag: 实际实现的时候，middle不被考虑在下一次的检索区域内，因为middle已经和target比较过了。</p>
<h2 id="代码实现：（耗时0ms）"><a href="#代码实现：（耗时0ms）" class="headerlink" title="代码实现：（耗时0ms）"></a>代码实现：（耗时0ms）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = nums.<span class="built_in">size</span>(),middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] == target)</span><br><span class="line">        	<span class="keyword">return</span> middle;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt; nums[middle])</span><br><span class="line">            &#123;</span><br><span class="line">            	low = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[high<span class="number">-1</span>] &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                	low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                	high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; nums[high<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            	high = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">if</span>(nums[low] &lt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    high = middle;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    low = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        middle = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-617.合并二叉树</title>
    <url>/2020/04/28/LeetCode-617/</url>
    <content><![CDATA[<h2 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode-617.合并二叉树"></a>LeetCode-617.合并二叉树</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这道题还是很简单的，只需要判断当前合并节点在对应的两棵树上是否都不为空。如果都不为空，则继续遍历左右子树，否则直接返回另一棵不为空的树即可。</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1 &amp;&amp; !t2)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">    	<span class="keyword">return</span> t1;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">    	<span class="keyword">return</span> t2;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-461.汉明距离</title>
    <url>/2020/04/29/LeetCode-461/</url>
    <content><![CDATA[<h2 id="LeetCode-461-汉明距离"><a href="#LeetCode-461-汉明距离" class="headerlink" title="LeetCode-461.汉明距离"></a>LeetCode-461.汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<p>注意：<br>0 ≤ x, y &lt; $2^{31}$.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>这题熟悉C++位运算即可。我们通过异或可以将两个数字中不同的位置1，然后计算不同的位的个数即可。</p>
<h2 id="位运算符简介："><a href="#位运算符简介：" class="headerlink" title="位运算符简介："></a>位运算符简介：</h2><p>位逻辑运算符：</p>
<p>​    &amp; （位   “与”）    and<br>​    ^ （位   “异或”）<br>​    | （位    “或”）   or<br>​    ~ （位   “取反”）<br>移位运算符：<br>​      &lt;&lt;（左移）<br>​      &gt;&gt;（右移）</p>
<p>优先级<br>位“与”、位“或”和位“异或”运算符都是双目运算符，其结合性都是从左向右的，优先级高于逻辑运算符，低于比较运算符，且从高到低依次为&amp;、^、| </p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != <span class="number">32</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &amp; <span class="number">1</span>)</span><br><span class="line">        	++count;</span><br><span class="line">        ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
</search>
