<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-26T14:55:33.493Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Boston房价数据t-SNE投影解释</title>
    <link href="http://yoursite.com/2020/06/26/PaperExam-Boston-2020-06-26/"/>
    <id>http://yoursite.com/2020/06/26/PaperExam-Boston-2020-06-26/</id>
    <published>2020-06-26T13:25:50.000Z</published>
    <updated>2020-06-26T14:55:33.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Boston房价数据t-SNE投影解释"><a href="#Boston房价数据t-SNE投影解释" class="headerlink" title="Boston房价数据t-SNE投影解释"></a>Boston房价数据t-SNE投影解释</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li>波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。</li></ul><div class="table-container"><table><thead><tr><th>No</th><th>属性</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>CRIM</td><td>Float</td><td>城镇人均犯罪率</td></tr><tr><td>2</td><td>ZN</td><td>Float</td><td>占地面积超过2.5万平方英尺的住宅用地比例</td></tr><tr><td>3</td><td>INDUS</td><td>Float</td><td>城镇非零售业务地区的比例</td></tr><tr><td>4</td><td>CHAS</td><td>Integer</td><td>查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)</td></tr><tr><td>5</td><td>NOX</td><td>Float</td><td>一氧化氮浓度（每1000万份）</td></tr><tr><td>6</td><td>RM</td><td>Float</td><td>平均每居民房数</td></tr><tr><td>7</td><td>AGE</td><td>Float</td><td>在1940年之前建成的所有者占用单位的比例</td></tr><tr><td>8</td><td>DIS</td><td>Float</td><td>与五个波士顿就业中心的加权距离</td></tr><tr><td>9</td><td>RAD</td><td>Integer</td><td>辐射状公路的可达性指数</td></tr><tr><td>10</td><td>TAX</td><td>Float</td><td>每10,000美元的全额物业税率</td></tr><tr><td>11</td><td>PTRATIO</td><td>Float</td><td>城镇师生比例</td></tr><tr><td>12</td><td>B</td><td>Float</td><td>1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例</td></tr><tr><td>13</td><td>LSTAT</td><td>Float</td><td>人口中地位较低人群的百分数</td></tr><tr><td>14</td><td>MEDV</td><td>Float</td><td>（目标变量/类别属性）以1000美元计算的自有住房的中位数</td></tr></tbody></table></div><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>解释Boston房价数据的非线性投影</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>使用分片算法将投影分片，并从原始特征在投影上的方向和原始特征和投影的相关性两方面解释非线性投影的布局</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="分片数量为1时"><a href="#分片数量为1时" class="headerlink" title="分片数量为1时"></a>分片数量为1时</h4><ul><li><p>我们生成整个非线性投影的线性近似，该线性近似中9,10,12特征和投影之间具有较高的相关性</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626214332499.png" alt="image-20200626214332499"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图1-Boston-Div1010-特征相关性图</center> </li><li><p><strong>9号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内9号特征的值从左下到右上存在增长的趋势，并且和9号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626214902709.png" alt="image-20200626214902709"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图2-Boston-Div1010-9-非线性投影（星坐标，热力）图</center> </li><li><p><strong>10号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内110号特征的值从左到右存在增长的趋势，并且和10号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215126919.png" alt="image-20200626215126919"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图3-Boston-Div1010-10-非线性投影（星坐标，热力）图</center> <ul><li><p><strong>12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征的值从右下到左上存在增长的趋势，并且和12号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215400233.png" alt="image-20200626215400233"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图4-Boston-Div1010-12-非线性投影（星坐标，热力）图</center> <h4 id="分片数量为2时"><a href="#分片数量为2时" class="headerlink" title="分片数量为2时"></a>分片数量为2时</h4><ul><li><p>分片拓扑关系图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215656377.png" alt="image-20200626215656377"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图5-Boston-Div2-拓扑关系图</center> <ul><li><p>分片原始特征相关性河流图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215955601.png" alt="image-20200626215955601"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图6-Boston-Div2-河流图</center> <ul><li><p>我们观察到1009和1008之间的12号特征相关性变化很大，我们对此进行深入分析</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626220442329.png" alt="image-20200626220442329"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图6-Boston-Div2-河流图</center> <ul><li><p><strong>1009分片的12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征值的分布没有明显的模式</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626220706588.png" alt="image-20200626220706588"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图7-Boston-Div1009-12-非线性投影（星坐标，热力）图</center> </li><li><p><strong>1008分片的12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征的值从下到上存在增长的趋势，并且和12号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626221026553.png" alt="image-20200626221026553"></p></li></ul></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图8-Boston-Div1008-12-非线性投影（星坐标，热力）图</center> <h4 id="分片数量为3时"><a href="#分片数量为3时" class="headerlink" title="分片数量为3时"></a>分片数量为3时</h4><ul><li><p>分片拓扑关系图</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626221735990.png" alt="image-20200626221735990"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图9-Boston-Div3-拓扑关系图</center> </li><li><p>分片原始特征相关性河流图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222126025.png" alt="image-20200626222126025"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图10-Boston-Div3-河流图</center> <ul><li><p>我们观察到1009和（699,1004）之间的1号特征相关性变化很大，我们对此进行深入分析</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222330613.png" alt="image-20200626222330613"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图10-Boston-Div3-河流图</center> <ul><li><p><strong>1009分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征值的分布在整体上没有呈现出模式，仅在右下部分呈现出变化，因此相关性较低</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222512376.png" alt="image-20200626222512376"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图11-Boston-Div1009-1-非线性投影（星坐标，热力）图</center> </li><li><p><strong>699分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征的值从右到左存在增长的趋势，并且和1号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222652345.png" alt="image-20200626222652345"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图12-Boston-Div699-1-非线性投影（星坐标，热力）图</center> </li><li><p><strong>1004分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征的值从左下到右上存在增长的趋势，并且和1号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222759426.png" alt="image-20200626222759426"></p></li></ul></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图13-Boston-Div1004-1-非线性投影（星坐标，热力）图</center> <h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验：<ul><li>我们的算法能从原始特征在非线性投影上的方向和原始特征和非线性投影的相关性两方面解释非线性投影的布局</li><li>使用我们的分片算法将非线性投影划分成多个近线性的片段，能够更准确的解释非线性投影的布局</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Boston房价数据t-SNE投影解释&quot;&gt;&lt;a href=&quot;#Boston房价数据t-SNE投影解释&quot; class=&quot;headerlink&quot; title=&quot;Boston房价数据t-SNE投影解释&quot;&gt;&lt;/a&gt;Boston房价数据t-SNE投影解释&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;字段描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;CRIM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇人均犯罪率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ZN&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;占地面积超过2.5万平方英尺的住宅用地比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;INDUS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇非零售业务地区的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;CHAS&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;NOX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;一氧化氮浓度（每1000万份）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;RM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;平均每居民房数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;AGE&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;在1940年之前建成的所有者占用单位的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DIS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;与五个波士顿就业中心的加权距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;RAD&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;辐射状公路的可达性指数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;TAX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;每10,000美元的全额物业税率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;PTRATIO&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇师生比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;LSTAT&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;人口中地位较低人群的百分数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;MEDV&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;（目标变量/类别属性）以1000美元计算的自有住房的中位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释Boston房价数据的非线性投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用分片算法将投影分片，并从原始特征在投影上的方向和原始特征和投影的相关性两方面解释非线性投影的布局&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
      <category term="t-SNE" scheme="http://yoursite.com/tags/t-SNE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-207.课程表</title>
    <link href="http://yoursite.com/2020/06/26/LeetCode-207/"/>
    <id>http://yoursite.com/2020/06/26/LeetCode-207/</id>
    <published>2020-06-26T11:39:46.000Z</published>
    <updated>2020-06-26T11:49:51.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-207-课程表"><a href="#LeetCode-207-课程表" class="headerlink" title="LeetCode-207.课程表"></a>LeetCode-207.课程表</h2><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 0 到 <code>numCourse-1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>输入的先决条件是由 <code>边缘列表</code> 表示的图形，而不是 <code>邻接矩阵</code> 。详情请参见<a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li>1 &lt;= numCourses &lt;= 10^5</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>本题可约化为： 课程安排图是否是 <code>有向无环图(DAG)</code>。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p></li><li><p>思路是通过 <code>拓扑排序</code> 判断此课程安排图是否是 <code>有向无环图(DAG)</code> 。 拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</p></li><li><p>通过课程前置条件列表 <code>prerequisites</code> 可以得到课程安排图的 <code>邻接表 adjacency</code>，以降低算法时间复杂度。</p></li><li><p>算法流程:</p><ul><li>统计课程安排图中每个节点的入度，生成 入度表 <code>indegrees</code>。<br>借助一个队列 <code>queue</code>，将所有入度为 0 的节点入队。</li><li>当 <code>queue</code> 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：<ul><li>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 <code>indegrees[cur] -= 1</code>。</li><li>当入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。</li></ul></li><li>在每次 <code>pre</code> 出队时，执行 <code>numCourses--</code>；<ul><li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。</li><li>因此，拓扑排序出队次数等于课程个数，返回 <code>numCourses == 0</code> 判断课程是否可以成功安排。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">incount</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">connect</span><span class="params">(numCourses, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : prerequisites)&#123;</span><br><span class="line">            ++incount[tmp[<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">connect</span>[tmp[<span class="number">1</span>]].insert(tmp[<span class="number">0</span>]);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i != numCourses;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!incount[i])</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            --numCourses;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> loc : <span class="built_in">connect</span>[num])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!--incount[loc])&#123;</span><br><span class="line">                    q.push(loc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-207-课程表&quot;&gt;&lt;a href=&quot;#LeetCode-207-课程表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-207.课程表&quot;&gt;&lt;/a&gt;LeetCode-207.课程表&lt;/h2&gt;&lt;p&gt;你这个学期必须选修 &lt;code&gt;numCourse&lt;/code&gt; 门课程，记为 0 到 &lt;code&gt;numCourse-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：&lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入的先决条件是由 &lt;code&gt;边缘列表&lt;/code&gt; 表示的图形，而不是 &lt;code&gt;邻接矩阵&lt;/code&gt; 。详情请参见&lt;a href=&quot;https://blog.csdn.net/woaidapaopao/article/details/51732947&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图的表示法&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你可以假定输入的先决条件中没有重复的边。&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= numCourses &amp;lt;= 10^5&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-394.字符串解码</title>
    <link href="http://yoursite.com/2020/06/25/LeetCode-394/"/>
    <id>http://yoursite.com/2020/06/25/LeetCode-394/</id>
    <published>2020-06-25T15:10:32.000Z</published>
    <updated>2020-06-25T15:23:40.953Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用递归的思想来完成这道题<ul><li>对于不重复的部分，我们把字符直接加入输出中</li><li>对于重复的部分，我们把重复部分的字符放入待处理字符串中，并递归处理待处理字符串</li><li>最后把递归返回结果加入输出中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>,substr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!count &amp;&amp; <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                k = k * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count)</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">if</span>(!count)&#123;</span><br><span class="line">                    substr = decodeString(substr);</span><br><span class="line">                    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">                        ans += substr;</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    substr.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count)&#123;</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.push_back(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/p&gt;
&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;
&lt;p&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 &lt;code&gt;3a&lt;/code&gt; 或 &lt;code&gt;2[4]&lt;/code&gt; 的输入。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;3[a]2[bc]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;aaabcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;3[a2[c]]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;accaccacc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;2[abc]3[cd]ef&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;abcabccdcdcdef&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abc3[cd]xyz&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;abccdcdcdxyz&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-309.最佳买卖股票时机含冷冻期</title>
    <link href="http://yoursite.com/2020/06/23/LeetCode-309/"/>
    <id>http://yoursite.com/2020/06/23/LeetCode-309/</id>
    <published>2020-06-23T13:02:55.000Z</published>
    <updated>2020-06-23T13:48:01.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode-309.最佳买卖股票时机含冷冻期"></a>LeetCode-309.最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>可以发现每天只有<strong>不持有股票</strong>和<strong>持有股票</strong>两种状态</li><li>因此我们可以得出以下状态转移方程：<ul><li>不持有股票：$Ans[i][0] = max(Ans[i-1][0],Ans[i-1][1] + prices[i])$</li><li>持有股票：$Ans[i][1] = max(Ans[i-2][0] - prices[i], ans[i-1[1]])$</li></ul></li><li>因为我们会用到$i-2$，所以我们要手工生成前两项</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, ans[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(ans[<span class="number">0</span>][<span class="number">0</span>], ans[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]), ans[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>;i != len; ++i)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = <span class="built_in">max</span>(ans[i<span class="number">-1</span>][<span class="number">0</span>], ans[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            ans[i][<span class="number">1</span>] = <span class="built_in">max</span>(ans[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i], ans[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[len<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul><li><p>实际上持有股票（Hold），卖出股票（Sold），冷冻期（Rest）之间可以构成一个状态机</p><p><img src="/2020/06/23/LeetCode-309/143bca8f4230f2ac50a47ef57bf3ce0e78fc21fc47e21b4294b87429689fcfab-image.png" alt="image.png"></p></li><li><p>因此我们只需要在遍历股票列表时维护这个状态机，就可以得到最优解</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Hold[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,Rest[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,Sold[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Hold[<span class="number">0</span>] -= prices[<span class="number">0</span>], Sold[<span class="number">0</span>] = <span class="number">0</span>, Wait[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            Hold[<span class="number">1</span>] = <span class="built_in">max</span>(Rest[<span class="number">0</span>] - prices[i], Hold[<span class="number">0</span>]);</span><br><span class="line">            Wait[<span class="number">1</span>] = <span class="built_in">max</span>(Rest[<span class="number">0</span>], Sold[<span class="number">0</span>]);</span><br><span class="line">            Sold[<span class="number">1</span>] = Hold[<span class="number">0</span>] + prices[i]; </span><br><span class="line">            Hold[<span class="number">0</span>] = Hold[<span class="number">1</span>],Rest[<span class="number">0</span>] = Rest[<span class="number">1</span>],Sold[<span class="number">0</span>] = Sold[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Sold[<span class="number">0</span>],Rest[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-309-最佳买卖股票时机含冷冻期&quot;&gt;&lt;a href=&quot;#LeetCode-309-最佳买卖股票时机含冷冻期&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-309.最佳买卖股票时机含冷冻期&quot;&gt;&lt;/a&gt;LeetCode-309.最佳买卖股票时机含冷冻期&lt;/h2&gt;&lt;p&gt;给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/li&gt;
&lt;li&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,0,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态机" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-399.除法求值</title>
    <link href="http://yoursite.com/2020/06/22/LeetCode-399/"/>
    <id>http://yoursite.com/2020/06/22/LeetCode-399/</id>
    <published>2020-06-22T13:43:42.000Z</published>
    <updated>2020-06-22T13:57:35.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-399-除法求值"><a href="#LeetCode-399-除法求值" class="headerlink" title="LeetCode-399.除法求值"></a>LeetCode-399.除法求值</h2><p>给出方程式 <code>A / B = k</code>, 其中 <code>A</code>和 <code>B</code>均为用字符串表示的变量， <code>k</code>是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 <code>-1.0</code>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">问题: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ? </span><br><span class="line">返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure><p>输入为:<code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>(方程式，方程式结果，问题方程式)， 其中<code>equations.size() == values.size()</code>，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回<code>vector&lt;double&gt;</code>类型。</p><p>基于上述例子，输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations(方程式) &#x3D; [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values(方程式结果) &#x3D; [2.0, 3.0],</span><br><span class="line">queries(问题方程式) &#x3D; [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure><p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>要计算两个变量之间的比值，我们需要解决两个问题：<ul><li>这两个变量之间是否存在关系？（我们可以每个变量看出图中的节点，除法看成节点之间的边，描述它们之间的关系）</li><li>如果这两个变量之间存在关系，怎么构建他们之间比值之间的联系？</li></ul></li><li>为了解决上述两个问题，我们可以使用并查集<ul><li>并查集可以非常快速的判断两个元素是否属于同一个连通分量（集合）</li><li>我们可以定制一个Root函数，在节点提升的过程中，建立节点和根节点之间的比值关系。（具体实现看代码）</li><li>因此，当a和b节点有共同根节点root时，a/b = a/root * root/b；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;,<span class="keyword">double</span>&gt; div;<span class="comment">//记录不同节点之间的比值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; p;<span class="comment">//记录不同节点之间的从属关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求Child节点的根节点</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Root</span><span class="params">(<span class="built_in">string</span> &amp;Child)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p.count(Child))</span><br><span class="line">            <span class="keyword">return</span> Child;</span><br><span class="line">        <span class="built_in">string</span> Parent = p[Child];</span><br><span class="line">        <span class="comment">//节点提升</span></span><br><span class="line">        <span class="keyword">while</span>(p.count(Parent))&#123;</span><br><span class="line">            <span class="comment">//子节点和父节点以及父节点的父节点之间的关系</span></span><br><span class="line">            div[&#123;Child,p[Parent]&#125;] = div[&#123;Child,p[Child]&#125;] * div[&#123;p[Child],p[Parent]&#125;];</span><br><span class="line">            div[&#123;p[Parent],Child&#125;] = <span class="number">1.0</span> / div[&#123;Child,p[Parent]&#125;];</span><br><span class="line">            p[Child] = p[Parent];</span><br><span class="line">            Parent = p[Parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个连通分量（集合）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b, <span class="keyword">double</span> &amp;val)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ar = Root(a), br = Root(b);</span><br><span class="line">        p[br] = ar;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录新的连通分量的根节点的比值信息</span></span><br><span class="line">        div[&#123;a,a&#125;] = div[&#123;b,b&#125;] = <span class="number">1.0</span>;</span><br><span class="line">        div[&#123;a,b&#125;] = val,div[&#123;b,a&#125;] = <span class="number">1.0</span> / val;</span><br><span class="line">        div[&#123;ar,br&#125;] = div[&#123;ar,a&#125;] * div[&#123;a,b&#125;] * div[&#123;b,br&#125;];</span><br><span class="line">        div[&#123;br,ar&#125;] = <span class="number">1.0</span> / div[&#123;ar,br&#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当a和b节点有共同根节点root时，a/b = a/root * root/b；</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ar = Root(a), br = Root(b);</span><br><span class="line">        <span class="keyword">if</span>(ar == br &amp;&amp; div.count(&#123;ar,ar&#125;))&#123;<span class="comment">//这里的div.count(&#123;ar,ar&#125;)判断是为了解决计算节点不在输入节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> div[&#123;a,ar&#125;] * div[&#123;ar,b&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = values.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            add(equations[i][<span class="number">0</span>], equations[i][<span class="number">1</span>], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        len = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            ans[i] = compute(queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-399-除法求值&quot;&gt;&lt;a href=&quot;#LeetCode-399-除法求值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-399.除法求值&quot;&gt;&lt;/a&gt;LeetCode-399.除法求值&lt;/h2&gt;&lt;p&gt;给出方程式 &lt;code&gt;A / B = k&lt;/code&gt;, 其中 &lt;code&gt;A&lt;/code&gt;和 &lt;code&gt;B&lt;/code&gt;均为用字符串表示的变量， &lt;code&gt;k&lt;/code&gt;是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 &lt;code&gt;-1.0&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 a &amp;#x2F; b &amp;#x3D; 2.0, b &amp;#x2F; c &amp;#x3D; 3.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;问题: a &amp;#x2F; c &amp;#x3D; ?, b &amp;#x2F; a &amp;#x3D; ?, a &amp;#x2F; e &amp;#x3D; ?, a &amp;#x2F; a &amp;#x3D; ?, x &amp;#x2F; x &amp;#x3D; ? &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入为:&lt;code&gt;vector&amp;lt;pair&amp;lt;string, string&amp;gt;&amp;gt; equations, vector&amp;lt;double&amp;gt;&amp;amp; values, vector&amp;lt;pair&amp;lt;string, string&amp;gt;&amp;gt; queries&lt;/code&gt;(方程式，方程式结果，问题方程式)， 其中&lt;code&gt;equations.size() == values.size()&lt;/code&gt;，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回&lt;code&gt;vector&amp;lt;double&amp;gt;&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;基于上述例子，输入如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;equations(方程式) &amp;#x3D; [ [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values(方程式结果) &amp;#x3D; [2.0, 3.0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queries(问题方程式) &amp;#x3D; [ [&amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;x&amp;quot;, &amp;quot;x&amp;quot;] ].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 1.Getting Started</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-1/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-1/</id>
    <published>2020-06-22T13:38:43.000Z</published>
    <updated>2020-06-22T13:42:22.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-1-Getting-Started"><a href="#Programming-in-Lua：Chapter-1-Getting-Started" class="headerlink" title="Programming in Lua：Chapter 1. Getting Started"></a>Programming in Lua：Chapter 1. Getting Started</h2><ul><li><p>Lua使用块（Chunks）作为代码执行的单位，一个Chunks可以是交互模式中的一行代码或者是一个函数</p></li><li><p>使用Chunks的方法：</p><ul><li>在交互模式中，可以使用<code>% lua -i prog​</code></li><li>或者可以使用dofile()导入别的lua文件</li></ul></li><li><p>Lua中的标识符可以是字母，数字和下划线开头，不能以数字开头</p></li><li><p>以下是Lua中的保留字，不能作为标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and      break     do        else      elseif</span><br><span class="line">end      false     for       function  goto</span><br><span class="line">if       in        local     nil       not</span><br><span class="line">or       repeat    return    then      true</span><br><span class="line">until    while</span><br></pre></td></tr></table></figure></li><li><p>注释的两种方式：</p><ul><li>以<code>--</code>开始的那一整行</li><li>以<code>--[[</code>开始直至<code>]]</code>或<code>--]]</code>结束的一整段</li></ul></li><li><p>Coding的语法喝JavaScript一致，即不需要强制添加分号，但是可以使用分号作为分隔符</p></li><li><p>全局变量不需要声明，访问未初始化的全局变量不会报错，会得到一个nil（null）值</p></li><li><p>声明但未初始化的变量和值为nil的变量存储在相同区域，不会被GC管理</p></li><li><p>Lua有8种基本类型：</p><ul><li>nil（空类型）：对全局变量分配nil使gc回收它的内存</li><li>boolean（true/false）:<ul><li>在Lua中任何值都可以表示条件，false和nil都视为false，其他值都视为true。</li><li><strong>注意数字0和空字符串也视为true！！！</strong></li><li>逻辑运算符：所有的值都会想条件控制一样被划分成true和false<ul><li>and（与操作）：如果第一个操作数为false，则返回第一个操作数，否则返回第二个操作数 （假如第一个操作数为假，那么我们返回这个操作数就可以判假，反之我们需要判断第二个操作数）</li><li>or（或操作） ：如果第一个操作数为true,  则返回第一个操作数，否则返回第二个操作数（假如第一个操作数为真，那么我们返回这个操作数就可以判真，反之我们需要判断第二个操作数）</li><li>not（非操作）：返回一个boolean值，这个值为操作数的boolean值取反</li><li>and 和 or都满足短路原则</li><li>赋默认值 x = x or y (假如x未定义，则会把默认值y赋给x)</li><li>三目运算符 a ? b : c == a and b or c （当且仅当b不为false时）</li></ul></li></ul></li><li>number (浮点数)</li><li>string （字符串）</li><li>userdata （用户数据 io.stdin）：允许将任意C数据结构存储在Lua中</li><li>function (函数)</li><li>table (数据表)</li><li>thread （线程）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-1-Getting-Started&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-1-Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Prog
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第一章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 3.Numbers</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-3/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-3/</id>
    <published>2020-06-22T13:38:37.000Z</published>
    <updated>2020-06-22T13:42:32.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-3-Numbers"><a href="#Programming-in-Lua：Chapter-3-Numbers" class="headerlink" title="Programming in Lua：Chapter 3. Numbers"></a>Programming in Lua：Chapter 3. Numbers</h2><ul><li><p>Number定义：</p><ul><li>在5.2版本之前，Lua使用双精度浮点格式表示Number</li><li>从5.3版本开始，使用64位整数（integer）和双精度浮点数（float）来表示Number</li><li>对于受限平台，可以把Lua 5.3编译成Small Lua，它可以使用32位整数和单精度浮点数</li></ul></li><li><p>Number比较：</p><ul><li>尽管具有浮点数和整数两种Number表示形式，但是它们的类型都是Number，且它们之间是可以相互转换的，例如1 == 1.0 —&gt; true</li><li>在需要区分整数和浮点数的场景，可以使用math.type()接口（整形返回integer，浮点数返回float）</li></ul></li><li><p>Number的十六进制：</p><ul><li>使用“0x”前缀来支持十六进制常量。并且支持浮点十六进制,十六进制的数保持了浮点值的所有精度，且转换速度比十进制快</li><li><p>可以使用string.format结合”%a”来表示十六进制的数</p><ul><li><p>> string.format(“%a”, 419)         —&gt; 0x1.a3p+8 </p></li><li><p>>  string.format(“%a”, 0.1)         —&gt; 0x1.999999999999ap-4</p></li></ul></li></ul></li><li><p>Number提供的算术运算：</p><ul><li>加法，减法，乘法，除法，取反，取模</li><li>整数除法: //，将结果向负无穷大舍入</li><li>幂运算：^</li></ul></li><li><p>Number的关系运算符：</p><ul><li>>  , &lt; , &gt;=, &lt;=</li><li>相等运算符: ==</li><li>不等云运算法: ~=</li></ul></li><li><p>Number的舍入函数：</p><ul><li>floor：趋向负无穷大舍入</li><li>ceil：趋向正无穷大舍入</li><li>modf：四舍五入</li></ul></li><li><p>Number的转换：</p><ul><li>整形 —》 浮点数：整形 + 0.0 就会转换成浮点数</li><li>浮点数 —》 整形： <ul><li>浮点数和 0 或运算就会转换成整形（只有在浮点数的值精确表示为整数的情况下才可以执行这种转换，即这个浮点数没有小数部分且它在整数范围之内）</li><li>math.tointeger（x），如果x不能转换成整数，返回nil</li></ul></li></ul></li><li><p>Number中的运算符优先级，从上到下（高 —》 低）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">unary operators (- # ~ not)</span><br><span class="line">* &#x2F; &#x2F;&#x2F; %</span><br><span class="line">+ -</span><br><span class="line">.. (concatentation)</span><br><span class="line">&lt;&lt; &gt;&gt; (bitwise shifts)</span><br><span class="line">&amp; (bitwise AND)</span><br><span class="line">~ (bitwise exclusive OR)</span><br><span class="line">| (bitwise OR)</span><br><span class="line">&lt; &gt; &lt;&#x3D; &gt;&#x3D; ~&#x3D; &#x3D;&#x3D;</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-3-Numbers&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-3-Numbers&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第三章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 4.Strings</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-4/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-4/</id>
    <published>2020-06-22T13:38:34.000Z</published>
    <updated>2020-06-22T13:41:04.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-4-Strings"><a href="#Programming-in-Lua：Chapter-4-Strings" class="headerlink" title="Programming in Lua：Chapter 4. Strings"></a>Programming in Lua：Chapter 4. Strings</h2><ul><li>Lua中的String是不可修改的</li><li>Lua中的String如同其他对象（table，function）一样由Lua的GC管理内存，因此我们不必担心字符串的分配和释放。</li><li>#string获取string的长度</li><li>我们可以使用串联运算符”..”来串联两个字符串（例如，”Result is “.. 3 —》 “Result is 3”），并且串联运算符不会修改已有的字符串，而是创建并返回新一个的字符串。</li><li>多行的字符串：<ul><li>“[[“和”]]”之间的多行文本会被认为是一个String</li><li>我们也可以使用”[==(=个数自定)[“和”]==]”来表示一个长字符串</li><li>换行使用“\z”</li></ul></li><li>Lua在运行时提供数字和字符串之间的自动转换，字符串数被认为是浮点数</li><li>使用tonumber显示的转换string：<ul><li>tonumber(num,jinzhi)，jinzhi可以是2~36之间的任何基数</li></ul></li><li>String 库函数：<ul><li>string.len(s) 等价与#s</li><li>string.rep(s, n) 重复字符串s，n次</li><li>string.lower(s)返回一个副本，其中的大写字母都变为小写字母</li><li>string.upper(s)返回一个副本，其中的消息字母都变为大写字母</li><li>string.sub(s，i，j)，返回s中的第i个字符到第j个字符之间（包括i，j）字符串的副本（我们也可以使用负索引，该索引从字符串的末尾开始计数）</li><li>string.char(nums,…)，它接受一个或多个整数输入，并且将每个整数转换为一个字符</li><li>string.byte(s，i)，它返回s中第i个字符的内部数字表示形式。</li><li>string.byte(s，i，j)，它返回s中第i个字符到第j个字符之间的内部数字表示形式（包括i，j）</li><li>string.format 使用规则和C中的Printf类似</li><li>string.find（stra，strb），返回strb字符串在stra中的起始和终止位置，如果不存在，则返回il</li><li>string.gsub(str，a，b)，将str中的a全部替换成b。返回两个值，第一个值是替换后生成的副本，第二个值是替换发生的次数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-4-Strings&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-4-Strings&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第四章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 6.Functions</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-6/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-6/</id>
    <published>2020-06-22T13:38:32.000Z</published>
    <updated>2020-06-22T13:59:15.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-6-Functions"><a href="#Programming-in-Lua：Chapter-6-Functions" class="headerlink" title="Programming in Lua：Chapter 6. Functions"></a>Programming in Lua：Chapter 6. Functions</h2><ul><li><p>o:foo(x) 表示调用对象o的foo函数</p></li><li><p>function 支持多个返回值，当调用位置是Table的末尾时，返回所有返回值，其他位置只返回第一个返回值，并丢弃其他的返回值</p></li><li><p>return function() 这种形式会返回所有的返回值</p></li><li><p>return (function()) 这种形式只会返回第一个返回值</p></li><li><p>function可以支持可变参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">        s = s + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">12</span>)) <span class="comment">--&gt; 54</span></span><br></pre></td></tr></table></figure></li><li><p>table.unpack()：获取一个列表，并且把列表中的所有元素作为结果返回</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unpack</span> <span class="params">(t, i, n)</span></span></span><br><span class="line">    i = i <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    n = n <span class="keyword">or</span> #t</span><br><span class="line">    <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> t[i], <span class="built_in">unpack</span>(t, i + <span class="number">1</span>, n)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>如果在function的尾部调用另一个function，那么这个函数调用的底层实现时goto（即不再保存当前函数的堆栈信息，也不会再返回当前函数的现场，所以尾调用不会出现程序栈溢出的问题）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这些都不是尾调用，因为需要处理g(x)返回的值，<span class="keyword">goto</span>是不会回来处理值的（没有保存堆栈信息），所以不能使用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> g(x) + <span class="number">1</span> <span class="comment">-- must do the addition</span></span><br><span class="line"><span class="keyword">return</span> x <span class="keyword">or</span> g(x) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line"><span class="keyword">return</span> (g(x)) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line">//这是尾调用，尽管参数是表达式，但是不需要返回来处理返回值，可以用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> x[i].foo(x[j] + a*b, i + j)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-6-Functions&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-6-Functions&quot; class=&quot;headerlink&quot; title=&quot;Programming in L
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第六章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 5.Tables</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-5/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-5/</id>
    <published>2020-06-22T13:38:20.000Z</published>
    <updated>2020-06-22T13:58:57.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-5-Tables"><a href="#Programming-in-Lua：Chapter-5-Tables" class="headerlink" title="Programming in Lua：Chapter 5. Tables"></a>Programming in Lua：Chapter 5. Tables</h2><ul><li><p>Lua中Table可以作为数组ArrayList，集合Set，记录Dict等数据结构的载体</p></li><li><p>Table的本质是一个Dict，其关键字可以使数字，字符串等任何Lua中的值（除了nil）</p></li><li><p>Lua中的Table本质上是一个对象，可以视为一个动态分配的对象，因此程序只能操纵它们的引用（或指针）</p></li><li><p>Lua永远不会再后台隐藏或创建新的Table</p></li><li><p>创建一个Table的最简单形式就是 “a = {}”  </p></li><li><p>Table的两种构造函数形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">polyline = &#123;</span><br><span class="line">    //列表形式</span><br><span class="line">    color=<span class="string">"blue"</span>,</span><br><span class="line">    thickness=<span class="number">2</span>,</span><br><span class="line">    npoints=<span class="number">4</span>,</span><br><span class="line">    //记录形式</span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[1]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[2]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">1</span>&#125;, <span class="comment">-- polyline[3]</span></span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">1</span>&#125; <span class="comment">-- polyline[4]</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们需要一个Array时，我们仅使用带有整数键的Table</p></li><li><p>当一个Array使用连续的整数键（1…n），且中间没有中断，那么这种结构被称为序列（sequence），可以使用#来获取sequence的长度</p></li><li><p>没有内容的字段和空字段没有区别，因此<code>a = {10, 20, 30, nil, nil}</code>的长度为3</p></li><li><p>我们可以使用pairs()遍历Table中的所有键值对，遍历顺序不是固定的（可以理解为C++中的 unordered_map<T1, t2>）</T1,></p></li><li><pre><code class="lang-lua">//这种判断包是否能使用的方法导入了6个表，效率很低zip = company and company.director and company.director.address and company.director.address.zipcode//这种判断包能否使用的方法导入了3个表，效率高zip = (((company or {}).director or {}).address or {}).zipcode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Table的内置函数：</span><br><span class="line"></span><br><span class="line">  * Table.insert(t,loc,data)：把data插入到表t的第i个位置上，并把后续元素向后迁移</span><br><span class="line"></span><br><span class="line">  * Table.insert(t, data)：把数据插入到表t的末尾</span><br><span class="line"></span><br><span class="line">  * Table.remove(t, loc)：把表t中第i个位置的数据返回并删除，最后把后续元素向前迁移</span><br><span class="line"></span><br><span class="line">  * Table.move(t, s, e ,p)：把表t中从第s个位置（包括s）到第e个位置（包括e）之间的元素位移到第t个位置</span><br></pre></td></tr></table></figure>  //要将元素插入Table的开头  table.move(a, 1, #a, 2)  a[1] = newElement  //删除Table开头的元素  table.move(a, 2, #a, 1)  a[#a] = nil</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-5-Tables&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-5-Tables&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：Cha
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第五章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75.颜色分类</title>
    <link href="http://yoursite.com/2020/06/21/LeetCode-75/"/>
    <id>http://yoursite.com/2020/06/21/LeetCode-75/</id>
    <published>2020-06-21T04:00:40.000Z</published>
    <updated>2020-06-21T04:33:21.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75.颜色分类"></a>LeetCode-75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用双指针来保存0的右边界和2的左边界</li><li>开头 —&gt; nums[i] 之间都是数字0</li><li>nums[i] —&gt; nums[j]（j是当前数字的位置）之间没有数字0和2</li><li>那么当num[k] —&gt; 结尾都是数字2</li><li>那么当 j == k时，开头 —&gt; nums[i] 都为0， num[i] —&gt; num[j]之间都为1，nums[j] —&gt; nums[k]之间都为2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(),k = len - <span class="number">1</span>;i &lt;= k;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">                nums[j++] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k--] = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-75-颜色分类&quot;&gt;&lt;a href=&quot;#LeetCode-75-颜色分类&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-75.颜色分类&quot;&gt;&lt;/a&gt;LeetCode-75.颜色分类&lt;/h2&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,0,2,1,1,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,0,1,1,2,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用计数排序的两趟扫描算法。&lt;br&gt;首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常数空间的一趟扫描算法吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-279.完全平方数</title>
    <link href="http://yoursite.com/2020/06/20/LeetCode-279/"/>
    <id>http://yoursite.com/2020/06/20/LeetCode-279/</id>
    <published>2020-06-20T14:26:46.000Z</published>
    <updated>2020-06-20T14:43:28.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279.完全平方数"></a>LeetCode-279.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>我们可以发现不同的数字之间的关系为$Num[i] = min(Num[i],Num[i - j^2] + 1)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(!m.count(n))</span><br><span class="line">        &#123;</span><br><span class="line">            m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!m.count(i))&#123;</span><br><span class="line">                    m[i] =  m[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">2</span>;j * j &lt;= i;++j)&#123;</span><br><span class="line">                        m[i] = <span class="built_in">min</span>(m[i], m[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心-BFS"><a href="#贪心-BFS" class="headerlink" title="贪心+BFS"></a>贪心+BFS</h4><ul><li>上面的方法每一个数字k我们都需要遍历$\sqrt k$次，总共就是$n * k$次</li><li>实际上我们之前的遍历过程就是一颗$\sqrt k$叉树，节点所在的层数表示使用数字的个数，节点的值表示剩下的值。</li><li>我们生成树时优先生成值较小的节点，并采用BFS搜索（从上到下，从左到右）。</li><li>当我们遍历到那个值为0的节点时，返回节点所在的层数即可，并且剩下的节点都不用遍历了，从而减少计算开销</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        i = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(i * i == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;n,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ++tmp.second;</span><br><span class="line">            k = tmp.first;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="built_in">sqrt</span>(k);j &gt; <span class="number">0</span>;--j)&#123;</span><br><span class="line">                tmp.first = k - j * j;</span><br><span class="line">                <span class="keyword">if</span>(tmp.first == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> tmp.second;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-279-完全平方数&quot;&gt;&lt;a href=&quot;#LeetCode-279-完全平方数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-279.完全平方数&quot;&gt;&lt;/a&gt;LeetCode-279.完全平方数&lt;/h2&gt;&lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 &lt;code&gt;1, 4, 9, 16, ...&lt;/code&gt;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 12 &amp;#x3D; 4 + 4 + 4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 13 &amp;#x3D; 4 + 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-337.打家劫舍 III</title>
    <link href="http://yoursite.com/2020/06/19/LeetCode-337/"/>
    <id>http://yoursite.com/2020/06/19/LeetCode-337/</id>
    <published>2020-06-19T12:32:09.000Z</published>
    <updated>2020-06-21T04:36:18.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-337-打家劫舍-III"><a href="#LeetCode-337-打家劫舍-III" class="headerlink" title="LeetCode-337.打家劫舍 III"></a>LeetCode-337.打家劫舍 III</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>输入: [3,2,3,null,3,null,1]          3    / \   2   3    \   \      3   1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.输入: [3,4,5,1,3,null,1]     3    / \   4   5  / \   \  1   3   1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>可以用动态规划的思想来做，如果我们把每一个节点当成根节点，那么对于该节点其最优解只有两种可能性：<ul><li>使用根节点，那么两个子节点都不使用</li><li>不使用根节点，那么两个子节点从（使用和不使用）两种方案里选择最优方案</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//方案1,比较慢，但是代码比较容易理解</span></span><br><span class="line">    <span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.count(root))</span><br><span class="line">            <span class="keyword">return</span> m[root];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val += func(root-&gt;left-&gt;left) + func(root-&gt;left-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val += func(root-&gt;right-&gt;left) + func(root-&gt;right-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        m[root] = <span class="built_in">max</span>(val,func(root-&gt;left) + func(root-&gt;right));</span><br><span class="line">        <span class="keyword">return</span> m[root];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方案2，动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans =  func(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans[<span class="number">0</span>],ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">func</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> lc = func(root-&gt;left),rc = func(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> &#123;root-&gt;val + lc[<span class="number">1</span>] + rc[<span class="number">1</span>], <span class="built_in">max</span>(lc[<span class="number">0</span>],lc[<span class="number">1</span>]) + <span class="built_in">max</span>(rc[<span class="number">0</span>],rc[<span class="number">1</span>])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-337-打家劫舍-III&quot;&gt;&lt;a href=&quot;#LeetCode-337-打家劫舍-III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-337.打家劫舍 III&quot;&gt;&lt;/a&gt;LeetCode-337.打家劫舍 III&lt;/h2&gt;&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;输入: [3,2,3,null,3,null,1]     
     3
    / \
   2   3
    \   \ 
     3   1
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-347.前K个高频元素</title>
    <link href="http://yoursite.com/2020/06/19/LeetCode-347/"/>
    <id>http://yoursite.com/2020/06/19/LeetCode-347/</id>
    <published>2020-06-18T16:50:09.000Z</published>
    <updated>2020-06-18T16:54:39.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode-347.前K个高频元素"></a>LeetCode-347.前K个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用一个HashMap在O(n)的时间复杂度里统计各个数字出现的次数</li><li>再使用一个大小为k的堆来保存频率最高的K个元素，复杂度为O(nlogK)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;m](<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)&#123; <span class="keyword">return</span> m[a] &gt; m[b];&#125;;</span><br><span class="line">        make_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.count(num))</span><br><span class="line">                m[num] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>();iter != m.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">            heap.push_back(iter-&gt;first);</span><br><span class="line">            push_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">if</span>(heap.<span class="built_in">size</span>() &gt; k)&#123;</span><br><span class="line">                pop_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">                heap.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-347-前K个高频元素&quot;&gt;&lt;a href=&quot;#LeetCode-347-前K个高频元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-347.前K个高频元素&quot;&gt;&lt;/a&gt;LeetCode-347.前K个高频元素&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 k 高的元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-62.不同路径</title>
    <link href="http://yoursite.com/2020/06/17/LeetCode-62/"/>
    <id>http://yoursite.com/2020/06/17/LeetCode-62/</id>
    <published>2020-06-17T11:37:00.000Z</published>
    <updated>2020-06-17T11:44:53.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode-62.不同路径"></a>LeetCode-62.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="/2020/06/17/LeetCode-62/robot_maze.png" alt="img"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>非常常规的动态规划，状态转移方程如下，$F[i][j] = F[i-1][j] + F[i][j-1]$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">count</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        count[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                    count[i][j] += count[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    count[i][j] += count[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-62-不同路径&quot;&gt;&lt;a href=&quot;#LeetCode-62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-62.不同路径&quot;&gt;&lt;/a&gt;LeetCode-62.不同路径&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/17/LeetCode-62/robot_maze.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;例如，上图是一个7 x 3 的网格。有多少可能的路径？&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: m &amp;#x3D; 3, n &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从左上角开始，总共有 3 条路径可以到达右下角。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 向右 -&amp;gt; 向右 -&amp;gt; 向下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 向右 -&amp;gt; 向下 -&amp;gt; 向右&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 向下 -&amp;gt; 向右 -&amp;gt; 向右&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: m &amp;#x3D; 7, n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= m, n &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;题目数据保证答案小于等于 2 * 10 ^ 9&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-647.回文子串</title>
    <link href="http://yoursite.com/2020/06/16/LeetCode-647/"/>
    <id>http://yoursite.com/2020/06/16/LeetCode-647/</id>
    <published>2020-06-16T15:32:02.000Z</published>
    <updated>2020-06-16T16:16:56.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-647-回文子串"><a href="#LeetCode-647-回文子串" class="headerlink" title="LeetCode-647.回文子串"></a>LeetCode-647.回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br><span class="line"></span><br><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>输入的字符串长度不会超过1000。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>对于每个回文串，都有一个对称中心</li><li>这个中心可以是字符或者字符之间的空隙，假定字符串长度为N，那么就存在N*2 - 1 个位置作为中心</li><li>因此，我们遍历每个对称中心，并像两边拓展回文串，就能得到所有的回文子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len = s.length(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len * <span class="number">2</span> - <span class="number">1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                j = i/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(k = i/<span class="number">2</span> + <span class="number">1</span>;j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len; --j,++k,++ans)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] != s[k])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-647-回文子串&quot;&gt;&lt;a href=&quot;#LeetCode-647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-647.回文子串&quot;&gt;&lt;/a&gt;LeetCode-647.回文子串&lt;/h2&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 三个回文子串: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;aaa&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明: 6个回文子串: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;输入的字符串长度不会超过1000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-49.字母异位词分组</title>
    <link href="http://yoursite.com/2020/06/15/LeetCode-49/"/>
    <id>http://yoursite.com/2020/06/15/LeetCode-49/</id>
    <published>2020-06-15T03:42:36.000Z</published>
    <updated>2020-06-15T03:50:14.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-49-字母异位词分组"><a href="#LeetCode-49-字母异位词分组" class="headerlink" title="LeetCode-49.字母异位词分组"></a>LeetCode-49.字母异位词分组</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="排序数组分类"><a href="#排序数组分类" class="headerlink" title="排序数组分类"></a>排序数组分类</h4><ul><li><p>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p></li><li><p>我们使用一个Map记录排序字符串和数组位置之间的映射关系即可</p></li><li><p>时间复杂度为$O(NKlogK)$，其中$N$是字符串个数，$K$是字符串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ts;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            ts = str;</span><br><span class="line">            sort(ts.<span class="built_in">begin</span>(),ts.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(!Dict.count(ts))&#123;</span><br><span class="line">                Dict[ts] = ans.<span class="built_in">size</span>();</span><br><span class="line">                ans.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="number">1</span>, str));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[Dict[ts]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="按计数分类"><a href="#按计数分类" class="headerlink" title="按计数分类"></a>按计数分类</h4><ul><li><p>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</p></li><li><p>我们使用一个长度为26的字符串记录每个字母出现的次数，用一个Map记录出现次数字符串和数组位置之间的映射关系即可</p></li><li><p>时间复杂度为$O(NK)$，其中$N$是字符串个数，$K$是字符串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> Loc_count;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : strs)&#123;</span><br><span class="line">            Loc_count = <span class="built_in">string</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : str)&#123;</span><br><span class="line">                ++Loc_count[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Dict.count(Loc_count))&#123;</span><br><span class="line">                Dict[Loc_count] = ans.<span class="built_in">size</span>();</span><br><span class="line">                ans.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="number">1</span>, str));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[Dict[Loc_count]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-49-字母异位词分组&quot;&gt;&lt;a href=&quot;#LeetCode-49-字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-49.字母异位词分组&quot;&gt;&lt;/a&gt;LeetCode-49.字母异位词分组&lt;/h2&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有输入均为小写字母。&lt;/li&gt;
&lt;li&gt;不考虑答案输出的顺序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-215.数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2020/06/14/LeetCode-215/"/>
    <id>http://yoursite.com/2020/06/14/LeetCode-215/</id>
    <published>2020-06-14T12:50:42.000Z</published>
    <updated>2020-06-14T13:36:21.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode-215.数组中的第K个最大元素"></a>LeetCode-215.数组中的第K个最大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>我们可以使用堆排对数组排序，然后再找到第K大元素，复杂度为$O(nlog(n))$</p></li><li><p>我们也可以使用快排的思想，每一轮剪枝一部分数据来找到第K大元素，复杂度最优为$O(n)$，最坏为$O(n^2)$</p></li><li><p>我们还可以使用分治的思想来解决这个问题，分治算法当然在达到一个非常小的规模时，会能直接或用很简单的方法得出结论，但是，其实，问题规模在达到某个阈值的时候，用直接朴素的方法解决这个规模的问题的效率，已经比继续分治的算法高了。这个时候，我们在这个阈值就开始选择朴素的方法才是最明智的选择。</p></li><li><p>基本思路：</p><ol><li>当规模小于阈值时，直接用排序算法返回结果。</li><li>当n大于阈值时，把n个元素划分为5个元素一组的n/5组，排除剩余元素（不会有影响，这里只是为了求中项mm），分别排序，然后挑出每一组元素的中间值，再在所有的中间值中，递归调用本算法，挑出中间值mm。</li><li>把元素划分为$A1、A2、A3$三组，分别包含大于、等于、小于$mm$的元素。</li><li>分三种情况：<ol><li>若A1的元素数量大于等于K，即第K个元素在第一组内：在$A1$中递归查找第k小元素。</li><li>若A1、A2元素个数之和大于等于K，即中项mm为第K个元素：返回mm</li><li>否则，第K个元素在第三组：在A3中递归寻找第（$k$-|$A1、A2$元素数量之和|）大元素。</li></ol></li></ol></li><li><p>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入  n 个元素的数组 A[1...n] 和整数 k，1 ≤ k ≤ n  </span><br><span class="line">输出  A 中的第 k 小元素  </span><br><span class="line">   </span><br><span class="line">算法描述 select(A, low, high, k)  </span><br><span class="line">1. n ← high - low----（Θ(1)）  </span><br><span class="line">2. if  n &lt; 44 then 将 sort(A[low...high]) return (A[k-1])----（Θ(1)）</span><br><span class="line">3. 令 q &#x3D;  ⌊n&#x2F;5⌋。将 A 分成 q 组，每组5个元素。如果5不整除 n ，则排除剩余的元素。----（Θ(n)）  </span><br><span class="line">4. 将 q 组中的每一组单独排序，找出中项。所有中项的集合为 M。----（Θ(n)）  </span><br><span class="line">5. mm ← select(M, 0, q,  ⌈q&#x2F;2⌉)   &#123; mm 为中项集合的中项 &#125; ----T(n&#x2F;5)  </span><br><span class="line">6. 将 A[low...high] 分成三组----（Θ(n)）  </span><br><span class="line">    A1 &#x3D; &#123; a | a &gt; mm &#125;  </span><br><span class="line">    A2 &#x3D; &#123; a | a &#x3D; mm &#125;  </span><br><span class="line">    A3 &#x3D; &#123; a | a &lt; mm &#125;  </span><br><span class="line">7. case  </span><br><span class="line">    |A1| ≥ k : return select(A1, 0, |A1|, k)  </span><br><span class="line">    |A1| + |A2| ≥ k : return mm  </span><br><span class="line">    |A1| + |A2| &lt; k : return select(A3, 0, |A3|, k - |A1| - |A2|)  </span><br><span class="line">8. end case</span><br></pre></td></tr></table></figure></li><li><p>算法分析：</p><ul><li><p>第1-6步的复杂度都很容易理解，我们着重讨论第7步的算法复杂度。</p><p><img src="/2020/06/14/LeetCode-215/webp" alt="img"></p></li><li><p>上图是处理到第5步后的元素，从左到右按各组中项降序（图解是求最小值的，所以要反过来看）排列，每组5个元素从下到上按降序排列。我们需要知道的是第7步时候问题的规模，即$A1、A3$这两个数组的规模。上图中我们可以看到$W$区的元素都是小于或等于$mm$的，令$A1’$表示小于或等于$mm$的元素的集合，显然W会是$A1’$的子集，即A1’的元素数量大于等于$W$的元素数量。于是我们有下面这个式子：</p><script type="math/tex; mode=display">|A1’| \ge 3 \lceil \lfloor n/5 \rfloor /2 \rceil \ge \frac{3}{2} \lfloor n/5 \rfloor</script><p>其中$A3$的数量 = $n-A1’$的数量，于是我么可以得到下面的式子：</p><script type="math/tex; mode=display">| A_3 | \le n - \frac{3}{2} \lfloor n/5 \rfloor \le n - \frac{3}{2} (\frac{n-4}{5}) = n - 0.3n + 1.2 = 0.7n + 1.2</script><p>至此，我们知道$A1、A3$的上界是$0.7n+1.2$，步骤7耗费的时间$T(0.7n+1.2)$。到这里还没说到44阈值的由来，这是因为我们希望去掉1.2这个常数，于是引入底函数帮忙：</p><script type="math/tex; mode=display">0.7n + 1.2 \le \lfloor 0.75n \rfloor</script><p>即</p><script type="math/tex; mode=display">0.7n + 1.2 \le  0.75n - 1</script><p>解不等式可得n&gt;=44。阈值44诞生了！！！现在我们还有了算法运行时间的递推式：可以算出来$T(n)=Θ(n)$。对于求中项的题目也是同样的解法，就是找第（n+1）/2个元素（奇数）和第n/2、n/2+1个元素（偶数）。需要注意，这个算法的常数倍数（比如c）都是很大的。</p></li></ul></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty() || k &gt; nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> select(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = high - low;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">44</span>)&#123;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + low, nums.<span class="built_in">begin</span>() + high, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">return</span> nums[low + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = low;i + <span class="number">5</span> &lt; high;i += <span class="number">5</span>)&#123;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + i,nums.<span class="built_in">begin</span>() + i + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            M.push_back(nums[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mm = select(M, <span class="number">0</span>, M.<span class="built_in">size</span>(), M.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A1,A2,A3;</span><br><span class="line">        <span class="keyword">for</span>(i = low; i &lt; high;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mm)</span><br><span class="line">                A1.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == mm)</span><br><span class="line">                A2.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A3.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A1.<span class="built_in">size</span>() &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> select(A1, <span class="number">0</span>, A1.<span class="built_in">size</span>(), k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A1.<span class="built_in">size</span>() + A2.<span class="built_in">size</span>() &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> mm;</span><br><span class="line">        <span class="keyword">return</span> select(A3, <span class="number">0</span>, A3.<span class="built_in">size</span>(), k - A1.<span class="built_in">size</span>() - A2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-215-数组中的第K个最大元素&quot;&gt;&lt;a href=&quot;#LeetCode-215-数组中的第K个最大元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-215.数组中的第K个最大元素&quot;&gt;&lt;/a&gt;LeetCode-215.数组中的第K个最大元素&lt;/h2&gt;&lt;p&gt;在未排序的数组中找到第 &lt;strong&gt;k&lt;/strong&gt; 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,1,5,6,4] 和 k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Boston房价数据集实验分析</title>
    <link href="http://yoursite.com/2020/06/13/PaperExamRecord-Boston/"/>
    <id>http://yoursite.com/2020/06/13/PaperExamRecord-Boston/</id>
    <published>2020-06-13T02:21:58.000Z</published>
    <updated>2020-06-15T15:38:31.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Boston房价数据集实验分析"><a href="#Boston房价数据集实验分析" class="headerlink" title="Boston房价数据集实验分析"></a>Boston房价数据集实验分析</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li>波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。</li></ul><div class="table-container"><table><thead><tr><th>No</th><th>属性</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>CRIM</td><td>Float</td><td>城镇人均犯罪率</td></tr><tr><td>2</td><td>ZN</td><td>Float</td><td>占地面积超过2.5万平方英尺的住宅用地比例</td></tr><tr><td>3</td><td>INDUS</td><td>Float</td><td>城镇非零售业务地区的比例</td></tr><tr><td>4</td><td>CHAS</td><td>Integer</td><td>查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)</td></tr><tr><td>5</td><td>NOX</td><td>Float</td><td>一氧化氮浓度（每1000万份）</td></tr><tr><td>6</td><td>RM</td><td>Float</td><td>平均每居民房数</td></tr><tr><td>7</td><td>AGE</td><td>Float</td><td>在1940年之前建成的所有者占用单位的比例</td></tr><tr><td>8</td><td>DIS</td><td>Float</td><td>与五个波士顿就业中心的加权距离</td></tr><tr><td>9</td><td>RAD</td><td>Integer</td><td>辐射状公路的可达性指数</td></tr><tr><td>10</td><td>TAX</td><td>Float</td><td>每10,000美元的全额物业税率</td></tr><tr><td>11</td><td>PTRATIO</td><td>Float</td><td>城镇师生比例</td></tr><tr><td>12</td><td>B</td><td>Float</td><td>1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例</td></tr><tr><td>13</td><td>LSTAT</td><td>Float</td><td>人口中地位较低人群的百分数</td></tr><tr><td>14</td><td>MEDV</td><td>Float</td><td>（目标变量/类别属性）以1000美元计算的自有住房的中位数</td></tr></tbody></table></div><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>分析Boston地区房价相关的因素</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>使用分片算法将投影分片，并结合分片的主要维度分布来分析和Boston地区房价相关的因素</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><ul><li>图1是Boston房价数据集使用t-SNE降维到2维后生成的散点图，其中颜色编码该区域房价中间值，颜色越深该区域房价中间值越高。</li></ul><p><img src="/2020/06/13/PaperExamRecord-Boston/t-SNE-price.png" alt="Boston-tSNE图"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图1-Boston房价分布</center> <h4 id="t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系"><a href="#t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系" class="headerlink" title="t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系"></a>t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系</h4><ul><li><p>图2为把投影划分成两个分片的情况，这里的分片呈现出一个问题，在投影中离得很远的两个聚类，却在原始空间中为近邻关系。<img src="/2020/06/13/PaperExamRecord-Boston/Div-2.png" alt="Div-2"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图2-两分片分布</center> </li><li><p>为了进一步观察，我们把长条形的分片（1008 -&gt; 1004,699）分裂，进一步观察分片之间的拓扑关系（图3）。其中1004是蓝色（上部）的分片，699是灰色（下部）的分片，结合拓扑关系图，我们可以发现在投影中距离很远的1004分片和699分片之间存在近邻关系，而1004分片与更近的1009分片之间却不存在近邻关系。<img src="/2020/06/13/PaperExamRecord-Boston/Div-3.png" alt="Div-3"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图3-三分片分布</center> </li></ul><h4 id="Boston房价和社区人均犯罪率（1）有关"><a href="#Boston房价和社区人均犯罪率（1）有关" class="headerlink" title="Boston房价和社区人均犯罪率（1）有关"></a>Boston房价和社区人均犯罪率（1）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的犯罪率（1）相关性很低，并且1009分片的房价明显要比另外两个分片高（总体来看区域颜色更深）</p></li><li><p>因此我们提出了一个猜想，Boston房价和犯罪率（1）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的左下方社区的犯罪率越大（颜色编码相关性正负，绿色表示正相关性，蓝色表示负相关性），结合图1我们可以发现分片699中左下方方向上颜色更浅（即房价更低）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的右上方社区的犯罪率越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>因为分片1009的犯罪率相关性很低（即投影结果与犯罪率维度无关），所以我们决定直接观察分片1009的原始数据，我们发现分片1009中犯罪率都保持在2%以下，而另外两个分片（1004,699）的犯罪率在0%~70%之间浮动。这也符合我们符合我们的对犯罪率的普遍认识。</p></li><li><p>因为多个分片中存在相同的模式，因此我们认为这个假设成立</p></li></ul></li></ul><h4 id="Boston房价和社区底层人口率（13）有关"><a href="#Boston房价和社区底层人口率（13）有关" class="headerlink" title="Boston房价和社区底层人口率（13）有关"></a>Boston房价和社区底层人口率（13）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的底层人口率（13）相关性较低低，并且1009分片的房价明显要比另外两个分片高</p></li><li><p>因此我们提出了一个猜想，Boston房价和底层人口率（13）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的左上方社区的底层人口率（13）越大，结合图1我们可以发现分片699中左上方方向上颜色更浅（即房价更低）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的右上方社区的底层人口率（13）越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>因为分片1009的底层人口率（13）相关性较低，并且通过观察分片的原始数据我们发现其中还是存在一些社区的底层人口率（13）较高的，因此我们分裂了分片1009（1009-&gt;1013,994)。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/Div-4.png" alt="image-20200613205811401"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图4-四分片分布</center> </li><li><p>从分片994（图4中间位置蓝色的分片）的维度分布图中我们观察到，越靠近分片994的右上方社区的底层人口率（13）越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/994.png" alt="image-20200613210149098"></p></li><li><p>因为多个分片中存在相同的模式，因此我们认为这个假设成立</p></li></ul></li></ul><h4 id="Boston房价和社区黑人数量（12）有关"><a href="#Boston房价和社区黑人数量（12）有关" class="headerlink" title="Boston房价和社区黑人数量（12）有关"></a>Boston房价和社区黑人数量（12）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的黑人数量（12）相关性较低低，并且1009分片的房价明显要比另外两个分片高</p></li><li><p>因此我们提出了一个猜想，Boston房价和黑人数量（12）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的右上方社区的黑人数量（12）越多，结合图1我们可以发现分片699中右上方方向上颜色更深（即房价更高）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的左上方社区的黑人数量（12）越多，结合图1我们可以发现分片1004中左上方方向上颜色几乎不变（即房价变化不大）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>从分片994（图4中间位置蓝色的分片）的维度分布图中我们观察到，越靠近分片994的左上方社区的黑人数量（12）越多，结合图1我们可以发现分片1004中左上方方向上颜色几乎不变（即房价变化不大）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/994.png" alt="image-20200613210149098"></p></li><li><p>因为多个分片中不存在相同的模式，因此我们认为这个假设不成立</p></li></ul></li></ul><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验分析：<ul><li>我们发现t-SNE投影中聚类的间距不能准确表达聚类之间的近邻关系</li><li>我们发现Boston房价：<ul><li>和社区人均犯罪率（1）有关</li><li>和社区底层人口率（13）有关</li><li>和社区黑人数量（12）无关</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Boston房价数据集实验分析&quot;&gt;&lt;a href=&quot;#Boston房价数据集实验分析&quot; class=&quot;headerlink&quot; title=&quot;Boston房价数据集实验分析&quot;&gt;&lt;/a&gt;Boston房价数据集实验分析&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;字段描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;CRIM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇人均犯罪率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ZN&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;占地面积超过2.5万平方英尺的住宅用地比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;INDUS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇非零售业务地区的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;CHAS&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;NOX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;一氧化氮浓度（每1000万份）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;RM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;平均每居民房数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;AGE&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;在1940年之前建成的所有者占用单位的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DIS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;与五个波士顿就业中心的加权距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;RAD&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;辐射状公路的可达性指数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;TAX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;每10,000美元的全额物业税率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;PTRATIO&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇师生比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;LSTAT&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;人口中地位较低人群的百分数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;MEDV&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;（目标变量/类别属性）以1000美元计算的自有住房的中位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分析Boston地区房价相关的因素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用分片算法将投影分片，并结合分片的主要维度分布来分析和Boston地区房价相关的因素&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-102.二叉树的层序遍历</title>
    <link href="http://yoursite.com/2020/06/13/LeetCode-102/"/>
    <id>http://yoursite.com/2020/06/13/LeetCode-102/</id>
    <published>2020-06-13T00:27:10.000Z</published>
    <updated>2020-06-13T00:33:25.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode-102.二叉树的层序遍历"></a>LeetCode-102.二叉树的层序遍历</h2><p>给你一个二叉树，请你返回其按<strong>层序遍历</strong>得到的节点值。（即逐层地，从左到右访问所有节点）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>二叉树：[3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7 返回其层次遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>以层序遍历，所以我们使用一个<strong>queue</strong>来记录遍历序列。</li><li>又因为每一次要在同一批次遍历，所以我们使用两个<strong>int</strong>来记录，当前批次要遍历的节点个数，和下一个批次要遍历的节点个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> now,next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        q.push(root);</span><br><span class="line">        now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(now)&#123;</span><br><span class="line">                tmp.push_back(q.front()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;left)&#123;</span><br><span class="line">                    q.push(q.front()-&gt;left);</span><br><span class="line">                    ++next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;right)&#123;</span><br><span class="line">                    q.push(q.front()-&gt;right);</span><br><span class="line">                    ++next;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                --now;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#LeetCode-102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-102.二叉树的层序遍历&quot;&gt;&lt;/a&gt;LeetCode-102.二叉树的层序遍历&lt;/h2&gt;&lt;p&gt;给你一个二叉树，请你返回其按&lt;strong&gt;层序遍历&lt;/strong&gt;得到的节点值。（即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7 
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="广度优先遍历" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
