<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-16T12:37:32.327Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-312.戳气球</title>
    <link href="http://yoursite.com/2020/07/16/LeetCode-312/"/>
    <id>http://yoursite.com/2020/07/16/LeetCode-312/</id>
    <published>2020-07-16T12:29:50.000Z</published>
    <updated>2020-07-16T12:37:32.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-312-戳气球"><a href="#LeetCode-312-戳气球" class="headerlink" title="LeetCode-312.戳气球"></a>LeetCode-312.戳气球</h2><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>说明:</strong></p><ul><li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li><li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>如果穷举，这道题的复杂度是O(N!)，这是不可接受的</li><li><p>通过观察，我发现这道题可以用动态规划求解，因为它满足以下性质：</p><ul><li>最优子结构<ul><li>如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构</li><li>一个问题具有最优子结构，可能使用动态规划方法，也可能使用贪心方法。所以最优子结构只是一个线索，不是看到有最优子结构就一定是用动态规划求解</li></ul></li><li>重叠子问题<ul><li>子问题空间必须足够“小”，即在不断的递归过程中，是在反复求解大量相同的子问题，而不是每次递归时都产生新的子问题。</li><li>一般的，不同子问题的总数是输入规模的多项式函数为好</li><li>如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质</li></ul></li></ul></li><li><p>状态转移方程为$dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i] <em> nums[k] </em> nums[j]),其中i &lt; k &lt; j$</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.insert(nums.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        nums.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">m</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j + i &lt; len;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k = <span class="number">1</span>;k &lt; i;++k)&#123;</span><br><span class="line">                    m[j][j+i] = <span class="built_in">max</span>(m[j][j+i],m[j][j+k] + m[j+k][j+i] + nums[j] * nums[j+k] * nums[j+i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[<span class="number">0</span>][len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-312-戳气球&quot;&gt;&lt;a href=&quot;#LeetCode-312-戳气球&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-312.戳气球&quot;&gt;&lt;/a&gt;LeetCode-312.戳气球&lt;/h2&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个气球，编号为&lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;，每个气球上都标有一个数字，这些数字存在数组 &lt;code&gt;nums&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。如果你戳破气球 &lt;code&gt;i&lt;/code&gt; ，就可以获得 &lt;code&gt;nums[left] * nums[i] * nums[right]&lt;/code&gt; 个硬币。 这里的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 代表和 &lt;code&gt;i&lt;/code&gt; 相邻的两个气球的序号。注意当你戳破了气球 &lt;code&gt;i&lt;/code&gt; 后，气球 &lt;code&gt;left&lt;/code&gt; 和气球 &lt;code&gt;right&lt;/code&gt; 就变成了相邻的气球。&lt;/p&gt;
&lt;p&gt;求所能获得硬币的最大数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以假设 &lt;code&gt;nums[-1] = nums[n] = 1&lt;/code&gt;，但注意它们不是真实存在的所以并不能被戳破。&lt;/li&gt;
&lt;li&gt;0 ≤ &lt;code&gt;n&lt;/code&gt; ≤ 500, 0 ≤ &lt;code&gt;nums[i]&lt;/code&gt; ≤ 100&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,1,5,8]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 167 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: nums &amp;#x3D; [3,1,5,8] --&amp;gt; [3,5,8] --&amp;gt;   [3,8]   --&amp;gt;  [8]  --&amp;gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     coins &amp;#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &amp;#x3D; 167&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-98.验证二叉搜索树</title>
    <link href="http://yoursite.com/2020/07/14/LeetCode-98/"/>
    <id>http://yoursite.com/2020/07/14/LeetCode-98/</id>
    <published>2020-07-14T13:54:11.000Z</published>
    <updated>2020-07-14T13:56:55.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode-98.验证二叉搜索树"></a>LeetCode-98.验证二叉搜索树</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li><p>节点的右子树只包含大于当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>二叉搜索树中序遍历的结果应该是单调递增的</li><li>如果不满足单调递增，就不是二叉搜索树</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            Get(root-&gt;left,ans);</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            Get(root-&gt;right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        Get(root,ans);</span><br><span class="line">        <span class="keyword">int</span> i,len = ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] &lt;= ans[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#LeetCode-98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-98.验证二叉搜索树&quot;&gt;&lt;/a&gt;LeetCode-98.验证二叉搜索树&lt;/h2&gt;&lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;假设一个二叉搜索树具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含小于当前节点的数。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;节点的右子树只包含大于当前节点的数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有左子树和右子树自身必须也是二叉搜索树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#x2F; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    3   6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入为: [5,1,4,null,null,3,6]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     根节点的值为 5 ，但是其右子节点值为 4 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3. 无重复字符的最长子串</title>
    <link href="http://yoursite.com/2020/07/14/LeetCode-3/"/>
    <id>http://yoursite.com/2020/07/14/LeetCode-3/</id>
    <published>2020-07-14T13:31:38.000Z</published>
    <updated>2020-07-14T14:00:20.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode-3. 无重复字符的最长子串"></a>LeetCode-3. 无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>创建一个不定大小滑动窗口</li><li>保证滑动窗口内，不会出现重复的字符</li><li>记录最大的窗口大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">use</span><span class="params">(<span class="number">128</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>(),i,j,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>;i != len;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(use[s[i]])&#123;</span><br><span class="line">                use[s[j]] = <span class="literal">false</span>;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                use[s[i]] = <span class="literal">true</span>;</span><br><span class="line">                ++i;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,i - j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-3-无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#LeetCode-3-无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-3. 无重复字符的最长子串&quot;&gt;&lt;/a&gt;LeetCode-3. 无重复字符的最长子串&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;bbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;pwwkew&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2.两数相加</title>
    <link href="http://yoursite.com/2020/07/14/LeetCode-2/"/>
    <id>http://yoursite.com/2020/07/14/LeetCode-2/</id>
    <published>2020-07-14T06:01:07.000Z</published>
    <updated>2020-07-14T06:07:00.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-2-两数相加"><a href="#LeetCode-2-两数相加" class="headerlink" title="LeetCode-2.两数相加"></a>LeetCode-2.两数相加</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>每种情况都要考虑是否要进位</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> jin = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1 &amp;&amp; !l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jin)&#123;</span><br><span class="line">                jin = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            l1-&gt;val += l2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(jin)&#123;</span><br><span class="line">                ++l1-&gt;val;</span><br><span class="line">                jin = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                jin = <span class="literal">true</span>;</span><br><span class="line">                l1-&gt;val -= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1-&gt;next = addTwoNumbers(l1-&gt;next,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *now = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            now = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            now = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jin)&#123;</span><br><span class="line">            ++now-&gt;val;</span><br><span class="line">            jin = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;val &gt; <span class="number">9</span>)&#123;</span><br><span class="line">            jin = <span class="literal">true</span>;</span><br><span class="line">            now-&gt;val -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now-&gt;next = addTwoNumbers(now-&gt;next,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-2-两数相加&quot;&gt;&lt;a href=&quot;#LeetCode-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-2.两数相加&quot;&gt;&lt;/a&gt;LeetCode-2.两数相加&lt;/h2&gt;&lt;p&gt;给出两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且它们的每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：7 -&amp;gt; 0 -&amp;gt; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原因：342 + 465 &amp;#x3D; 807&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-19.删除链表的倒数第N个节点</title>
    <link href="http://yoursite.com/2020/07/14/LeetCode-19/"/>
    <id>http://yoursite.com/2020/07/14/LeetCode-19/</id>
    <published>2020-07-14T04:59:06.000Z</published>
    <updated>2020-07-14T06:07:33.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-19-删除链表的倒数第N个节点"><a href="#LeetCode-19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode-19.删除链表的倒数第N个节点"></a>LeetCode-19.删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 n 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>先递归到数组末尾</li><li>回溯时记录是第几个节点</li><li>删除对应节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ListNode* head,<span class="keyword">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;</span><br><span class="line">           func(head-&gt;next,n);</span><br><span class="line">           --n;</span><br><span class="line">           <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">               head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        func(head,n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-19-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#LeetCode-19-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-19.删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;LeetCode-19.删除链表的倒数第N个节点&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
&lt;h3 id=&quot;示例：&quot;&gt;&lt;a href=&quot;#示例：&quot; class=&quot;headerlink&quot; title=&quot;示例：&quot;&gt;&lt;/a&gt;示例：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n &amp;#x3D; 2.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定的 n 保证是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你能尝试使用一趟扫描实现吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31. 下一个排列</title>
    <link href="http://yoursite.com/2020/07/13/LeetCode-31/"/>
    <id>http://yoursite.com/2020/07/13/LeetCode-31/</id>
    <published>2020-07-13T13:36:58.000Z</published>
    <updated>2020-07-13T13:41:33.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode-31. 下一个排列"></a>LeetCode-31. 下一个排列</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3 → 1,3,2</code><br><code>3,2,1 → 1,2,3</code><br><code>1,1,5 → 1,5,1</code></p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>从后向前找到第一个比后边元素小的数（变化的位数越靠后，增长的变化越小）</li><li>该元素后边的数组都是单调递减的，因此我们从后向前遍历，找到第一个比该元素大的元素，并交换他们的位置（找到变化最少的下一位）</li><li>最后把后边的数组倒置（从小到大是最小的排列）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = len<span class="number">-1</span>;i != <span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &lt; nums[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i)&#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">for</span>(j = len - <span class="number">1</span>;j &gt; i;--j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i,j = len<span class="number">-1</span>;i &lt; j;++i,--j)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-31-下一个排列&quot;&gt;&lt;a href=&quot;#LeetCode-31-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-31. 下一个排列&quot;&gt;&lt;/a&gt;LeetCode-31. 下一个排列&lt;/h2&gt;&lt;p&gt;实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。&lt;/p&gt;
&lt;p&gt;如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。&lt;/p&gt;
&lt;p&gt;必须&lt;strong&gt;原地&lt;/strong&gt;修改，只允许使用额外常数空间。&lt;/p&gt;
&lt;p&gt;以下是一些例子，输入位于左侧列，其相应输出位于右侧列。&lt;br&gt;&lt;code&gt;1,2,3 → 1,3,2&lt;/code&gt;&lt;br&gt;&lt;code&gt;3,2,1 → 1,2,3&lt;/code&gt;&lt;br&gt;&lt;code&gt;1,1,5 → 1,5,1&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://yoursite.com/2020/07/13/LeetCode-34/"/>
    <id>http://yoursite.com/2020/07/13/LeetCode-34/</id>
    <published>2020-07-13T13:33:20.000Z</published>
    <updated>2020-07-13T13:36:23.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置"></a>LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>首先是常规的二分查找</li><li>其次在找到target值后，要判断是否还要继续查找（通过判断左边或者右边是否还有target值）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> target,<span class="keyword">bool</span> big)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>(),middle;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                high = middle;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                low = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(big)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(middle + <span class="number">1</span> &lt; high &amp;&amp; nums[middle+<span class="number">1</span>] == target)</span><br><span class="line">                        low = middle + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= low &amp;&amp; nums[middle<span class="number">-1</span>] == target)</span><br><span class="line">                        high = middle;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[low] == target)</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        ans[<span class="number">0</span>] = fun(nums,target,<span class="literal">false</span>);</span><br><span class="line">        ans[<span class="number">1</span>] = fun(nums,target,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;LeetCode-34. 在排序数组中查找元素的第一个和最后一个位置&lt;/h2&gt;&lt;p&gt;给定一个按照升序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/code&gt;。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;你的算法时间复杂度必须是 O(log n) 级别。&lt;/p&gt;
&lt;p&gt;如果数组中不存在目标值，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [5,7,7,8,8,10], target &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [5,7,7,8,8,10], target &amp;#x3D; 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [-1,-1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-152.乘积最大子数组</title>
    <link href="http://yoursite.com/2020/07/13/LeetCode-152/"/>
    <id>http://yoursite.com/2020/07/13/LeetCode-152/</id>
    <published>2020-07-13T13:29:38.000Z</published>
    <updated>2020-07-13T13:32:39.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-152-乘积最大子数组"><a href="#LeetCode-152-乘积最大子数组" class="headerlink" title="LeetCode-152.乘积最大子数组"></a>LeetCode-152.乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><ul><li>思想如同LeetCode-53题</li><li>但是要注意正值用最大值，负值用最小值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> tleft,fleft;</span><br><span class="line">        <span class="keyword">int</span> tright,fright;</span><br><span class="line">        <span class="keyword">int</span> tmiddle,fmiddle;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">Combine</span><span class="params">(Node &amp;a,Node &amp;b)</span></span>&#123;</span><br><span class="line">        Node ans;</span><br><span class="line">        <span class="keyword">int</span> n1,n2,n3,n4;</span><br><span class="line">        n1 = a.sum * b.tleft,n2 = a.sum * b.fleft;</span><br><span class="line">        ans.tleft = <span class="built_in">max</span>(a.tleft,<span class="built_in">max</span>(n1,n2));</span><br><span class="line">        ans.fleft = <span class="built_in">min</span>(a.fleft,<span class="built_in">min</span>(n1,n2));</span><br><span class="line">        n1 = a.tright * b.sum,n2 = a.fright * b.sum;</span><br><span class="line">        ans.tright = <span class="built_in">max</span>(b.tright,<span class="built_in">max</span>(n1,n2));</span><br><span class="line">        ans.fright = <span class="built_in">min</span>(b.fright,<span class="built_in">min</span>(n1,n2));</span><br><span class="line">        n1 = a.tright * b.tleft,n2 = a.tright * b.fleft,n3 = a.fright * b.tleft,n4 = a.fright * b.fleft;</span><br><span class="line">        ans.tmiddle = <span class="built_in">max</span>(a.tmiddle,<span class="built_in">max</span>(b.tmiddle,<span class="built_in">max</span>(n1,<span class="built_in">max</span>(n2,<span class="built_in">max</span>(n3,n4)))));</span><br><span class="line">        ans.fmiddle = <span class="built_in">min</span>(a.fmiddle,<span class="built_in">min</span>(b.fmiddle,<span class="built_in">min</span>(n1,<span class="built_in">min</span>(n2,<span class="built_in">min</span>(n3,n4)))));</span><br><span class="line">        ans.sum = a.sum * b.sum;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;nums[start],nums[start],nums[start],nums[start],nums[start],nums[start],nums[start]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = (start+<span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">        Node &amp;&amp;a = func(nums,start,middle);</span><br><span class="line">        Node &amp;&amp;b = func(nums,middle+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> Combine(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>思想如同LeetCode-53题</li><li>但是要注意正值用最大值，负值用最小值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Node &amp;&amp;ans = func(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans.tleft,<span class="built_in">max</span>(ans.fleft,<span class="built_in">max</span>(ans.tright,<span class="built_in">max</span>(ans.fright,<span class="built_in">max</span>(ans.tmiddle,<span class="built_in">max</span>(ans.fmiddle,ans.sum))))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;int&gt; T(len,0),F(len,0);</span><br><span class="line">        <span class="keyword">int</span> i,ans = nums[<span class="number">0</span>];</span><br><span class="line">        T[<span class="number">0</span>] = nums[<span class="number">0</span>] &gt; <span class="number">0</span> ? nums[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">0</span>] = nums[<span class="number">0</span>] &lt; <span class="number">0</span> ? nums[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            T[i] = <span class="built_in">max</span>(nums[i],<span class="built_in">max</span>(T[i<span class="number">-1</span>] * nums[i],F[i<span class="number">-1</span>] * nums[i]));</span><br><span class="line">            F[i] = <span class="built_in">min</span>(nums[i],<span class="built_in">min</span>(T[i<span class="number">-1</span>] * nums[i],F[i<span class="number">-1</span>] * nums[i]));</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,T[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-152-乘积最大子数组&quot;&gt;&lt;a href=&quot;#LeetCode-152-乘积最大子数组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-152.乘积最大子数组&quot;&gt;&lt;/a&gt;LeetCode-152.乘积最大子数组&lt;/h2&gt;&lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,3,-2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 子数组 [2,3] 有最大乘积 6。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [-2,0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-322.零钱兑换</title>
    <link href="http://yoursite.com/2020/07/11/LeetCode-322/"/>
    <id>http://yoursite.com/2020/07/11/LeetCode-322/</id>
    <published>2020-07-11T05:30:36.000Z</published>
    <updated>2020-07-11T06:08:04.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-322-零钱兑换"><a href="#LeetCode-322-零钱兑换" class="headerlink" title="LeetCode-322.零钱兑换"></a>LeetCode-322.零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以认为每种硬币的数量是无限的。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这其实是一个背包问题</li><li>对于任一数字<strong>i</strong>，都满足以下状态转移方程$f(i) = min(f(i-1)+1,f(i-2)+1,…,f(i-j)+1)其中i &gt;= j且j \in coins$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i,len = coins.<span class="built_in">size</span>();</span><br><span class="line">        count[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= amount;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - j &gt;= <span class="number">0</span> &amp;&amp; count[i-j] != INT_MAX)</span><br><span class="line">                    count[i] = <span class="built_in">min</span>(count[i], count[i-j] + <span class="number">1</span>);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[amount] != INT_MAX ? count[amount] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-322-零钱兑换&quot;&gt;&lt;a href=&quot;#LeetCode-322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-322.零钱兑换&quot;&gt;&lt;/a&gt;LeetCode-322.零钱兑换&lt;/h2&gt;&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins &amp;#x3D; [1, 2, 5], amount &amp;#x3D; 11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 11 &amp;#x3D; 5 + 5 + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: coins &amp;#x3D; [2], amount &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-240.搜索二维矩阵 II</title>
    <link href="http://yoursite.com/2020/07/09/LeetCode-240/"/>
    <id>http://yoursite.com/2020/07/09/LeetCode-240/</id>
    <published>2020-07-09T05:06:19.000Z</published>
    <updated>2020-07-09T05:13:06.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-240-搜索二维矩阵-II"><a href="#LeetCode-240-搜索二维矩阵-II" class="headerlink" title="LeetCode-240.搜索二维矩阵 II"></a>LeetCode-240.搜索二维矩阵 II</h2><p>写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li><p>每行的元素从左到右升序排列。</p></li><li><p>每列的元素从上到下升序排列。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>我们可以用分治的思想来解决这个问题</p></li><li><p>因为矩阵满足以下两个性质</p><ul><li><p>每行的元素从左到右升序排列。</p></li><li><p>每列的元素从上到下升序排列。</p></li></ul></li><li><p>所以从矩阵的左下角开始</p><ul><li>如果Target &gt; matrix[x][y]，则说明该行所有剩下的数都比Target大，因此我们应该比较上一行(—x)</li><li>如果Target &lt; matrix[x][y]，则说明该列所有剩下的数都比Target小，因此我们应该比较下一列(++y)</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.<span class="built_in">size</span>(),y = <span class="number">0</span>,col;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!col) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        --x;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &lt; col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &lt; target)&#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                --x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-240-搜索二维矩阵-II&quot;&gt;&lt;a href=&quot;#LeetCode-240-搜索二维矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-240.搜索二维矩阵 II&quot;&gt;&lt;/a&gt;LeetCode-240.搜索二维矩阵 II&lt;/h2&gt;&lt;p&gt;写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每行的元素从左到右升序排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每列的元素从上到下升序排列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;现有矩阵 matrix 如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,   4,  7, 11, 15],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,   5,  8, 12, 19],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,   6,  9, 16, 22],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [10, 13, 14, 17, 24],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [18, 21, 23, 26, 30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给定 target = &lt;code&gt;5&lt;/code&gt;，返回 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定 target = &lt;code&gt;20&lt;/code&gt;，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="分治算法" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-79.单词搜索</title>
    <link href="http://yoursite.com/2020/07/08/LeetCode-79/"/>
    <id>http://yoursite.com/2020/07/08/LeetCode-79/</id>
    <published>2020-07-08T05:38:34.000Z</published>
    <updated>2020-07-08T05:42:08.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-79-单词搜索"><a href="#LeetCode-79-单词搜索" class="headerlink" title="LeetCode-79.单词搜索"></a>LeetCode-79.单词搜索</h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word &#x3D; &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word &#x3D; &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li>1 &lt;= board.length &lt;= 200</li><li>1 &lt;= board[i].length &lt;= 200</li><li>1 &lt;= word.length &lt;= 10^3</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>在外层遍历board中的每个字符作为入口</li><li>在内层深度搜索，判断是否满足Word</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, x = board.<span class="built_in">size</span>(), y, loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">word</span>.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        y = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">use</span><span class="params">(x, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(y, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x &amp;&amp; !ans;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y &amp;&amp; !ans;++j)&#123;</span><br><span class="line">                ans = func(board, <span class="keyword">word</span>, use, i, j, loc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;use, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> loc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!use[x][y] &amp;&amp; board[x][y] == <span class="keyword">word</span>[loc])&#123;</span><br><span class="line">            use[x][y] = <span class="literal">true</span>;</span><br><span class="line">            loc += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(loc == <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ans &amp;&amp; x - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                ans |= func(board, <span class="keyword">word</span>, use, x<span class="number">-1</span>, y, loc);</span><br><span class="line">            <span class="keyword">if</span>(!ans &amp;&amp; x + <span class="number">1</span> &lt; board.<span class="built_in">size</span>())</span><br><span class="line">                ans |= func(board, <span class="keyword">word</span>, use, x+<span class="number">1</span>, y, loc);</span><br><span class="line">            <span class="keyword">if</span>(!ans &amp;&amp; y - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                ans |= func(board, <span class="keyword">word</span>, use, x, y<span class="number">-1</span>, loc);</span><br><span class="line">            <span class="keyword">if</span>(!ans &amp;&amp; y + <span class="number">1</span> &lt; board[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                ans |= func(board, <span class="keyword">word</span>, use, x, y+<span class="number">1</span>, loc);</span><br><span class="line">            use[x][y] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-79-单词搜索&quot;&gt;&lt;a href=&quot;#LeetCode-79-单词搜索&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-79.单词搜索&quot;&gt;&lt;/a&gt;LeetCode-79.单词搜索&lt;/h2&gt;&lt;p&gt;给定一个二维网格和一个单词，找出该单词是否存在于网格中。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;board &amp;#x3D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 word &amp;#x3D; &amp;quot;ABCCED&amp;quot;, 返回 true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 word &amp;#x3D; &amp;quot;SEE&amp;quot;, 返回 true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定 word &amp;#x3D; &amp;quot;ABCB&amp;quot;, 返回 false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;board 和 word 中只包含大写和小写英文字母。&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= board.length &amp;lt;= 200&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= board[i].length &amp;lt;= 200&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= word.length &amp;lt;= 10^3&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-56.合并区间</title>
    <link href="http://yoursite.com/2020/07/08/LeetCode-56/"/>
    <id>http://yoursite.com/2020/07/08/LeetCode-56/</id>
    <published>2020-07-08T01:44:21.000Z</published>
    <updated>2020-07-08T01:54:21.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-56-合并区间"><a href="#LeetCode-56-合并区间" class="headerlink" title="LeetCode-56.合并区间"></a>LeetCode-56.合并区间</h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>合并的规则是$num[i][1] &gt;= num[i+1][0]$，且$num[i][0] &lt;= num[i][1]$，所以应该先按$num[i][0]$从小到大排序。</li><li>如果出现了$num[i][0] == num[i+1][0]$的情况，我们就应该检查$num[i][1]和num[i+1][1]$之间的大小关系，因为$num[i][1]$越大，$num[i]$的范围越大，越能合并其他的$num[i]$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];       </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> i,len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.empty())&#123;</span><br><span class="line">                ans.push_back(intervals[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans.back()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                ans.back() = &#123;<span class="built_in">min</span>(ans.back()[<span class="number">0</span>],intervals[i][<span class="number">0</span>]),<span class="built_in">max</span>(ans.back()[<span class="number">1</span>],intervals[i][<span class="number">1</span>])&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-56-合并区间&quot;&gt;&lt;a href=&quot;#LeetCode-56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-56.合并区间&quot;&gt;&lt;/a&gt;LeetCode-56.合并区间&lt;/h2&gt;&lt;p&gt;给出一个区间的集合，请合并所有重叠的区间。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [[1,3],[2,6],[8,10],[15,18]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[1,6],[8,10],[15,18]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [[1,4],[4,5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [[1,5]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-494.目标和</title>
    <link href="http://yoursite.com/2020/07/06/LeetCode-494/"/>
    <id>http://yoursite.com/2020/07/06/LeetCode-494/</id>
    <published>2020-07-06T13:25:15.000Z</published>
    <updated>2020-07-08T01:54:55.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-494-目标和"><a href="#LeetCode-494-目标和" class="headerlink" title="LeetCode-494.目标和"></a>LeetCode-494.目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>因为数组的和不会超过1000，所以我们可以依此做动态规划（解空间远小于深度遍历的2^20）</li><li>状态转移方程为$f(i,j) = f(i-1,j-nums[i]) + f(i-1,j+nums[i])$,其中$f(i,j)$表示前<strong>i</strong>个数和为<strong>j</strong>的方法数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, sum = <span class="number">0</span>, len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i != len; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">2001</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">2001</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        a[<span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = -sum; j &lt;= sum; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    b[j + <span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &gt;= -sum)</span><br><span class="line">                        b[j + <span class="number">1000</span>] += a[j - nums[i - <span class="number">1</span>] + <span class="number">1000</span>];</span><br><span class="line">                    <span class="keyword">if</span>(j + nums[i - <span class="number">1</span>] &lt;= sum)</span><br><span class="line">                        b[j + <span class="number">1000</span>] += a[j + nums[i - <span class="number">1</span>] + <span class="number">1000</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    a[j + <span class="number">1000</span>] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &gt;= -sum)</span><br><span class="line">                        a[j + <span class="number">1000</span>] += b[j - nums[i - <span class="number">1</span>] + <span class="number">1000</span>];</span><br><span class="line">                    <span class="keyword">if</span>(j + nums[i - <span class="number">1</span>] &lt;= sum)</span><br><span class="line">                        a[j + <span class="number">1000</span>] += b[j + nums[i - <span class="number">1</span>] + <span class="number">1000</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> a[S + <span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">return</span> b[S + <span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-494-目标和&quot;&gt;&lt;a href=&quot;#LeetCode-494-目标和&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-494.目标和&quot;&gt;&lt;/a&gt;LeetCode-494.目标和&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt;。对于数组中的任意一个整数，你都可以从 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt;中选择一个符号添加在前面。&lt;/p&gt;
&lt;p&gt;返回可以使最终数组和为目标数 S 的所有添加符号的方法数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums: [1, 1, 1, 1, 1], S: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-1+1+1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1-1+1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1-1+1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1+1-1+1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+1+1+1+1-1 &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一共有5种方法让最终目标和为3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组非空，且长度不会超过 20 。&lt;/li&gt;
&lt;li&gt;初始的数组的和不会超过 1000 。&lt;/li&gt;
&lt;li&gt;保证返回的最终结果能被 32 位整数存下。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-560.和为K的子数组</title>
    <link href="http://yoursite.com/2020/07/04/LeetCode-560/"/>
    <id>http://yoursite.com/2020/07/04/LeetCode-560/</id>
    <published>2020-07-04T05:42:49.000Z</published>
    <updated>2020-07-04T06:12:06.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-560-和为K的子数组"><a href="#LeetCode-560-和为K的子数组" class="headerlink" title="LeetCode-560.和为K的子数组"></a>LeetCode-560.和为K的子数组</h2><p>给定一个整数数组和一个整数 <strong>k</strong>，你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h4><ul><li>对于数组中的每一个<strong>i</strong>，我们都在其后遍历每一个<strong>j</strong>，计算<strong>nums[i..j]</strong>的和是否为<strong>k</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,count = <span class="number">0</span>,sum,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = i;j != len;++j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><ul><li>因为<strong>nums[i..j]</strong>可以用前缀和<strong>nums[0..j]</strong> - 前缀和<strong>nums[0..i]</strong>来表示，所以我们可以使用<strong>Hash</strong>表来记录数组的前缀和，并在<strong>O(1)</strong>的时间里检索是否存在一个前缀和满足差为K</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; prim;</span><br><span class="line">        <span class="keyword">int</span> i,j,count = <span class="number">0</span>,len = nums.<span class="built_in">size</span>();</span><br><span class="line">        prim[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">        j += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(prim.count(j-k))</span><br><span class="line">                count += prim[j-k];</span><br><span class="line">            <span class="keyword">if</span>(!prim.count(j))</span><br><span class="line">                prim[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++prim[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-560-和为K的子数组&quot;&gt;&lt;a href=&quot;#LeetCode-560-和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-560.和为K的子数组&quot;&gt;&lt;/a&gt;LeetCode-560.和为K的子数组&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k&lt;/strong&gt;，你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数组的个数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:nums &amp;#x3D; [1,1,1], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组的长度为 [1, 20,000]。&lt;/li&gt;
&lt;li&gt;数组中元素的范围是 [-1000, 1000] ，且整数 &lt;strong&gt;k&lt;/strong&gt; 的范围是 [-1e7, 1e7]。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-438.找到字符串中所有字母异位词</title>
    <link href="http://yoursite.com/2020/07/04/LeetCode-438/"/>
    <id>http://yoursite.com/2020/07/04/LeetCode-438/</id>
    <published>2020-07-04T05:31:22.000Z</published>
    <updated>2020-07-04T05:41:53.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-438-找到字符串中所有字母异位词"><a href="#LeetCode-438-找到字符串中所有字母异位词" class="headerlink" title="LeetCode-438.找到字符串中所有字母异位词"></a>LeetCode-438.找到字符串中所有字母异位词</h2><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>字母异位词我们可以抽象成，固定字母出现次数的固定长度片段。</li><li>那么我们只需要构建一个滑动窗口，统计这个窗口内出现的字母次数是否一致即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lens = s.length(), lenp = p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(lenp &gt; lens)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : p)&#123;</span><br><span class="line">            ++count[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= lens;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; lenp)&#123;</span><br><span class="line">                --count[s[i]-<span class="string">'a'</span>];    </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>;j != <span class="number">26</span>;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count[j])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">26</span>)</span><br><span class="line">                    ans.push_back(i-lenp);</span><br><span class="line">                <span class="keyword">if</span>(i &lt; lens)&#123;</span><br><span class="line">                    --count[s[i]-<span class="string">'a'</span>];</span><br><span class="line">                    ++count[s[i-lenp] - <span class="string">'a'</span>];   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-438-找到字符串中所有字母异位词&quot;&gt;&lt;a href=&quot;#LeetCode-438-找到字符串中所有字母异位词&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-438.找到字符串中所有字母异位词&quot;&gt;&lt;/a&gt;LeetCode-438.找到字符串中所有字母异位词&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;strong&gt;s&lt;/strong&gt; 和一个非空字符串 &lt;strong&gt;p&lt;/strong&gt;，找到 &lt;strong&gt;s&lt;/strong&gt; 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。&lt;/p&gt;
&lt;p&gt;字符串只包含小写英文字母，并且字符串 &lt;strong&gt;s&lt;/strong&gt; 和 &lt;strong&gt;p&lt;/strong&gt; 的长度都不超过 20100。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字母异位词指字母相同，但排列不同的字符串。&lt;/li&gt;
&lt;li&gt;不考虑答案输出的顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0, 6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;起始索引等于 0 的子串是 &amp;quot;cba&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;起始索引等于 6 的子串是 &amp;quot;bac&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0, 1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;起始索引等于 0 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;起始索引等于 1 的子串是 &amp;quot;ba&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;起始索引等于 2 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>科研论文Introduction引言部分的作用（转载）</title>
    <link href="http://yoursite.com/2020/07/03/Introduction/"/>
    <id>http://yoursite.com/2020/07/03/Introduction/</id>
    <published>2020-07-03T04:45:15.000Z</published>
    <updated>2020-07-04T13:19:37.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Introduction"><a href="#什么是Introduction" class="headerlink" title="什么是Introduction"></a>什么是Introduction</h2><p>「<strong>Introduction引言部分通过呈现研究课题所折射的研究理论来说服目标读者</strong>」<strong>。</strong> 引言部分不同于摘要Abstract）, 字数上没有严格的局限性，但是内容方面要求在对应的选题上更加<strong>精准和明确</strong>（be concise and to the point）。引言通常需要承接摘要部分提出的几个学术方向展开话题，从比较宽泛的学术背景铺垫<strong>逐渐过渡到论文的研究课题</strong>（narrow down to the research problem）。</p><p><strong>Tips：</strong>「<strong>Introduction引言部分通过呈现研究课题所折射的研究理论来说服目标读者</strong>」</p><h3 id="Why-An-Introduction-Is-Needed？"><a href="#Why-An-Introduction-Is-Needed？" class="headerlink" title="Why An Introduction Is Needed？"></a><strong>Why An Introduction Is Needed？</strong></h3><p><strong>「从文章的大结构来看Introduction提出了你的研究问题，这个问题的答案应该在文章的Discussion或者Conclusion部分呈现给读者，也就是在文章的首尾形成一个前后呼应的关系」</strong>。</p><h3 id="那Introduction引言部分是只有一个横空出世的研究问题吗？"><a href="#那Introduction引言部分是只有一个横空出世的研究问题吗？" class="headerlink" title="那Introduction引言部分是只有一个横空出世的研究问题吗？"></a><strong>那Introduction引言部分是只有一个横空出世的研究问题吗？</strong></h3><p><strong>显然不是！</strong>引言部分需要解答两个核心问题：</p><blockquote><p>1.研究空白是什么？为什么我们要填补这个研究空白？(更加接地气地表达就是， <strong>你要说服读者这个研究空白很重要值得我们费时费力去探究</strong>)</p><p>2.你的研究问题是什么？为什么你的研究问题可以填补这个研究空白？(更加接地气地表达就是，<strong>你要说服读者相信你的研究的确填补了这个领域的空白</strong>)</p></blockquote><p><strong>Tips：</strong>结合我的工作，我觉得这两个核心问题可以这么写：</p><ol><li>可视分析是金融、医学等领域的重要数据分析技术，随着近年来的流形学习兴起，越来越多的可视分析系统使用流形学习（非线性投影）技术。但由于非线性变换固有的复杂性，非线性投影的布局通常是难以解释的，而这也制约了分析人员对数据的深入分析（例如对流形结构的分析）。</li><li>本文的研究问题是解释非线性投影的布局。我们通常认为流形学习（非线性投影）具有全局非线性，局部线性的特性，并且线性关系通常要比非线性关系更容易理解。因此我们使用非线性投影的线性近似来解释非线性投影的布局，但是全局的线性近似往往会和原始投影有较大的差异。为了克服这个挑战，我们基于多目标优化策略将非线性投影划分成多个近线性的片段，从而生成局部的线性近似来解释非线性投影的布局。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Introduction&quot;&gt;&lt;a href=&quot;#什么是Introduction&quot; class=&quot;headerlink&quot; title=&quot;什么是Introduction&quot;&gt;&lt;/a&gt;什么是Introduction&lt;/h2&gt;&lt;p&gt;「&lt;strong&gt;Introduct
      
    
    </summary>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Introduction" scheme="http://yoursite.com/tags/Introduction/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-139.单词拆分</title>
    <link href="http://yoursite.com/2020/07/02/LeetCode-139/"/>
    <id>http://yoursite.com/2020/07/02/LeetCode-139/</id>
    <published>2020-07-02T14:05:04.000Z</published>
    <updated>2020-07-02T14:17:51.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode-139.单词拆分"></a>LeetCode-139.单词拆分</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ol><li>我们定义$dp[i]$表示字符串$s$前$i$个字符组成的字符串$s[0..i-1]$是否能被拆分成若干个字典中出现的单词。</li><li><p>那么状态转移方程为$dp[i] = dp[j] \&amp;\&amp; check(s[j..i-1])$，其中$check(s[j..i-1])$表示字符串$s[0..i-1]$是否为字典中的一个单词</p></li><li><p>我们可以用Set作为字典的容器</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordDict)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">m_set</span><span class="params">(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(len + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i != len + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j != i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[j])&#123;</span><br><span class="line">                    ans[i] = m_set.count(s.substr(j, i - j)) &gt; <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ans[i])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="前缀树Trim"><a href="#前缀树Trim" class="headerlink" title="前缀树Trim"></a>前缀树Trim</h4><ul><li>原理和动态规划一致，区别体现在我们使用前缀树作为字典的容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">word</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, Node&gt; m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteNode</span><span class="params">(Node &amp;n, <span class="built_in">string</span> &amp;str)</span></span>&#123;</span><br><span class="line">        Node *node = &amp;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;m.count(c))</span><br><span class="line">                node-&gt;m[c] = &#123;<span class="literal">false</span>, <span class="built_in">map</span>&lt;<span class="keyword">char</span>, Node&gt;()&#125;;</span><br><span class="line">            node = &amp;(node-&gt;m[c]);</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;<span class="keyword">word</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReadNode</span><span class="params">(Node &amp;now, <span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        Node *node = &amp;now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;m.count(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = &amp;(node-&gt;m[c]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;<span class="keyword">word</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;wordDict)</span></span>&#123;</span><br><span class="line">        Node n = &#123;<span class="literal">false</span>, <span class="built_in">map</span>&lt;<span class="keyword">char</span>, Node&gt;()&#125;;</span><br><span class="line">        <span class="built_in">string</span> ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : wordDict)&#123;</span><br><span class="line">            ss = str;</span><br><span class="line">            <span class="keyword">if</span> (ss != <span class="string">""</span>)</span><br><span class="line">                WriteNode(n, ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i, j, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(len + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i != len + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j != i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[j])&#123;</span><br><span class="line">                    ans[i] = ReadNode(n, s.substr(j, i - j));</span><br><span class="line">                    <span class="keyword">if</span> (ans[i])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-139-单词拆分&quot;&gt;&lt;a href=&quot;#LeetCode-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-139.单词拆分&quot;&gt;&lt;/a&gt;LeetCode-139.单词拆分&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拆分时可以重复使用字典中的单词。&lt;/li&gt;
&lt;li&gt;你可以假设字典中没有重复的单词。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;leetcode&amp;quot;, wordDict &amp;#x3D; [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 返回 true 因为 &amp;quot;leetcode&amp;quot; 可以被拆分成 &amp;quot;leet code&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;applepenapple&amp;quot;, wordDict &amp;#x3D; [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 返回 true 因为 &amp;quot;applepenapple&amp;quot; 可以被拆分成 &amp;quot;apple pen apple&amp;quot;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     注意你可以重复使用字典中的单词。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s &amp;#x3D; &amp;quot;catsandog&amp;quot;, wordDict &amp;#x3D; [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="前缀树" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-416.分割等和子集</title>
    <link href="http://yoursite.com/2020/07/01/LeetCode-416/"/>
    <id>http://yoursite.com/2020/07/01/LeetCode-416/</id>
    <published>2020-07-01T12:31:12.000Z</published>
    <updated>2020-07-01T12:42:59.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-416-分割等和子集"><a href="#LeetCode-416-分割等和子集" class="headerlink" title="LeetCode-416.分割等和子集"></a>LeetCode-416.分割等和子集</h2><p>给定一个<strong>只包含正整数</strong>的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br><span class="line"></span><br><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们可以用动态规划的思想解决这个问题，我们可以把这个问题当成0-1背包问题的抽象</li><li>首先是要判断数组元素和是否为偶数，如果为奇数直接返回False</li><li>然后，我们用$f(i,j)$表示前$i$个数的子集的和是否可以为$j$</li><li>那么状态转移方程为$f(i,j) = f(i-1,j) || f(i-1,j-nums[i])$<ol><li>如果不用第$i$个数，只有前$i-1$个数的子集和可以为$j$时才为真</li><li>如果用第$i$个数，只有判断前$i-1$个数的子集和可以为$j-nums[i]$时才为真</li></ol></li><li>我们可以压缩状态表，因为计算$f(i,j)$只需要用到$f(i-1,j)$和$f(i-1,j-nums[i])$，而$j$从大到小遍历就不需要保存前置状态了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,len = nums.<span class="built_in">size</span>(),i,j;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : nums)</span><br><span class="line">            sum += tmp;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(sum+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = sum;j != <span class="number">0</span>;--j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                    ans[j] = ans[j] || ans[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-416-分割等和子集&quot;&gt;&lt;a href=&quot;#LeetCode-416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-416.分割等和子集&quot;&gt;&lt;/a&gt;LeetCode-416.分割等和子集&lt;/h2&gt;&lt;p&gt;给定一个&lt;strong&gt;只包含正整数&lt;/strong&gt;的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个数组中的元素不会超过 100&lt;/li&gt;
&lt;li&gt;数组的大小不会超过 200&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1, 5, 11, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 数组可以分割成 [1, 5, 5] 和 [11].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1, 2, 3, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 数组不能分割成两个元素和相等的子集.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-200.岛屿数量</title>
    <link href="http://yoursite.com/2020/06/30/LeetCode-200/"/>
    <id>http://yoursite.com/2020/06/30/LeetCode-200/</id>
    <published>2020-06-30T14:16:47.000Z</published>
    <updated>2020-06-30T14:28:32.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode-200.岛屿数量"></a>LeetCode-200.岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="广度搜索"><a href="#广度搜索" class="headerlink" title="广度搜索"></a>广度搜索</h4><ul><li>我们从上到下，从左到右遍历输入的矩阵<ul><li>当我们遍历到’1’时，把其置为’0’，并把它的位置加入到一个队列中，同时计数器time++<ul><li>当队列不为空时，每次都从队列中取出一个位置，遍历这个位置的上，下，左，右是否为’1’。如果为’1’，则把其置’0’，并且把该位置加入到队列中</li><li>当队列为空时，继续遍历输入的矩阵</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp,tmp2;</span><br><span class="line">        <span class="keyword">int</span> i,j,x = grid.<span class="built_in">size</span>(),y;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    tmp.first = i,tmp.second = j;</span><br><span class="line">                    grid[tmp.first][tmp.second] = <span class="string">'0'</span>;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        tmp = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        tmp2.first = tmp.first - <span class="number">1</span>, tmp2.second = tmp.second;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.first &gt;= <span class="number">0</span> &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first + <span class="number">1</span>, tmp2.second = tmp.second;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.first &lt; x &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first, tmp2.second = tmp.second - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.second &gt;= <span class="number">0</span> &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first, tmp2.second = tmp.second + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.second &lt; y &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul><li>使用一个map存储位置之间的从属关系</li><li>使用GetRoot()函数找到某个位置的根节点</li><li>使用Combine(a,b)把b的根节点合并到a的根节点</li><li>遍历整个输入矩阵构建从属关系，最后用set记录有几个根节点即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; Parent; </span><br><span class="line"></span><br><span class="line">    pair&lt;int,int&gt; getRoot(pair&lt;int,int&gt; &amp;tmp)&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; parent = Parent[tmp];</span><br><span class="line">        <span class="keyword">while</span>(parent != Parent[parent])&#123;</span><br><span class="line">            Parent[tmp] = Parent[parent];</span><br><span class="line">            parent = Parent[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> aRoot = getRoot(a),bRoot = getRoot(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Parent[bRoot] = aRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,x = grid.<span class="built_in">size</span>(),y;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a,b;</span><br><span class="line">        <span class="keyword">if</span>(!x)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!y)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    Parent[a] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != x - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    b.first = i+<span class="number">1</span>, b.second = j;</span><br><span class="line">                    Combine(a,b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j != y - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    b.first = i, b.second = j+<span class="number">1</span>;</span><br><span class="line">                    Combine(a,b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    ans.insert(getRoot(a));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-200-岛屿数量&quot;&gt;&lt;a href=&quot;#LeetCode-200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-200.岛屿数量&quot;&gt;&lt;/a&gt;LeetCode-200.岛屿数量&lt;/h2&gt;&lt;p&gt;给你一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 每座岛屿只能由水平和&amp;#x2F;或竖直方向上相邻的陆地连接而成。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>SwissRoll数据ISOMAP投影解释</title>
    <link href="http://yoursite.com/2020/06/30/PaperExam-SwissRoll-2020-06-30/"/>
    <id>http://yoursite.com/2020/06/30/PaperExam-SwissRoll-2020-06-30/</id>
    <published>2020-06-30T12:50:09.000Z</published>
    <updated>2020-07-02T14:18:25.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SwissRoll数据ISOMAP投影解释"><a href="#SwissRoll数据ISOMAP投影解释" class="headerlink" title="SwissRoll数据ISOMAP投影解释"></a>SwissRoll数据ISOMAP投影解释</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li><p>SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形</p><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/SwissRoll.jpg" alt="img"></p></li></ul><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>解释SwissRoll数据的ISOMAP投影</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>把SwissRoll的ISOMAP投影划分成多个分片，观察这些分片间特征的变化趋势</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="SwissRoll数据ISOMAP投影（18个分片）"><a href="#SwissRoll数据ISOMAP投影（18个分片）" class="headerlink" title="SwissRoll数据ISOMAP投影（18个分片）"></a>SwissRoll数据ISOMAP投影（18个分片）</h4><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/image-20200630205638498.png" alt="image-20200630205638498" style="zoom:80%;"></p><h4 id="分片特征相关性系数（绝对值）河流图"><a href="#分片特征相关性系数（绝对值）河流图" class="headerlink" title="分片特征相关性系数（绝对值）河流图"></a>分片特征相关性系数（绝对值）河流图</h4><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/image-20200630205934533.png" alt="image-20200630205934533"></p><ul><li>其中绿色代表的是原始空间中z轴的相关性，浅蓝色代表的是原始空间中的y轴的相关性，蓝色代表的是原始空间中x轴的相关性</li></ul><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验，我们观察到：<ul><li>SwissRoll的ISOMAP投影空间$(u,v)$和原始空间中$(x,y,z)$的关系如下：<ul><li>$u = f(x,y)$：<ul><li>其中$x$和$y$的相关性系数（绝对值）上呈现出负相关性，$x$增大$y$就减小，反之$x$减小$y$就增大</li><li>$x$和$y$的相关性系数（绝对值）的变化趋势为（$x$增长（$y$减小），$x$减小（$y$增长））不断重复</li></ul></li><li>$v = f(z)$，投影空间中的$v$和原始空间中的$z$一一对应</li></ul></li></ul></li><li>因此我们得到了以下结论：<ul><li>SwissRoll从一个扭曲的曲面展开成一个二维的平面的过程，本质上是原始空间中$(x,y)$投影到投影空间中$u$的过程。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;a href=&quot;#SwissRoll数据ISOMAP投影解释&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;/a&gt;SwissRoll数据ISOMAP投影解释&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/30/PaperExam-SwissRoll-2020-06-30/SwissRoll.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释SwissRoll数据的ISOMAP投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把SwissRoll的ISOMAP投影划分成多个分片，观察这些分片间特征的变化趋势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="SwissRoll" scheme="http://yoursite.com/tags/SwissRoll/"/>
    
      <category term="ISOMAP" scheme="http://yoursite.com/tags/ISOMAP/"/>
    
  </entry>
  
</feed>
