<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-01T12:42:59.923Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-416.分割等和子集</title>
    <link href="http://yoursite.com/2020/07/01/LeetCode-416/"/>
    <id>http://yoursite.com/2020/07/01/LeetCode-416/</id>
    <published>2020-07-01T12:31:12.000Z</published>
    <updated>2020-07-01T12:42:59.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-416-分割等和子集"><a href="#LeetCode-416-分割等和子集" class="headerlink" title="LeetCode-416.分割等和子集"></a>LeetCode-416.分割等和子集</h2><p>给定一个<strong>只包含正整数</strong>的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><strong>注意:</strong></p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br><span class="line"></span><br><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们可以用动态规划的思想解决这个问题，我们可以把这个问题当成0-1背包问题的抽象</li><li>首先是要判断数组元素和是否为偶数，如果为奇数直接返回False</li><li>然后，我们用$f(i,j)$表示前$i$个数的子集的和是否可以为$j$</li><li>那么状态转移方程为$f(i,j) = f(i-1,j) || f(i-1,j-nums[i])$<ol><li>如果不用第$i$个数，只有前$i-1$个数的子集和可以为$j$时才为真</li><li>如果用第$i$个数，只有判断前$i-1$个数的子集和可以为$j-nums[i]$时才为真</li></ol></li><li>我们可以压缩状态表，因为计算$f(i,j)$只需要用到$f(i-1,j)$和$f(i-1,j-nums[i])$，而$j$从大到小遍历就不需要保存前置状态了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,len = nums.<span class="built_in">size</span>(),i,j;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : nums)</span><br><span class="line">            sum += tmp;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(sum+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = sum;j != <span class="number">0</span>;--j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                    ans[j] = ans[j] || ans[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-416-分割等和子集&quot;&gt;&lt;a href=&quot;#LeetCode-416-分割等和子集&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-416.分割等和子集&quot;&gt;&lt;/a&gt;LeetCode-416.分割等和子集&lt;/h2&gt;&lt;p&gt;给定一个&lt;strong&gt;只包含正整数&lt;/strong&gt;的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个数组中的元素不会超过 100&lt;/li&gt;
&lt;li&gt;数组的大小不会超过 200&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1, 5, 11, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 数组可以分割成 [1, 5, 5] 和 [11].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [1, 2, 3, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 数组不能分割成两个元素和相等的子集.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-200.岛屿数量</title>
    <link href="http://yoursite.com/2020/06/30/LeetCode-200/"/>
    <id>http://yoursite.com/2020/06/30/LeetCode-200/</id>
    <published>2020-06-30T14:16:47.000Z</published>
    <updated>2020-06-30T14:28:32.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode-200.岛屿数量"></a>LeetCode-200.岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="广度搜索"><a href="#广度搜索" class="headerlink" title="广度搜索"></a>广度搜索</h4><ul><li>我们从上到下，从左到右遍历输入的矩阵<ul><li>当我们遍历到’1’时，把其置为’0’，并把它的位置加入到一个队列中，同时计数器time++<ul><li>当队列不为空时，每次都从队列中取出一个位置，遍历这个位置的上，下，左，右是否为’1’。如果为’1’，则把其置’0’，并且把该位置加入到队列中</li><li>当队列为空时，继续遍历输入的矩阵</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp,tmp2;</span><br><span class="line">        <span class="keyword">int</span> i,j,x = grid.<span class="built_in">size</span>(),y;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    tmp.first = i,tmp.second = j;</span><br><span class="line">                    grid[tmp.first][tmp.second] = <span class="string">'0'</span>;</span><br><span class="line">                    q.push(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                        tmp = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        tmp2.first = tmp.first - <span class="number">1</span>, tmp2.second = tmp.second;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.first &gt;= <span class="number">0</span> &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first + <span class="number">1</span>, tmp2.second = tmp.second;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.first &lt; x &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first, tmp2.second = tmp.second - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.second &gt;= <span class="number">0</span> &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp2.first = tmp.first, tmp2.second = tmp.second + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(tmp2.second &lt; y &amp;&amp; grid[tmp2.first][tmp2.second] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            q.push(tmp2);</span><br><span class="line">                            grid[tmp2.first][tmp2.second] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul><li>使用一个map存储位置之间的从属关系</li><li>使用GetRoot()函数找到某个位置的根节点</li><li>使用Combine(a,b)把b的根节点合并到a的根节点</li><li>遍历整个输入矩阵构建从属关系，最后用set记录有几个根节点即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; Parent; </span><br><span class="line"></span><br><span class="line">    pair&lt;int,int&gt; getRoot(pair&lt;int,int&gt; &amp;tmp)&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; parent = Parent[tmp];</span><br><span class="line">        <span class="keyword">while</span>(parent != Parent[parent])&#123;</span><br><span class="line">            Parent[tmp] = Parent[parent];</span><br><span class="line">            parent = Parent[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> aRoot = getRoot(a),bRoot = getRoot(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Parent[bRoot] = aRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,x = grid.<span class="built_in">size</span>(),y;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a,b;</span><br><span class="line">        <span class="keyword">if</span>(!x)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        y = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!y)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    Parent[a] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i != x - <span class="number">1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    b.first = i+<span class="number">1</span>, b.second = j;</span><br><span class="line">                    Combine(a,b);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j != y - <span class="number">1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    b.first = i, b.second = j+<span class="number">1</span>;</span><br><span class="line">                    Combine(a,b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != x;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j != y;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    a.first = i,a.second = j;</span><br><span class="line">                    ans.insert(getRoot(a));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-200-岛屿数量&quot;&gt;&lt;a href=&quot;#LeetCode-200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-200.岛屿数量&quot;&gt;&lt;/a&gt;LeetCode-200.岛屿数量&lt;/h2&gt;&lt;p&gt;给你一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 每座岛屿只能由水平和&amp;#x2F;或竖直方向上相邻的陆地连接而成。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>SwissRoll数据ISOMAP投影解释</title>
    <link href="http://yoursite.com/2020/06/30/PaperExam-SwissRoll-2020-06-30/"/>
    <id>http://yoursite.com/2020/06/30/PaperExam-SwissRoll-2020-06-30/</id>
    <published>2020-06-30T12:50:09.000Z</published>
    <updated>2020-06-30T14:30:17.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SwissRoll数据ISOMAP投影解释"><a href="#SwissRoll数据ISOMAP投影解释" class="headerlink" title="SwissRoll数据ISOMAP投影解释"></a>SwissRoll数据ISOMAP投影解释</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li><p>SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形</p><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/SwissRoll.jpg" alt="img"></p></li></ul><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>解释SwissRoll数据的ISOMAP投影</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>把SwissRoll的ISOMAP投影划分成多个分片，观察这些分片间特征的变化趋势</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="SwissRoll数据ISOMAP投影（18个分片）"><a href="#SwissRoll数据ISOMAP投影（18个分片）" class="headerlink" title="SwissRoll数据ISOMAP投影（18个分片）"></a>SwissRoll数据ISOMAP投影（18个分片）</h4><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/image-20200630205638498.png" alt="image-20200630205638498" style="zoom:80%;"></p><h4 id="分片特征相关性系数（绝对值）河流图"><a href="#分片特征相关性系数（绝对值）河流图" class="headerlink" title="分片特征相关性系数（绝对值）河流图"></a>分片特征相关性系数（绝对值）河流图</h4><p><img src="/2020/06/30/PaperExam-SwissRoll-2020-06-30/image-20200630205934533.png" alt="image-20200630205934533"></p><ul><li>其中绿色代表的是原始空间中z轴的相关性，浅蓝色代表的是原始空间中的y轴的相关性，蓝色代表的是原始空间中x轴的相关性</li></ul><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验，我们观察到：<ul><li>SwissRoll的ISOMAP投影空间$(u,v)$和原始空间中$(x,y,z)$的关系如下：<ul><li>$u = f(x,y)$：<ul><li>其中$x$和$y$的相关性系数（绝对值）上呈现出负相关性，$x$增大$y$就减小，反之$x$减小$y$就增大</li><li>$x$和$y$的相关性系数（绝对值）的变化趋势为（$x$增长（$y$减小），$x$减小（$y$增长））不断重复</li></ul></li><li>$v = f(z)$，投影空间中的$v$和原始空间中的$z$一一对应</li></ul></li></ul></li><li>因此我们得到了以下结论：<ul><li>SwissRoll从一个扭曲的曲面展开成一个二维的平面的过程，本质上是原始空间中$(x,y)$投影到投影空间中$u$的过程。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;a href=&quot;#SwissRoll数据ISOMAP投影解释&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;/a&gt;SwissRoll数据ISOMAP投影解释&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/30/PaperExam-SwissRoll-2020-06-30/SwissRoll.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释SwissRoll数据的ISOMAP投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把SwissRoll的ISOMAP投影划分成多个分片，观察这些分片间特征的变化趋势&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
      <category term="t-SNE" scheme="http://yoursite.com/tags/t-SNE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-146.LRU缓存机制</title>
    <link href="http://yoursite.com/2020/06/29/LeetCode-146/"/>
    <id>http://yoursite.com/2020/06/29/LeetCode-146/</id>
    <published>2020-06-29T14:07:32.000Z</published>
    <updated>2020-06-29T14:20:32.924Z</updated>
    
    <content type="html"><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个<code>LRU (最近最少使用) 缓存机制</code>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p><p>获取数据 <code>get(key)</code> - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p><strong>进阶:</strong></p><p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>使用List存储数据，这样插入删除数据的代价为<code>O(1)</code></li><li>使用Hash存储数据的Key，这样查找数据的代价为<code>O(1)</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator&gt; m;</span><br><span class="line">    <span class="keyword">int</span> m_capacity;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.count(key))&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = *m[key];</span><br><span class="line">            cache.erase(m[key]);</span><br><span class="line">            cache.push_back(tmp);</span><br><span class="line">            m[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">return</span> tmp.second;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.count(key))&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = *m[key];</span><br><span class="line">            cache.erase(m[key]);</span><br><span class="line">            tmp.second = value;</span><br><span class="line">            cache.push_back(tmp);</span><br><span class="line">            m[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cache.push_back(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(key,value));</span><br><span class="line">            m[key] = --cache.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">if</span>(cache.<span class="built_in">size</span>() &gt; m_capacity)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = cache.<span class="built_in">begin</span>();</span><br><span class="line">                m.erase(tmp-&gt;first);</span><br><span class="line">                cache.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运用你所掌握的数据结构，设计和实现一个&lt;code&gt;LRU (最近最少使用) 缓存机制&lt;/code&gt;。它应该支持以下操作： 获取数据 &lt;code&gt;get&lt;/code&gt; 和 写入数据 &lt;code&gt;put&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;获取数据 &lt;code&gt;get(key)&lt;/code&gt; - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。&lt;br&gt;写入数据 &lt;code&gt;put(key, value)&lt;/code&gt; - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你是否可以在 &lt;strong&gt;O(1)&lt;/strong&gt; 时间复杂度内完成这两种操作？&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LRUCache cache &amp;#x3D; new LRUCache( 2 &amp;#x2F;* 缓存容量 *&amp;#x2F; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.put(1, 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.put(2, 2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.get(1);       &amp;#x2F;&amp;#x2F; 返回  1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.put(3, 3);    &amp;#x2F;&amp;#x2F; 该操作会使得关键字 2 作废&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.get(2);       &amp;#x2F;&amp;#x2F; 返回 -1 (未找到)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.put(4, 4);    &amp;#x2F;&amp;#x2F; 该操作会使得关键字 1 作废&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.get(1);       &amp;#x2F;&amp;#x2F; 返回 -1 (未找到)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.get(3);       &amp;#x2F;&amp;#x2F; 返回  3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.get(4);       &amp;#x2F;&amp;#x2F; 返回  4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>SwissRoll数据ISOMAP投影解释</title>
    <link href="http://yoursite.com/2020/06/28/PaperExam-SwissRoll-2020-06-28/"/>
    <id>http://yoursite.com/2020/06/28/PaperExam-SwissRoll-2020-06-28/</id>
    <published>2020-06-28T13:06:49.000Z</published>
    <updated>2020-06-30T12:51:28.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SwissRoll数据ISOMAP投影解释"><a href="#SwissRoll数据ISOMAP投影解释" class="headerlink" title="SwissRoll数据ISOMAP投影解释"></a>SwissRoll数据ISOMAP投影解释</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li><p>SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/SwissRoll.jpg" alt="img"></p></li></ul><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>解释SwissRoll数据的ISOMAP投影</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>对于投影中近线性分布的布局，我们的算法能否表达特征的方向和相关性</li><li>对于投影中非线性分布的布局，我们的分片算法能否将其划分成多个近线性的片段，并在每个近线性分片上描述特征的方向和相关性</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="近线性分布的布局（2号特征）"><a href="#近线性分布的布局（2号特征）" class="headerlink" title="近线性分布的布局（2号特征）"></a>近线性分布的布局（2号特征）</h4><ul><li><p>下图是2号特征的分布（热力图），通过热力图我们发现2号特征的分布是近线性的，呈现出一种从上到下逐渐增大的趋势。同时，我们算法给出的特征方向（红色的箭头）也和这个趋势一致。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628213043488.png" alt="image-20200628213043488" style="zoom:80%;"></p></li></ul><h4 id="非线性分布的布局（1号特征）"><a href="#非线性分布的布局（1号特征）" class="headerlink" title="非线性分布的布局（1号特征）"></a>非线性分布的布局（1号特征）</h4><ul><li><p>下图是1号特征的分布（热力图），通过热力图我们发现1号特征的分布是非线性的，从左到右一直在循环的增大减小。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628212200278.png" style="zoom:80%;"></p></li><li><p>为了更准确的解释非线性布局的特征，我们把这个投影划分成了四片近线性的分片（从左到右分别是,<strong>左一，左二，右二，右一</strong> ）</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628215605616.png" alt="image-20200628215605616" style="zoom:80%;"></p></li><li><p><strong>左一</strong>分片的1号特征的分布（热力图），该分片内1号特征从左到右逐渐增大。同时，我们算法给出的特征方向（红色的箭头）也和这个趋势一致。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628215842805.png" alt="image-20200628215842805" style="zoom:80%;"></p></li><li><p><strong>左二</strong>分片的1号特征的分布（热力图），该分片内1号特征从右到左逐渐增大。同时，我们算法给出的特征方向（红色的箭头）也和这个趋势一致。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628220156732.png" alt="image-20200628220156732" style="zoom:80%;"></p></li><li><p><strong>右二</strong>分片的1号特征的分布（热力图），该分片内1号特征从左到右逐渐增大。同时，我们算法给出的特征方向（红色的箭头）也和这个趋势一致。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628220320211.png" alt="image-20200628220320211" style="zoom:80%;"></p></li><li><p><strong>右一</strong>分片的1号特征的分布（热力图），该分片内1号特征从右到左逐渐增大。同时，我们算法给出的特征方向（红色的箭头）也和这个趋势一致。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/image-20200628220353826.png" alt="image-20200628220353826" style="zoom: 80%;"></p></li></ul><h4 id="SwissRoll流形的展开过程"><a href="#SwissRoll流形的展开过程" class="headerlink" title="SwissRoll流形的展开过程"></a>SwissRoll流形的展开过程</h4><ul><li><p>下图是3号特征的分布（热力图），通过热力图我们发现3号特征的分布类似于2号特征，也是从左到右一直在循环的增大减小。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/Users\Zhou\haowenzhou\source\_posts\PaperExam-SwissRoll-2020-06-28\image-20200628220952101.png" alt="image-20200628220952101" style="zoom:80%;"></p></li><li><p>结合1号特征和2号特征的分析可知，1号和3号特征只影响投影的左右布局，而2号特征只影响投影的上下布局。</p></li><li><p>再结合特征相关性柱状图，我们发现2号特征的相关性接近1（即在ISOMAP投影过程中，该特征被完整的保留）。因此我们可以得出一个结论，SwissRoll在ISOMAP投影中是通过1号特征和3号特征来展开流形的，而2号特征并不影响流形的展开。</p><p><img src="/2020/06/28/PaperExam-SwissRoll-2020-06-28/Users\Zhou\AppData\Roaming\Typora\typora-user-images\image-20200628221351362.png" alt="image-20200628221351362"></p></li></ul><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验：<ul><li>我们的算法能直接解释非线性投影中近线性分布的布局</li><li>对于非线性分布的布局，我们的算法可以将投影划分成多个近线性的片段，并在每个近线性的片段上解释非线性分布的布局</li><li>SwissRoll在ISOMAP投影中是通过1号特征和3号特征来展开流形的，而2号特征并不影响流形的展开。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;a href=&quot;#SwissRoll数据ISOMAP投影解释&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll数据ISOMAP投影解释&quot;&gt;&lt;/a&gt;SwissRoll数据ISOMAP投影解释&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SwissRoll数据是一个三维数据集，其中包含一个内嵌在三维空间中的二维平面流形&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/28/PaperExam-SwissRoll-2020-06-28/SwissRoll.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释SwissRoll数据的ISOMAP投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用ISOMAP将SwissRoll数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于投影中近线性分布的布局，我们的算法能否表达特征的方向和相关性&lt;/li&gt;
&lt;li&gt;对于投影中非线性分布的布局，我们的分片算法能否将其划分成多个近线性的片段，并在每个近线性分片上描述特征的方向和相关性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
      <category term="t-SNE" scheme="http://yoursite.com/tags/t-SNE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-621. 任务调度器</title>
    <link href="http://yoursite.com/2020/06/28/LeetCode-621/"/>
    <id>http://yoursite.com/2020/06/28/LeetCode-621/</id>
    <published>2020-06-28T12:59:21.000Z</published>
    <updated>2020-06-28T13:03:57.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-621-任务调度器"><a href="#LeetCode-621-任务调度器" class="headerlink" title="LeetCode-621. 任务调度器"></a>LeetCode-621. 任务调度器</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个<strong>相同种类</strong>的任务之间必须有长度为 <strong>n</strong> 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的<strong>最短时间</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ol><a id="more"></a><h3 id="解题思路-转载-之后找机会重做一遍"><a href="#解题思路-转载-之后找机会重做一遍" class="headerlink" title="解题思路(转载)(之后找机会重做一遍)"></a>解题思路(转载)(之后找机会重做一遍)</h3><ul><li>由于相同的任务之间必须有 n 的冷却时间，所以我们可以想到按照任务的数量来安排它们，即一种任务的出现次数越多，我们就越早地安排。例如有 5 种任务 A, B, C, D, E，且它们分别有 6, 1, 1, 1, 1 个时，假设冷却时间 n = 2，那么我们首先安排任务 A，随后在 2 单位的冷却时间里，我们安排任务 B, C，随后继续安排任务 A，再安排任务 D, E，以此类推。</li><li>因此我们得到了一种安排的方法：我们规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。我们可以使用逆向思维来证明：假设第 r 轮中某个任务在第 k 个执行，那么说明它在第 r 轮时为数量第 k 多的任务。在第 r 轮结束后，第 1 多到第 k 多的任务的数量都会减少 1，因此在第 r + 1 轮，这个任务最多也只能是数量第 k 多，因此它如果被执行，一定满足冷却时间的要求。</li><li>根据上面的安排方法，我们每一轮选择不超过 n + 1 个任务执行，直到所有的任务被执行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : tasks)&#123;</span><br><span class="line">            ++m[c-<span class="string">'A'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>,loc,i;</span><br><span class="line">        sort(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">while</span>(m[<span class="number">0</span>])&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!m[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">26</span> &amp;&amp; m[i])</span><br><span class="line">                    --m[i];</span><br><span class="line">                ++time;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-621-任务调度器&quot;&gt;&lt;a href=&quot;#LeetCode-621-任务调度器&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-621. 任务调度器&quot;&gt;&lt;/a&gt;LeetCode-621. 任务调度器&lt;/h2&gt;&lt;p&gt;给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。&lt;/p&gt;
&lt;p&gt;然而，两个&lt;strong&gt;相同种类&lt;/strong&gt;的任务之间必须有长度为 &lt;strong&gt;n&lt;/strong&gt; 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。&lt;/p&gt;
&lt;p&gt;你需要计算完成所有任务所需要的&lt;strong&gt;最短时间&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：tasks &amp;#x3D; [&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;B&amp;quot;], n &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B -&amp;gt; (待命) -&amp;gt; A -&amp;gt; B.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     在本示例中，两个相同类型任务之间必须间隔长度为 n &amp;#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任务的总个数为 [1, 10000]。&lt;/li&gt;
&lt;li&gt;n 的取值范围为 [0, 100]。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>PaperExam-Boston-2020/06/27</title>
    <link href="http://yoursite.com/2020/06/27/PaperExam-Boston-2020-06-27/"/>
    <id>http://yoursite.com/2020/06/27/PaperExam-Boston-2020-06-27/</id>
    <published>2020-06-27T14:24:47.000Z</published>
    <updated>2020-06-27T14:24:47.615Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode-142. 环形链表 II</title>
    <link href="http://yoursite.com/2020/06/27/LeetCode-142/"/>
    <id>http://yoursite.com/2020/06/27/LeetCode-142/</id>
    <published>2020-06-27T06:37:05.000Z</published>
    <updated>2020-06-27T06:55:02.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-142-环形链表-II"><a href="#LeetCode-142-环形链表-II" class="headerlink" title="LeetCode-142. 环形链表 II"></a>LeetCode-142. 环形链表 II</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><img src="/2020/06/27/LeetCode-142/circularlinkedlist.png" alt="img"></p><p><strong>示例 ：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="/2020/06/27/LeetCode-142/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="/2020/06/27/LeetCode-142/circularlinkedlist_test3.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong>你是否可以不用额外空间解决此题？</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。</li></ul><p>算法流程：</p><ul><li>双指针第一次相遇： 设两指针 <code>fast</code>，<code>slow</code> 指向链表头部 <code>head</code>，<code>fast</code> 每轮走 2 步，<code>slow</code> 每轮走 1 步；<ul><li>第一种结果： <code>fast</code> 指针走过链表末端，说明链表无环，直接返回 <code>null</code>；（TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，<code>fast</code> 与 <code>slow</code> 的间距 +1，<code>fast</code> 终会追上 <code>slow</code>；）</li><li>第二种结果： 当<code>fast == slow</code>时， 两指针在环中 第一次相遇 。下面分析此时<code>fast</code> 与 <code>slow</code>走过的 步数关系 ：<ul><li>设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了 f，s 步，则有：<ul><li><code>fast</code> 走的步数是<code>slow</code>步数的 2 倍，即 f=2s；（解析： <code>fast</code> 每轮走 2 步）</li><li><code>fast</code> 比 <code>slow</code>多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 <code>fast</code> 比 <code>slow</code> 多走 环的长度整数倍 ）；</li><li>以上两式相减得：f=2nb，s=nb，即<code>fast</code>和<code>slow</code> 指针分别走了 2n，n 个环的周长 （注意： n 是未知数，不同链表的情况不同）。</li></ul></li></ul></li></ul></li><li>目前情况分析：<ul><li>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li><li>而目前，<code>slow</code> 指针走过的步数为 nb 步。因此，我们只要想办法让 <code>slow</code> 再走 a 步停下来，就可以到环的入口。</li><li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和<code>slow</code> 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部<code>head</code>。</li></ul></li><li>双指针第二次相遇：<ul><li><code>slow</code>指针 位置不变 ，将<code>fast</code>指针重新 指向链表头部节点 ；<code>slow</code>和<code>fast</code>同时每轮向前走 1 步；(TIPS：此时 f=0，s=nb ；）</li><li>当 <code>fast</code> 指针走到 f=a 步时，<code>slow</code> 指针走到步s=a+nb，此时两指针重合，并同时指向链表环入口 。</li></ul></li><li>返回slow指针指向的节点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!fast || !slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-142-环形链表-II&quot;&gt;&lt;a href=&quot;#LeetCode-142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-142. 环形链表 II&quot;&gt;&lt;/a&gt;LeetCode-142. 环形链表 II&lt;/h2&gt;&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;不允许修改给定的链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/27/LeetCode-142/circularlinkedlist.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 ：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [3,2,0,-4], pos &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：tail connects to node index 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/27/LeetCode-142/circularlinkedlist_test2.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1,2], pos &amp;#x3D; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：tail connects to node index 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/27/LeetCode-142/circularlinkedlist_test3.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head &amp;#x3D; [1], pos &amp;#x3D; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：no cycle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中没有环。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;你是否可以不用额外空间解决此题？&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Boston房价数据t-SNE投影解释</title>
    <link href="http://yoursite.com/2020/06/26/PaperExam-Boston-2020-06-26/"/>
    <id>http://yoursite.com/2020/06/26/PaperExam-Boston-2020-06-26/</id>
    <published>2020-06-26T13:25:50.000Z</published>
    <updated>2020-06-26T14:55:33.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Boston房价数据t-SNE投影解释"><a href="#Boston房价数据t-SNE投影解释" class="headerlink" title="Boston房价数据t-SNE投影解释"></a>Boston房价数据t-SNE投影解释</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li>波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。</li></ul><div class="table-container"><table><thead><tr><th>No</th><th>属性</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>CRIM</td><td>Float</td><td>城镇人均犯罪率</td></tr><tr><td>2</td><td>ZN</td><td>Float</td><td>占地面积超过2.5万平方英尺的住宅用地比例</td></tr><tr><td>3</td><td>INDUS</td><td>Float</td><td>城镇非零售业务地区的比例</td></tr><tr><td>4</td><td>CHAS</td><td>Integer</td><td>查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)</td></tr><tr><td>5</td><td>NOX</td><td>Float</td><td>一氧化氮浓度（每1000万份）</td></tr><tr><td>6</td><td>RM</td><td>Float</td><td>平均每居民房数</td></tr><tr><td>7</td><td>AGE</td><td>Float</td><td>在1940年之前建成的所有者占用单位的比例</td></tr><tr><td>8</td><td>DIS</td><td>Float</td><td>与五个波士顿就业中心的加权距离</td></tr><tr><td>9</td><td>RAD</td><td>Integer</td><td>辐射状公路的可达性指数</td></tr><tr><td>10</td><td>TAX</td><td>Float</td><td>每10,000美元的全额物业税率</td></tr><tr><td>11</td><td>PTRATIO</td><td>Float</td><td>城镇师生比例</td></tr><tr><td>12</td><td>B</td><td>Float</td><td>1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例</td></tr><tr><td>13</td><td>LSTAT</td><td>Float</td><td>人口中地位较低人群的百分数</td></tr><tr><td>14</td><td>MEDV</td><td>Float</td><td>（目标变量/类别属性）以1000美元计算的自有住房的中位数</td></tr></tbody></table></div><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>解释Boston房价数据的非线性投影</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>使用分片算法将投影分片，并从原始特征在投影上的方向和原始特征和投影的相关性两方面解释非线性投影的布局</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="分片数量为1时"><a href="#分片数量为1时" class="headerlink" title="分片数量为1时"></a>分片数量为1时</h4><ul><li><p>我们生成整个非线性投影的线性近似，该线性近似中9,10,12特征和投影之间具有较高的相关性</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626214332499.png" alt="image-20200626214332499"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图1-Boston-Div1010-特征相关性图</center> </li><li><p><strong>9号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内9号特征的值从左下到右上存在增长的趋势，并且和9号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626214902709.png" alt="image-20200626214902709"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图2-Boston-Div1010-9-非线性投影（星坐标，热力）图</center> </li><li><p><strong>10号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内110号特征的值从左到右存在增长的趋势，并且和10号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215126919.png" alt="image-20200626215126919"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图3-Boston-Div1010-10-非线性投影（星坐标，热力）图</center> <ul><li><p><strong>12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征的值从右下到左上存在增长的趋势，并且和12号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215400233.png" alt="image-20200626215400233"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图4-Boston-Div1010-12-非线性投影（星坐标，热力）图</center> <h4 id="分片数量为2时"><a href="#分片数量为2时" class="headerlink" title="分片数量为2时"></a>分片数量为2时</h4><ul><li><p>分片拓扑关系图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215656377.png" alt="image-20200626215656377"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图5-Boston-Div2-拓扑关系图</center> <ul><li><p>分片原始特征相关性河流图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626215955601.png" alt="image-20200626215955601"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图6-Boston-Div2-河流图</center> <ul><li><p>我们观察到1009和1008之间的12号特征相关性变化很大，我们对此进行深入分析</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626220442329.png" alt="image-20200626220442329"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图6-Boston-Div2-河流图</center> <ul><li><p><strong>1009分片的12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征值的分布没有明显的模式</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626220706588.png" alt="image-20200626220706588"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图7-Boston-Div1009-12-非线性投影（星坐标，热力）图</center> </li><li><p><strong>1008分片的12号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内12号特征的值从下到上存在增长的趋势，并且和12号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626221026553.png" alt="image-20200626221026553"></p></li></ul></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图8-Boston-Div1008-12-非线性投影（星坐标，热力）图</center> <h4 id="分片数量为3时"><a href="#分片数量为3时" class="headerlink" title="分片数量为3时"></a>分片数量为3时</h4><ul><li><p>分片拓扑关系图</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626221735990.png" alt="image-20200626221735990"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图9-Boston-Div3-拓扑关系图</center> </li><li><p>分片原始特征相关性河流图如下</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222126025.png" alt="image-20200626222126025"></p></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图10-Boston-Div3-河流图</center> <ul><li><p>我们观察到1009和（699,1004）之间的1号特征相关性变化很大，我们对此进行深入分析</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222330613.png" alt="image-20200626222330613"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图10-Boston-Div3-河流图</center> <ul><li><p><strong>1009分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征值的分布在整体上没有呈现出模式，仅在右下部分呈现出变化，因此相关性较低</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222512376.png" alt="image-20200626222512376"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图11-Boston-Div1009-1-非线性投影（星坐标，热力）图</center> </li><li><p><strong>699分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征的值从右到左存在增长的趋势，并且和1号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222652345.png" alt="image-20200626222652345"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图12-Boston-Div699-1-非线性投影（星坐标，热力）图</center> </li><li><p><strong>1004分片的1号特征</strong>在非线性投影中的方向以及在非线性投影中的热力分布如下，分片内1号特征的值从左下到右上存在增长的趋势，并且和1号特征的方向一致</p><p><img src="/2020/06/26/PaperExam-Boston-2020-06-26/image-20200626222759426.png" alt="image-20200626222759426"></p></li></ul></li></ul><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图13-Boston-Div1004-1-非线性投影（星坐标，热力）图</center> <h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验：<ul><li>我们的算法能从原始特征在非线性投影上的方向和原始特征和非线性投影的相关性两方面解释非线性投影的布局</li><li>使用我们的分片算法将非线性投影划分成多个近线性的片段，能够更准确的解释非线性投影的布局</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Boston房价数据t-SNE投影解释&quot;&gt;&lt;a href=&quot;#Boston房价数据t-SNE投影解释&quot; class=&quot;headerlink&quot; title=&quot;Boston房价数据t-SNE投影解释&quot;&gt;&lt;/a&gt;Boston房价数据t-SNE投影解释&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;字段描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;CRIM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇人均犯罪率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ZN&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;占地面积超过2.5万平方英尺的住宅用地比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;INDUS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇非零售业务地区的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;CHAS&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;NOX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;一氧化氮浓度（每1000万份）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;RM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;平均每居民房数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;AGE&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;在1940年之前建成的所有者占用单位的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DIS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;与五个波士顿就业中心的加权距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;RAD&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;辐射状公路的可达性指数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;TAX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;每10,000美元的全额物业税率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;PTRATIO&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇师生比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;LSTAT&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;人口中地位较低人群的百分数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;MEDV&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;（目标变量/类别属性）以1000美元计算的自有住房的中位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;解释Boston房价数据的非线性投影&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用分片算法将投影分片，并从原始特征在投影上的方向和原始特征和投影的相关性两方面解释非线性投影的布局&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
      <category term="t-SNE" scheme="http://yoursite.com/tags/t-SNE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-207.课程表</title>
    <link href="http://yoursite.com/2020/06/26/LeetCode-207/"/>
    <id>http://yoursite.com/2020/06/26/LeetCode-207/</id>
    <published>2020-06-26T11:39:46.000Z</published>
    <updated>2020-06-26T11:49:51.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-207-课程表"><a href="#LeetCode-207-课程表" class="headerlink" title="LeetCode-207.课程表"></a>LeetCode-207.课程表</h2><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 0 到 <code>numCourse-1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br><span class="line"></span><br><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>输入的先决条件是由 <code>边缘列表</code> 表示的图形，而不是 <code>邻接矩阵</code> 。详情请参见<a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li><li>你可以假定输入的先决条件中没有重复的边。</li><li>1 &lt;= numCourses &lt;= 10^5</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>本题可约化为： 课程安排图是否是 <code>有向无环图(DAG)</code>。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p></li><li><p>思路是通过 <code>拓扑排序</code> 判断此课程安排图是否是 <code>有向无环图(DAG)</code> 。 拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</p></li><li><p>通过课程前置条件列表 <code>prerequisites</code> 可以得到课程安排图的 <code>邻接表 adjacency</code>，以降低算法时间复杂度。</p></li><li><p>算法流程:</p><ul><li>统计课程安排图中每个节点的入度，生成 入度表 <code>indegrees</code>。<br>借助一个队列 <code>queue</code>，将所有入度为 0 的节点入队。</li><li>当 <code>queue</code> 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：<ul><li>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 <code>indegrees[cur] -= 1</code>。</li><li>当入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。</li></ul></li><li>在每次 <code>pre</code> 出队时，执行 <code>numCourses--</code>；<ul><li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。</li><li>因此，拓扑排序出队次数等于课程个数，返回 <code>numCourses == 0</code> 判断课程是否可以成功安排。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">incount</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">connect</span><span class="params">(numCourses, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp : prerequisites)&#123;</span><br><span class="line">            ++incount[tmp[<span class="number">0</span>]];</span><br><span class="line">            <span class="built_in">connect</span>[tmp[<span class="number">1</span>]].insert(tmp[<span class="number">0</span>]);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i != numCourses;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!incount[i])</span><br><span class="line">                q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> num = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            --numCourses;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> loc : <span class="built_in">connect</span>[num])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!--incount[loc])&#123;</span><br><span class="line">                    q.push(loc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-207-课程表&quot;&gt;&lt;a href=&quot;#LeetCode-207-课程表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-207.课程表&quot;&gt;&lt;/a&gt;LeetCode-207.课程表&lt;/h2&gt;&lt;p&gt;你这个学期必须选修 &lt;code&gt;numCourse&lt;/code&gt; 门课程，记为 0 到 &lt;code&gt;numCourse-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：&lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入的先决条件是由 &lt;code&gt;边缘列表&lt;/code&gt; 表示的图形，而不是 &lt;code&gt;邻接矩阵&lt;/code&gt; 。详情请参见&lt;a href=&quot;https://blog.csdn.net/woaidapaopao/article/details/51732947&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图的表示法&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;你可以假定输入的先决条件中没有重复的边。&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= numCourses &amp;lt;= 10^5&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-394.字符串解码</title>
    <link href="http://yoursite.com/2020/06/25/LeetCode-394/"/>
    <id>http://yoursite.com/2020/06/25/LeetCode-394/</id>
    <published>2020-06-25T15:10:32.000Z</published>
    <updated>2020-06-25T15:23:40.953Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用递归的思想来完成这道题<ul><li>对于不重复的部分，我们把字符直接加入输出中</li><li>对于重复的部分，我们把重复部分的字符放入待处理字符串中，并递归处理待处理字符串</li><li>最后把递归返回结果加入输出中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>,substr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!count &amp;&amp; <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                k = k * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count)</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">if</span>(!count)&#123;</span><br><span class="line">                    substr = decodeString(substr);</span><br><span class="line">                    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">                        ans += substr;</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    substr.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count)&#123;</span><br><span class="line">                    substr.push_back(c);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans.push_back(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。&lt;/p&gt;
&lt;p&gt;编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。&lt;/p&gt;
&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。&lt;/p&gt;
&lt;p&gt;此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 &lt;code&gt;3a&lt;/code&gt; 或 &lt;code&gt;2[4]&lt;/code&gt; 的输入。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;3[a]2[bc]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;aaabcbc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;3[a2[c]]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;accaccacc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;2[abc]3[cd]ef&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;abcabccdcdcdef&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：s &amp;#x3D; &amp;quot;abc3[cd]xyz&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;abccdcdcdxyz&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-309.最佳买卖股票时机含冷冻期</title>
    <link href="http://yoursite.com/2020/06/23/LeetCode-309/"/>
    <id>http://yoursite.com/2020/06/23/LeetCode-309/</id>
    <published>2020-06-23T13:02:55.000Z</published>
    <updated>2020-06-23T13:48:01.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-309-最佳买卖股票时机含冷冻期"><a href="#LeetCode-309-最佳买卖股票时机含冷冻期" class="headerlink" title="LeetCode-309.最佳买卖股票时机含冷冻期"></a>LeetCode-309.最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>可以发现每天只有<strong>不持有股票</strong>和<strong>持有股票</strong>两种状态</li><li>因此我们可以得出以下状态转移方程：<ul><li>不持有股票：$Ans[i][0] = max(Ans[i-1][0],Ans[i-1][1] + prices[i])$</li><li>持有股票：$Ans[i][1] = max(Ans[i-2][0] - prices[i], ans[i-1[1]])$</li></ul></li><li>因为我们会用到$i-2$，所以我们要手工生成前两项</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, ans[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(ans[<span class="number">0</span>][<span class="number">0</span>], ans[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]), ans[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(ans[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>;i != len; ++i)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = <span class="built_in">max</span>(ans[i<span class="number">-1</span>][<span class="number">0</span>], ans[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            ans[i][<span class="number">1</span>] = <span class="built_in">max</span>(ans[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i], ans[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[len<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul><li><p>实际上持有股票（Hold），卖出股票（Sold），冷冻期（Rest）之间可以构成一个状态机</p><p><img src="/2020/06/23/LeetCode-309/143bca8f4230f2ac50a47ef57bf3ce0e78fc21fc47e21b4294b87429689fcfab-image.png" alt="image.png"></p></li><li><p>因此我们只需要在遍历股票列表时维护这个状态机，就可以得到最优解</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Hold[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,Rest[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,Sold[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Hold[<span class="number">0</span>] -= prices[<span class="number">0</span>], Sold[<span class="number">0</span>] = <span class="number">0</span>, Wait[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i)&#123;</span><br><span class="line">            Hold[<span class="number">1</span>] = <span class="built_in">max</span>(Rest[<span class="number">0</span>] - prices[i], Hold[<span class="number">0</span>]);</span><br><span class="line">            Wait[<span class="number">1</span>] = <span class="built_in">max</span>(Rest[<span class="number">0</span>], Sold[<span class="number">0</span>]);</span><br><span class="line">            Sold[<span class="number">1</span>] = Hold[<span class="number">0</span>] + prices[i]; </span><br><span class="line">            Hold[<span class="number">0</span>] = Hold[<span class="number">1</span>],Rest[<span class="number">0</span>] = Rest[<span class="number">1</span>],Sold[<span class="number">0</span>] = Sold[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Sold[<span class="number">0</span>],Rest[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-309-最佳买卖股票时机含冷冻期&quot;&gt;&lt;a href=&quot;#LeetCode-309-最佳买卖股票时机含冷冻期&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-309.最佳买卖股票时机含冷冻期&quot;&gt;&lt;/a&gt;LeetCode-309.最佳买卖股票时机含冷冻期&lt;/h2&gt;&lt;p&gt;给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。&lt;/p&gt;
&lt;p&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/li&gt;
&lt;li&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1,2,3,0,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态机" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-399.除法求值</title>
    <link href="http://yoursite.com/2020/06/22/LeetCode-399/"/>
    <id>http://yoursite.com/2020/06/22/LeetCode-399/</id>
    <published>2020-06-22T13:43:42.000Z</published>
    <updated>2020-06-22T13:57:35.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-399-除法求值"><a href="#LeetCode-399-除法求值" class="headerlink" title="LeetCode-399.除法求值"></a>LeetCode-399.除法求值</h2><p>给出方程式 <code>A / B = k</code>, 其中 <code>A</code>和 <code>B</code>均为用字符串表示的变量， <code>k</code>是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 <code>-1.0</code>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">问题: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ? </span><br><span class="line">返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure><p>输入为:<code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries</code>(方程式，方程式结果，问题方程式)， 其中<code>equations.size() == values.size()</code>，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回<code>vector&lt;double&gt;</code>类型。</p><p>基于上述例子，输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations(方程式) &#x3D; [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values(方程式结果) &#x3D; [2.0, 3.0],</span><br><span class="line">queries(问题方程式) &#x3D; [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure><p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>要计算两个变量之间的比值，我们需要解决两个问题：<ul><li>这两个变量之间是否存在关系？（我们可以每个变量看出图中的节点，除法看成节点之间的边，描述它们之间的关系）</li><li>如果这两个变量之间存在关系，怎么构建他们之间比值之间的联系？</li></ul></li><li>为了解决上述两个问题，我们可以使用并查集<ul><li>并查集可以非常快速的判断两个元素是否属于同一个连通分量（集合）</li><li>我们可以定制一个Root函数，在节点提升的过程中，建立节点和根节点之间的比值关系。（具体实现看代码）</li><li>因此，当a和b节点有共同根节点root时，a/b = a/root * root/b；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;,<span class="keyword">double</span>&gt; div;<span class="comment">//记录不同节点之间的比值</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; p;<span class="comment">//记录不同节点之间的从属关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求Child节点的根节点</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Root</span><span class="params">(<span class="built_in">string</span> &amp;Child)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p.count(Child))</span><br><span class="line">            <span class="keyword">return</span> Child;</span><br><span class="line">        <span class="built_in">string</span> Parent = p[Child];</span><br><span class="line">        <span class="comment">//节点提升</span></span><br><span class="line">        <span class="keyword">while</span>(p.count(Parent))&#123;</span><br><span class="line">            <span class="comment">//子节点和父节点以及父节点的父节点之间的关系</span></span><br><span class="line">            div[&#123;Child,p[Parent]&#125;] = div[&#123;Child,p[Child]&#125;] * div[&#123;p[Child],p[Parent]&#125;];</span><br><span class="line">            div[&#123;p[Parent],Child&#125;] = <span class="number">1.0</span> / div[&#123;Child,p[Parent]&#125;];</span><br><span class="line">            p[Child] = p[Parent];</span><br><span class="line">            Parent = p[Parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个连通分量（集合）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b, <span class="keyword">double</span> &amp;val)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ar = Root(a), br = Root(b);</span><br><span class="line">        p[br] = ar;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录新的连通分量的根节点的比值信息</span></span><br><span class="line">        div[&#123;a,a&#125;] = div[&#123;b,b&#125;] = <span class="number">1.0</span>;</span><br><span class="line">        div[&#123;a,b&#125;] = val,div[&#123;b,a&#125;] = <span class="number">1.0</span> / val;</span><br><span class="line">        div[&#123;ar,br&#125;] = div[&#123;ar,a&#125;] * div[&#123;a,b&#125;] * div[&#123;b,br&#125;];</span><br><span class="line">        div[&#123;br,ar&#125;] = <span class="number">1.0</span> / div[&#123;ar,br&#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当a和b节点有共同根节点root时，a/b = a/root * root/b；</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ar = Root(a), br = Root(b);</span><br><span class="line">        <span class="keyword">if</span>(ar == br &amp;&amp; div.count(&#123;ar,ar&#125;))&#123;<span class="comment">//这里的div.count(&#123;ar,ar&#125;)判断是为了解决计算节点不在输入节点的情况</span></span><br><span class="line">            <span class="keyword">return</span> div[&#123;a,ar&#125;] * div[&#123;ar,b&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,len = values.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            add(equations[i][<span class="number">0</span>], equations[i][<span class="number">1</span>], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        len = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">ans</span><span class="params">(len, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">            ans[i] = compute(queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-399-除法求值&quot;&gt;&lt;a href=&quot;#LeetCode-399-除法求值&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-399.除法求值&quot;&gt;&lt;/a&gt;LeetCode-399.除法求值&lt;/h2&gt;&lt;p&gt;给出方程式 &lt;code&gt;A / B = k&lt;/code&gt;, 其中 &lt;code&gt;A&lt;/code&gt;和 &lt;code&gt;B&lt;/code&gt;均为用字符串表示的变量， &lt;code&gt;k&lt;/code&gt;是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 &lt;code&gt;-1.0&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 a &amp;#x2F; b &amp;#x3D; 2.0, b &amp;#x2F; c &amp;#x3D; 3.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;问题: a &amp;#x2F; c &amp;#x3D; ?, b &amp;#x2F; a &amp;#x3D; ?, a &amp;#x2F; e &amp;#x3D; ?, a &amp;#x2F; a &amp;#x3D; ?, x &amp;#x2F; x &amp;#x3D; ? &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入为:&lt;code&gt;vector&amp;lt;pair&amp;lt;string, string&amp;gt;&amp;gt; equations, vector&amp;lt;double&amp;gt;&amp;amp; values, vector&amp;lt;pair&amp;lt;string, string&amp;gt;&amp;gt; queries&lt;/code&gt;(方程式，方程式结果，问题方程式)， 其中&lt;code&gt;equations.size() == values.size()&lt;/code&gt;，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回&lt;code&gt;vector&amp;lt;double&amp;gt;&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;基于上述例子，输入如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;equations(方程式) &amp;#x3D; [ [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] ],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values(方程式结果) &amp;#x3D; [2.0, 3.0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queries(问题方程式) &amp;#x3D; [ [&amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;x&amp;quot;, &amp;quot;x&amp;quot;] ].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="图" scheme="http://yoursite.com/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 1.Getting Started</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-1/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-1/</id>
    <published>2020-06-22T13:38:43.000Z</published>
    <updated>2020-06-22T13:42:22.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-1-Getting-Started"><a href="#Programming-in-Lua：Chapter-1-Getting-Started" class="headerlink" title="Programming in Lua：Chapter 1. Getting Started"></a>Programming in Lua：Chapter 1. Getting Started</h2><ul><li><p>Lua使用块（Chunks）作为代码执行的单位，一个Chunks可以是交互模式中的一行代码或者是一个函数</p></li><li><p>使用Chunks的方法：</p><ul><li>在交互模式中，可以使用<code>% lua -i prog​</code></li><li>或者可以使用dofile()导入别的lua文件</li></ul></li><li><p>Lua中的标识符可以是字母，数字和下划线开头，不能以数字开头</p></li><li><p>以下是Lua中的保留字，不能作为标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and      break     do        else      elseif</span><br><span class="line">end      false     for       function  goto</span><br><span class="line">if       in        local     nil       not</span><br><span class="line">or       repeat    return    then      true</span><br><span class="line">until    while</span><br></pre></td></tr></table></figure></li><li><p>注释的两种方式：</p><ul><li>以<code>--</code>开始的那一整行</li><li>以<code>--[[</code>开始直至<code>]]</code>或<code>--]]</code>结束的一整段</li></ul></li><li><p>Coding的语法喝JavaScript一致，即不需要强制添加分号，但是可以使用分号作为分隔符</p></li><li><p>全局变量不需要声明，访问未初始化的全局变量不会报错，会得到一个nil（null）值</p></li><li><p>声明但未初始化的变量和值为nil的变量存储在相同区域，不会被GC管理</p></li><li><p>Lua有8种基本类型：</p><ul><li>nil（空类型）：对全局变量分配nil使gc回收它的内存</li><li>boolean（true/false）:<ul><li>在Lua中任何值都可以表示条件，false和nil都视为false，其他值都视为true。</li><li><strong>注意数字0和空字符串也视为true！！！</strong></li><li>逻辑运算符：所有的值都会想条件控制一样被划分成true和false<ul><li>and（与操作）：如果第一个操作数为false，则返回第一个操作数，否则返回第二个操作数 （假如第一个操作数为假，那么我们返回这个操作数就可以判假，反之我们需要判断第二个操作数）</li><li>or（或操作） ：如果第一个操作数为true,  则返回第一个操作数，否则返回第二个操作数（假如第一个操作数为真，那么我们返回这个操作数就可以判真，反之我们需要判断第二个操作数）</li><li>not（非操作）：返回一个boolean值，这个值为操作数的boolean值取反</li><li>and 和 or都满足短路原则</li><li>赋默认值 x = x or y (假如x未定义，则会把默认值y赋给x)</li><li>三目运算符 a ? b : c == a and b or c （当且仅当b不为false时）</li></ul></li></ul></li><li>number (浮点数)</li><li>string （字符串）</li><li>userdata （用户数据 io.stdin）：允许将任意C数据结构存储在Lua中</li><li>function (函数)</li><li>table (数据表)</li><li>thread （线程）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-1-Getting-Started&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-1-Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Prog
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第一章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 3.Numbers</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-3/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-3/</id>
    <published>2020-06-22T13:38:37.000Z</published>
    <updated>2020-06-22T13:42:32.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-3-Numbers"><a href="#Programming-in-Lua：Chapter-3-Numbers" class="headerlink" title="Programming in Lua：Chapter 3. Numbers"></a>Programming in Lua：Chapter 3. Numbers</h2><ul><li><p>Number定义：</p><ul><li>在5.2版本之前，Lua使用双精度浮点格式表示Number</li><li>从5.3版本开始，使用64位整数（integer）和双精度浮点数（float）来表示Number</li><li>对于受限平台，可以把Lua 5.3编译成Small Lua，它可以使用32位整数和单精度浮点数</li></ul></li><li><p>Number比较：</p><ul><li>尽管具有浮点数和整数两种Number表示形式，但是它们的类型都是Number，且它们之间是可以相互转换的，例如1 == 1.0 —&gt; true</li><li>在需要区分整数和浮点数的场景，可以使用math.type()接口（整形返回integer，浮点数返回float）</li></ul></li><li><p>Number的十六进制：</p><ul><li>使用“0x”前缀来支持十六进制常量。并且支持浮点十六进制,十六进制的数保持了浮点值的所有精度，且转换速度比十进制快</li><li><p>可以使用string.format结合”%a”来表示十六进制的数</p><ul><li><p>> string.format(“%a”, 419)         —&gt; 0x1.a3p+8 </p></li><li><p>>  string.format(“%a”, 0.1)         —&gt; 0x1.999999999999ap-4</p></li></ul></li></ul></li><li><p>Number提供的算术运算：</p><ul><li>加法，减法，乘法，除法，取反，取模</li><li>整数除法: //，将结果向负无穷大舍入</li><li>幂运算：^</li></ul></li><li><p>Number的关系运算符：</p><ul><li>>  , &lt; , &gt;=, &lt;=</li><li>相等运算符: ==</li><li>不等云运算法: ~=</li></ul></li><li><p>Number的舍入函数：</p><ul><li>floor：趋向负无穷大舍入</li><li>ceil：趋向正无穷大舍入</li><li>modf：四舍五入</li></ul></li><li><p>Number的转换：</p><ul><li>整形 —》 浮点数：整形 + 0.0 就会转换成浮点数</li><li>浮点数 —》 整形： <ul><li>浮点数和 0 或运算就会转换成整形（只有在浮点数的值精确表示为整数的情况下才可以执行这种转换，即这个浮点数没有小数部分且它在整数范围之内）</li><li>math.tointeger（x），如果x不能转换成整数，返回nil</li></ul></li></ul></li><li><p>Number中的运算符优先级，从上到下（高 —》 低）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">unary operators (- # ~ not)</span><br><span class="line">* &#x2F; &#x2F;&#x2F; %</span><br><span class="line">+ -</span><br><span class="line">.. (concatentation)</span><br><span class="line">&lt;&lt; &gt;&gt; (bitwise shifts)</span><br><span class="line">&amp; (bitwise AND)</span><br><span class="line">~ (bitwise exclusive OR)</span><br><span class="line">| (bitwise OR)</span><br><span class="line">&lt; &gt; &lt;&#x3D; &gt;&#x3D; ~&#x3D; &#x3D;&#x3D;</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-3-Numbers&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-3-Numbers&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第三章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 4.Strings</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-4/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-4/</id>
    <published>2020-06-22T13:38:34.000Z</published>
    <updated>2020-06-22T13:41:04.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-4-Strings"><a href="#Programming-in-Lua：Chapter-4-Strings" class="headerlink" title="Programming in Lua：Chapter 4. Strings"></a>Programming in Lua：Chapter 4. Strings</h2><ul><li>Lua中的String是不可修改的</li><li>Lua中的String如同其他对象（table，function）一样由Lua的GC管理内存，因此我们不必担心字符串的分配和释放。</li><li>#string获取string的长度</li><li>我们可以使用串联运算符”..”来串联两个字符串（例如，”Result is “.. 3 —》 “Result is 3”），并且串联运算符不会修改已有的字符串，而是创建并返回新一个的字符串。</li><li>多行的字符串：<ul><li>“[[“和”]]”之间的多行文本会被认为是一个String</li><li>我们也可以使用”[==(=个数自定)[“和”]==]”来表示一个长字符串</li><li>换行使用“\z”</li></ul></li><li>Lua在运行时提供数字和字符串之间的自动转换，字符串数被认为是浮点数</li><li>使用tonumber显示的转换string：<ul><li>tonumber(num,jinzhi)，jinzhi可以是2~36之间的任何基数</li></ul></li><li>String 库函数：<ul><li>string.len(s) 等价与#s</li><li>string.rep(s, n) 重复字符串s，n次</li><li>string.lower(s)返回一个副本，其中的大写字母都变为小写字母</li><li>string.upper(s)返回一个副本，其中的消息字母都变为大写字母</li><li>string.sub(s，i，j)，返回s中的第i个字符到第j个字符之间（包括i，j）字符串的副本（我们也可以使用负索引，该索引从字符串的末尾开始计数）</li><li>string.char(nums,…)，它接受一个或多个整数输入，并且将每个整数转换为一个字符</li><li>string.byte(s，i)，它返回s中第i个字符的内部数字表示形式。</li><li>string.byte(s，i，j)，它返回s中第i个字符到第j个字符之间的内部数字表示形式（包括i，j）</li><li>string.format 使用规则和C中的Printf类似</li><li>string.find（stra，strb），返回strb字符串在stra中的起始和终止位置，如果不存在，则返回il</li><li>string.gsub(str，a，b)，将str中的a全部替换成b。返回两个值，第一个值是替换后生成的副本，第二个值是替换发生的次数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-4-Strings&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-4-Strings&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第四章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 6.Functions</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-6/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-6/</id>
    <published>2020-06-22T13:38:32.000Z</published>
    <updated>2020-06-22T13:59:15.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-6-Functions"><a href="#Programming-in-Lua：Chapter-6-Functions" class="headerlink" title="Programming in Lua：Chapter 6. Functions"></a>Programming in Lua：Chapter 6. Functions</h2><ul><li><p>o:foo(x) 表示调用对象o的foo函数</p></li><li><p>function 支持多个返回值，当调用位置是Table的末尾时，返回所有返回值，其他位置只返回第一个返回值，并丢弃其他的返回值</p></li><li><p>return function() 这种形式会返回所有的返回值</p></li><li><p>return (function()) 这种形式只会返回第一个返回值</p></li><li><p>function可以支持可变参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">        s = s + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">12</span>)) <span class="comment">--&gt; 54</span></span><br></pre></td></tr></table></figure></li><li><p>table.unpack()：获取一个列表，并且把列表中的所有元素作为结果返回</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unpack</span> <span class="params">(t, i, n)</span></span></span><br><span class="line">    i = i <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    n = n <span class="keyword">or</span> #t</span><br><span class="line">    <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> t[i], <span class="built_in">unpack</span>(t, i + <span class="number">1</span>, n)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>如果在function的尾部调用另一个function，那么这个函数调用的底层实现时goto（即不再保存当前函数的堆栈信息，也不会再返回当前函数的现场，所以尾调用不会出现程序栈溢出的问题）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这些都不是尾调用，因为需要处理g(x)返回的值，<span class="keyword">goto</span>是不会回来处理值的（没有保存堆栈信息），所以不能使用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> g(x) + <span class="number">1</span> <span class="comment">-- must do the addition</span></span><br><span class="line"><span class="keyword">return</span> x <span class="keyword">or</span> g(x) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line"><span class="keyword">return</span> (g(x)) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line">//这是尾调用，尽管参数是表达式，但是不需要返回来处理返回值，可以用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> x[i].foo(x[j] + a*b, i + j)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-6-Functions&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-6-Functions&quot; class=&quot;headerlink&quot; title=&quot;Programming in L
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第六章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 5.Tables</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-5/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-5/</id>
    <published>2020-06-22T13:38:20.000Z</published>
    <updated>2020-06-22T13:58:57.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-5-Tables"><a href="#Programming-in-Lua：Chapter-5-Tables" class="headerlink" title="Programming in Lua：Chapter 5. Tables"></a>Programming in Lua：Chapter 5. Tables</h2><ul><li><p>Lua中Table可以作为数组ArrayList，集合Set，记录Dict等数据结构的载体</p></li><li><p>Table的本质是一个Dict，其关键字可以使数字，字符串等任何Lua中的值（除了nil）</p></li><li><p>Lua中的Table本质上是一个对象，可以视为一个动态分配的对象，因此程序只能操纵它们的引用（或指针）</p></li><li><p>Lua永远不会再后台隐藏或创建新的Table</p></li><li><p>创建一个Table的最简单形式就是 “a = {}”  </p></li><li><p>Table的两种构造函数形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">polyline = &#123;</span><br><span class="line">    //列表形式</span><br><span class="line">    color=<span class="string">"blue"</span>,</span><br><span class="line">    thickness=<span class="number">2</span>,</span><br><span class="line">    npoints=<span class="number">4</span>,</span><br><span class="line">    //记录形式</span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[1]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[2]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">1</span>&#125;, <span class="comment">-- polyline[3]</span></span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">1</span>&#125; <span class="comment">-- polyline[4]</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们需要一个Array时，我们仅使用带有整数键的Table</p></li><li><p>当一个Array使用连续的整数键（1…n），且中间没有中断，那么这种结构被称为序列（sequence），可以使用#来获取sequence的长度</p></li><li><p>没有内容的字段和空字段没有区别，因此<code>a = {10, 20, 30, nil, nil}</code>的长度为3</p></li><li><p>我们可以使用pairs()遍历Table中的所有键值对，遍历顺序不是固定的（可以理解为C++中的 unordered_map<T1, t2>）</T1,></p></li><li><pre><code class="lang-lua">//这种判断包是否能使用的方法导入了6个表，效率很低zip = company and company.director and company.director.address and company.director.address.zipcode//这种判断包能否使用的方法导入了3个表，效率高zip = (((company or {}).director or {}).address or {}).zipcode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Table的内置函数：</span><br><span class="line"></span><br><span class="line">  * Table.insert(t,loc,data)：把data插入到表t的第i个位置上，并把后续元素向后迁移</span><br><span class="line"></span><br><span class="line">  * Table.insert(t, data)：把数据插入到表t的末尾</span><br><span class="line"></span><br><span class="line">  * Table.remove(t, loc)：把表t中第i个位置的数据返回并删除，最后把后续元素向前迁移</span><br><span class="line"></span><br><span class="line">  * Table.move(t, s, e ,p)：把表t中从第s个位置（包括s）到第e个位置（包括e）之间的元素位移到第t个位置</span><br></pre></td></tr></table></figure>  //要将元素插入Table的开头  table.move(a, 1, #a, 2)  a[1] = newElement  //删除Table开头的元素  table.move(a, 2, #a, 1)  a[#a] = nil</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-5-Tables&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-5-Tables&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：Cha
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第五章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75.颜色分类</title>
    <link href="http://yoursite.com/2020/06/21/LeetCode-75/"/>
    <id>http://yoursite.com/2020/06/21/LeetCode-75/</id>
    <published>2020-06-21T04:00:40.000Z</published>
    <updated>2020-06-21T04:33:21.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75.颜色分类"></a>LeetCode-75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用双指针来保存0的右边界和2的左边界</li><li>开头 —&gt; nums[i] 之间都是数字0</li><li>nums[i] —&gt; nums[j]（j是当前数字的位置）之间没有数字0和2</li><li>那么当num[k] —&gt; 结尾都是数字2</li><li>那么当 j == k时，开头 —&gt; nums[i] 都为0， num[i] —&gt; num[j]之间都为1，nums[j] —&gt; nums[k]之间都为2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(),k = len - <span class="number">1</span>;i &lt;= k;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">                nums[j++] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k--] = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-75-颜色分类&quot;&gt;&lt;a href=&quot;#LeetCode-75-颜色分类&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-75.颜色分类&quot;&gt;&lt;/a&gt;LeetCode-75.颜色分类&lt;/h2&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,0,2,1,1,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,0,1,1,2,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用计数排序的两趟扫描算法。&lt;br&gt;首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常数空间的一趟扫描算法吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-279.完全平方数</title>
    <link href="http://yoursite.com/2020/06/20/LeetCode-279/"/>
    <id>http://yoursite.com/2020/06/20/LeetCode-279/</id>
    <published>2020-06-20T14:26:46.000Z</published>
    <updated>2020-06-20T14:43:28.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279.完全平方数"></a>LeetCode-279.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>我们可以发现不同的数字之间的关系为$Num[i] = min(Num[i],Num[i - j^2] + 1)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(!m.count(n))</span><br><span class="line">        &#123;</span><br><span class="line">            m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!m.count(i))&#123;</span><br><span class="line">                    m[i] =  m[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">2</span>;j * j &lt;= i;++j)&#123;</span><br><span class="line">                        m[i] = <span class="built_in">min</span>(m[i], m[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心-BFS"><a href="#贪心-BFS" class="headerlink" title="贪心+BFS"></a>贪心+BFS</h4><ul><li>上面的方法每一个数字k我们都需要遍历$\sqrt k$次，总共就是$n * k$次</li><li>实际上我们之前的遍历过程就是一颗$\sqrt k$叉树，节点所在的层数表示使用数字的个数，节点的值表示剩下的值。</li><li>我们生成树时优先生成值较小的节点，并采用BFS搜索（从上到下，从左到右）。</li><li>当我们遍历到那个值为0的节点时，返回节点所在的层数即可，并且剩下的节点都不用遍历了，从而减少计算开销</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        i = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(i * i == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;n,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ++tmp.second;</span><br><span class="line">            k = tmp.first;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="built_in">sqrt</span>(k);j &gt; <span class="number">0</span>;--j)&#123;</span><br><span class="line">                tmp.first = k - j * j;</span><br><span class="line">                <span class="keyword">if</span>(tmp.first == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> tmp.second;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-279-完全平方数&quot;&gt;&lt;a href=&quot;#LeetCode-279-完全平方数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-279.完全平方数&quot;&gt;&lt;/a&gt;LeetCode-279.完全平方数&lt;/h2&gt;&lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 &lt;code&gt;1, 4, 9, 16, ...&lt;/code&gt;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 12 &amp;#x3D; 4 + 4 + 4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 13 &amp;#x3D; 4 + 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
</feed>
