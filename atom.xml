<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-18T07:37:38.435Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-1.两数之和</title>
    <link href="http://yoursite.com/2020/05/18/LeetCode-1/"/>
    <id>http://yoursite.com/2020/05/18/LeetCode-1/</id>
    <published>2020-05-18T07:33:38.000Z</published>
    <updated>2020-05-18T07:37:38.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode-1.两数之和"></a>LeetCode-1.两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>在建立HashTable的过程中，判断当前HashTable是否存在满足条件的元素</li><li>时间复杂度为O(n)，空间复杂度也为O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,j,len;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,len = nums.<span class="built_in">size</span>();i != len;++i)&#123;</span><br><span class="line">            j = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(j) != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                ans.push_back(m[j]);</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-1-两数之和&quot;&gt;&lt;a href=&quot;#LeetCode-1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-1.两数之和&quot;&gt;&lt;/a&gt;LeetCode-1.两数之和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定 nums &amp;#x3D; [2, 7, 11, 15], target &amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为 nums[0] + nums[1] &amp;#x3D; 2 + 7 &amp;#x3D; 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以返回 [0, 1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-70.爬楼梯</title>
    <link href="http://yoursite.com/2020/05/17/LeetCode-70/"/>
    <id>http://yoursite.com/2020/05/17/LeetCode-70/</id>
    <published>2020-05-17T08:41:35.000Z</published>
    <updated>2020-05-17T08:44:21.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode-70.爬楼梯"></a>LeetCode-70.爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为每次只能爬1或2个台阶，所以每一级台阶的上法 = 低一级台阶的上法 + 低两阶台阶的上法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,i;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span>(a = <span class="number">1</span>,b = <span class="number">2</span>,i = <span class="number">3</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LeetCode-70-爬楼梯&quot;&gt;&lt;a href=&quot;#LeetCode-70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-70.爬楼梯&quot;&gt;&lt;/a&gt;LeetCode-70.爬楼梯&lt;/h2&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-543.二叉树的直径</title>
    <link href="http://yoursite.com/2020/05/16/LeetCode-543/"/>
    <id>http://yoursite.com/2020/05/16/LeetCode-543/</id>
    <published>2020-05-16T05:01:16.000Z</published>
    <updated>2020-05-16T05:06:36.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-543-二叉树的直径"><a href="#LeetCode-543-二叉树的直径" class="headerlink" title="LeetCode-543.二叉树的直径"></a>LeetCode-543.二叉树的直径</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>对于每一个节点，最长路径可能横跨这个节点的左右子树，或者只是经过这个节点的左右子树中的一个</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        func(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode *root,<span class="keyword">int</span> &amp;ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = func(root-&gt;left,ans);</span><br><span class="line">        <span class="keyword">int</span> right = func(root-&gt;right,ans);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,left+right+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ans = max(left+right+1,ans);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul><li>这里max(ans,left+right+1)和max(left+right+1,ans)的时间开销不同，需要调研一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-543-二叉树的直径&quot;&gt;&lt;a href=&quot;#LeetCode-543-二叉树的直径&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-543.二叉树的直径&quot;&gt;&lt;/a&gt;LeetCode-543.二叉树的直径&lt;/h2&gt;&lt;p&gt;给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;p&gt;给定二叉树&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      1
     / \
    2   3
   / \     
  4   5    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。&lt;/p&gt;
&lt;p&gt;注意：两结点之间的路径长度是以它们之间边的数目表示。&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于每一个节点，最长路径可能横跨这个节点的左右子树，或者只是经过这个节点的左右子树中的一个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-101.对称二叉树</title>
    <link href="http://yoursite.com/2020/05/15/LeetCode-101/"/>
    <id>http://yoursite.com/2020/05/15/LeetCode-101/</id>
    <published>2020-05-15T07:06:24.000Z</published>
    <updated>2020-05-15T07:30:10.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode-101.对称二叉树"></a>LeetCode-101.对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>    1   / \  2   2   \   \   3    3</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><ul><li>若一棵树的左右子树镜像对称，则该树镜像对称</li><li>判断两棵树镜像对称的要求：<ul><li>两棵树的根节点的值相同</li><li>两颗树中任一颗树的左子树与另一棵树的右子树镜像对称</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> func(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(TreeNode *lchild, TreeNode* rchild)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!lchild || !rchild)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lchild &amp;&amp; !rchild) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lchild-&gt;val == rchild-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> func(lchild-&gt;left,rchild-&gt;right) &amp;&amp; func(lchild-&gt;right,rchild-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h4><ul><li>使用队列存储待遍历的节点，将根节点的左右子树压入队列</li><li>当队列为空时循环结束。<ul><li>每次提取两个结点并比较它们的值。</li><li>若树不对称（即从队列中取出两个不相等的连续结点），返回false</li><li>将两个结点的左右子结点按相反的顺序插入队列中。</li></ul></li><li>返回true</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> func2(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func2</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        TreeNode *left,*right;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            left = q.front(),q.pop();</span><br><span class="line">            right = q.front(),q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!left || !right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left != right)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(left-&gt;left),q.push(right-&gt;right);</span><br><span class="line">                q.push(right-&gt;left),q.push(left-&gt;right);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-101-对称二叉树&quot;&gt;&lt;a href=&quot;#LeetCode-101-对称二叉树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-101.对称二叉树&quot;&gt;&lt;/a&gt;LeetCode-101.对称二叉树&lt;/h2&gt;&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;h3 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h3&gt;&lt;p&gt;例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
 / \ / \
3  4 4  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1
   / \
  2   2
   \   \
   3    3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;进阶&quot;&gt;&lt;a href=&quot;#进阶&quot; class=&quot;headerlink&quot; title=&quot;进阶&quot;&gt;&lt;/a&gt;进阶&lt;/h3&gt;&lt;p&gt;你可以运用递归和迭代两种方法解决这个问题吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="递归/非递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92/"/>
    
      <category term="镜像树" scheme="http://yoursite.com/tags/%E9%95%9C%E5%83%8F%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PaperExamRecord-Iris</title>
    <link href="http://yoursite.com/2020/05/14/PaperExamRecord-Iris/"/>
    <id>http://yoursite.com/2020/05/14/PaperExamRecord-Iris/</id>
    <published>2020-05-14T12:47:51.000Z</published>
    <updated>2020-05-14T15:24:18.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Iris局部线性近似实验分析"><a href="#Iris局部线性近似实验分析" class="headerlink" title="Iris局部线性近似实验分析"></a>Iris局部线性近似实验分析</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>验证算法在低维多类数据集上的有效性</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>多次实验，观察实验结果是否一致</li><li>观测实验结果是否和前人对Iris数据集的分析一致</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>在Iris数据集上使用t-SNE方法投影到二维</li><li>使用算法将t-SNE投影简化成包含3个局部投影的投影集合（Iris数据集中存在三种类型的花）</li></ul><a id="more"></a><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="Iris-t-SNE分片示意图"><a href="#Iris-t-SNE分片示意图" class="headerlink" title="Iris t-SNE分片示意图"></a>Iris t-SNE分片示意图</h4><p><img src="/2020/05/14/PaperExamRecord-Iris/1589463841875.png" alt="1589463841875"></p><h4 id="Iris分片树示意图"><a href="#Iris分片树示意图" class="headerlink" title="Iris分片树示意图"></a>Iris分片树示意图</h4><p><img src="/2020/05/14/PaperExamRecord-Iris/1589463951813.png" alt="1589463951813"></p><h4 id="局部参数映射列表"><a href="#局部参数映射列表" class="headerlink" title="局部参数映射列表"></a>局部参数映射列表</h4><div class="table-container"><table><thead><tr><th>分片标号</th><th>sepal length和投影的相关性</th><th>sepal breadth和投影的相关性</th><th>petal length和投影的相关性</th><th>petal breadth和投影的相关性</th></tr></thead><tbody><tr><td>1</td><td>0.34</td><td>0.28</td><td>1.24</td><td>0.5</td></tr><tr><td>2</td><td>0.28</td><td>0.60</td><td>1.19</td><td>0.36</td></tr><tr><td>3</td><td>0.58</td><td>0.16</td><td>0.98</td><td>0.83</td></tr></tbody></table></div><h4 id="Iris数据集前人分析-1"><a href="#Iris数据集前人分析-1" class="headerlink" title="Iris数据集前人分析$^1$"></a>Iris数据集前人分析$^1$</h4><ul><li>Fisher在线性判别分析的实验中给出的最佳参数（相关性）如下：</li></ul><div class="table-container"><table><thead><tr><th>sepal length</th><th>sepal breadth</th><th>petal length</th><th>petal breadth</th></tr></thead><tbody><tr><td>-3.308998</td><td>-2.759132</td><td>8.866048</td><td>9.392551</td></tr></tbody></table></div><ul><li><p>Fisher线性判别分析结果</p><p><img src="/2020/05/14/PaperExamRecord-Iris/1589465223247.png" alt="1589465223247"></p></li><li><p>Fisher认为petal length和petal breadth相比sepal length和sepal breadth能够更好地区分Iris</p></li></ul><h3 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><ul><li>多次实验得到的实验结果一致</li><li>t-SNE在投影Iris数据集上呈现出和Fisher线性判别分析模型相同的模式<ul><li>所有分片的投影的petal length和petal breadth相关性大于sepal length和sepal breadth的相关性，这和Fisher线性判别分析的结论一致</li></ul></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[1]Fisher R A. The use of multiple measurements in taxonomic problems[J]. Annals of eugenics, 1936, 7(2): 179-188.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Iris局部线性近似实验分析&quot;&gt;&lt;a href=&quot;#Iris局部线性近似实验分析&quot; class=&quot;headerlink&quot; title=&quot;Iris局部线性近似实验分析&quot;&gt;&lt;/a&gt;Iris局部线性近似实验分析&lt;/h2&gt;&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;验证算法在低维多类数据集上的有效性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多次实验，观察实验结果是否一致&lt;/li&gt;
&lt;li&gt;观测实验结果是否和前人对Iris数据集的分析一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在Iris数据集上使用t-SNE方法投影到二维&lt;/li&gt;
&lt;li&gt;使用算法将t-SNE投影简化成包含3个局部投影的投影集合（Iris数据集中存在三种类型的花）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Iris" scheme="http://yoursite.com/tags/Iris/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53.最大子序和</title>
    <link href="http://yoursite.com/2020/05/14/LeetCode-53/"/>
    <id>http://yoursite.com/2020/05/14/LeetCode-53/</id>
    <published>2020-05-14T06:13:49.000Z</published>
    <updated>2020-05-14T07:01:30.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode-53.最大子序和"></a>LeetCode-53.最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><ul><li>如果当前子数组和&gt;0，子数组尾部添加新的数</li><li>如果当前子数组和&lt;0，子数组头部减少存在的数</li><li>最后返回最大子数组和</li><li>时间复杂度为$O(n)$,空间复杂度为$O(1)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start,<span class="built_in">end</span>,sum,len = nums.<span class="built_in">size</span>(),ans;</span><br><span class="line">        <span class="keyword">if</span>(!len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        start = <span class="built_in">end</span> = sum = <span class="number">0</span>;</span><br><span class="line">        ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(start != len &amp;&amp; <span class="built_in">end</span> != len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[<span class="built_in">end</span>];</span><br><span class="line">                ++<span class="built_in">end</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start != <span class="built_in">end</span> &amp;&amp; sum &gt; ans)</span><br><span class="line">                ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>状态转移方程为$ F(i) = max(F(i-1) + a_i,a_i)$,其中：<ul><li>$F(i)$为以第$i$个数为结尾的最大子数组和</li><li>$a_i$为第$i$个数的值</li></ul></li><li>因为状态转移方程只需要上一个位置的结尾的最大子数组和</li><li>所以时间复杂度为$O(n)$,空间复杂度为$O(1)$。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last,now,ans;</span><br><span class="line">        last = now = ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            now = <span class="built_in">max</span>(nums[i],last+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(now &gt; ans)</span><br><span class="line">                ans = now;</span><br><span class="line">            last = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分治（线段树）"><a href="#分治（线段树）" class="headerlink" title="分治（线段树）"></a>分治（线段树）</h4><ul><li><p>为了合并两个子区域，每个子区域我们需要维护以下属性</p><ul><li>$lSum$ 表示 $[l,r)$ 内以 $l$ 为左端点的最大子段和</li><li>$rSum$ 表示 $[l,r)$  内以 $r-1$ 为右端点的最大子段和</li><li>$mSum$ 表示 $[l,r)$  内的最大子段和</li><li>$iSum$ 表示 $[l,r)$ 的区间和。</li></ul></li><li><p>Divide阶段：</p><ul><li>将$[l,r)$划分成$[l,m)$和$[m,r)$两个部分，其中$m=(l+r)/2$</li><li>当$l + 1 == r$时，返回$[l,r)$ 子区域</li></ul></li><li>Combine阶段：<ul><li>合并$l$子区域和$r$子区域，新的子区域的属性值如下：<ul><li>$lSum = max(l.lSum,l.iSum+r.lSum)$</li><li>$rSum = max(r.rSum,l.rSum+r.iSum)$</li><li>$mSum = max(l.rSum+r.lSum,max(l.mSum,r.mSum))$，因为新区间的最大子段和如果不跨区间，那么就是$max(l.mSum,r.mSum)$；如果跨区间，那么就是$l.rSum+r.lSum$</li><li>$iSum = l.iSum + r.iSum$</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">states</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> isum,lsum,rsum,msum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">states <span class="title">Combine</span><span class="params">(states &amp;l, states &amp;r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> isum,lsum,rsum,msum;</span><br><span class="line">        isum = l.isum + r.isum;</span><br><span class="line">        lsum = <span class="built_in">max</span>(l.lsum,l.isum + r.lsum);</span><br><span class="line">        rsum = <span class="built_in">max</span>(r.rsum,l.rsum + r.isum);</span><br><span class="line">        msum = <span class="built_in">max</span>(l.rsum + r.lsum,<span class="built_in">max</span>(l.msum,r.msum));</span><br><span class="line">        <span class="keyword">return</span> (states)&#123;isum,lsum,rsum,msum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">states <span class="title">Divide</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l+<span class="number">1</span> == r)</span><br><span class="line">            <span class="keyword">return</span> (states)&#123;nums[l],nums[l],nums[l],nums[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">        states ls = Divide(nums,l,m);</span><br><span class="line">        states rs = Divide(nums,m,r);</span><br><span class="line">        <span class="keyword">return</span> Combine(ls,rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Divide(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()).msum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-53-最大子序和&quot;&gt;&lt;a href=&quot;#LeetCode-53-最大子序和&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-53.最大子序和&quot;&gt;&lt;/a&gt;LeetCode-53.最大子序和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;进阶:&lt;/p&gt;
&lt;p&gt;如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-155.最小栈</title>
    <link href="http://yoursite.com/2020/05/13/LeetCode-155/"/>
    <id>http://yoursite.com/2020/05/13/LeetCode-155/</id>
    <published>2020-05-13T12:56:20.000Z</published>
    <updated>2020-05-13T13:29:05.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-155-最小栈"><a href="#LeetCode-155-最小栈" class="headerlink" title="LeetCode-155.最小栈"></a>LeetCode-155.最小栈</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>实现一个能在常数时间能检索到最小元素的栈，那么需要这么设计数据结构</p><ul><li>用数组实现一个数据栈来存储数据</li><li>用数组实现一个最小数栈来存储最小数<ul><li>因为两个最小数之间的数字都不会是最小数，所以当Pop出一个最小数，那么新的最小数栈的栈顶就是当前的最小数</li></ul></li><li>需要注意动态扩容的问题</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">int</span> *data,*<span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>,msize;</span><br><span class="line">    <span class="keyword">int</span> length,mlength;</span><br><span class="line">    MinStack() :data(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]),<span class="built_in">min</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]),<span class="built_in">size</span>(<span class="number">128</span>),msize(<span class="number">128</span>),length(<span class="number">0</span>),mlength(<span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mlength == <span class="number">0</span> || x &lt;= <span class="built_in">min</span>[mlength - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mlength == msize)&#123;</span><br><span class="line">                msize *= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> *newdata = <span class="keyword">new</span> <span class="keyword">int</span>[msize];</span><br><span class="line">                <span class="keyword">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i != mlength;++i)</span><br><span class="line">                    newdata[i] = <span class="built_in">min</span>[i];</span><br><span class="line">                <span class="keyword">delete</span>[] <span class="built_in">min</span>;</span><br><span class="line">                <span class="built_in">min</span> = newdata;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">min</span>[mlength++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="built_in">size</span>)&#123;</span><br><span class="line">            <span class="built_in">size</span> *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> *newdata = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span>];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>;i != length;++i)</span><br><span class="line">                newdata[i] = data[i];</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">            data = newdata;</span><br><span class="line">        &#125;</span><br><span class="line">        data[length++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[--length] == <span class="built_in">min</span>[mlength<span class="number">-1</span>])&#123;</span><br><span class="line">                --mlength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> data[length<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mlength &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>[mlength<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-155-最小栈&quot;&gt;&lt;a href=&quot;#LeetCode-155-最小栈&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-155.最小栈&quot;&gt;&lt;/a&gt;LeetCode-155.最小栈&lt;/h2&gt;&lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;p&gt;push(x) —— 将元素 x 推入栈中。&lt;br&gt;pop() —— 删除栈顶的元素。&lt;br&gt;top() —— 获取栈顶元素。&lt;br&gt;getMin() —— 检索栈中的最小元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例:&quot;&gt;&lt;/a&gt;示例:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[-2],[0],[-3],[],[],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[null,null,null,null,-3,null,0,-2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MinStack minStack &amp;#x3D; new MinStack();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; 返回 -3.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.top();      --&amp;gt; 返回 0.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; 返回 -2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;pop、top 和 getMin 操作总是在 非空栈 上调用。&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;实现一个能在常数时间能检索到最小元素的栈，那么需要这么设计数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用数组实现一个数据栈来存储数据&lt;/li&gt;
&lt;li&gt;用数组实现一个最小数栈来存储最小数&lt;ul&gt;
&lt;li&gt;因为两个最小数之间的数字都不会是最小数，所以当Pop出一个最小数，那么新的最小数栈的栈顶就是当前的最小数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要注意动态扩容的问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-121.买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/05/12/LeetCode-121/"/>
    <id>http://yoursite.com/2020/05/12/LeetCode-121/</id>
    <published>2020-05-12T04:11:41.000Z</published>
    <updated>2020-05-12T09:20:41.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode-121.买卖股票的最佳时机"></a>LeetCode-121.买卖股票的最佳时机</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">(注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。)</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>可以用动态规划实现，那么就会涉及到状态转移方程。</p></li><li><p>状态转移方程：计算到每一天的最低股价 = 前一天的股价 &lt; 当天的股价 ？ 前一天的股价 ： 当天的股价。</p></li><li><p>最大利润为最低股价和当前股价之间的差值的最大值</p></li></ul><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = prices[<span class="number">0</span>],<span class="built_in">min</span> = prices[<span class="number">0</span>],ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i,len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">                ans = ans &gt; <span class="built_in">max</span> - <span class="built_in">min</span> ? ans : <span class="built_in">max</span> - <span class="built_in">min</span>;</span><br><span class="line">                <span class="built_in">min</span> = prices[i];</span><br><span class="line">                <span class="built_in">max</span> = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i] &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">                <span class="built_in">max</span> = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans = ans &gt; <span class="built_in">max</span> - <span class="built_in">min</span> ? ans : <span class="built_in">max</span>-<span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#LeetCode-121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-121.买卖股票的最佳时机&quot;&gt;&lt;/a&gt;LeetCode-121.买卖股票的最佳时机&lt;/h2&gt;&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;h3 id=&quot;示例-1&quot;&gt;&lt;a href=&quot;#示例-1&quot; class=&quot;headerlink&quot; title=&quot;示例 1&quot;&gt;&lt;/a&gt;示例 1&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 2 天（股票价格 &amp;#x3D; 1）的时候买入，在第 5 天（股票价格 &amp;#x3D; 6）的时候卖出，最大利润 &amp;#x3D; 6-1 &amp;#x3D; 5 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(注意利润不能是 7-1 &amp;#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;示例-2&quot;&gt;&lt;a href=&quot;#示例-2&quot; class=&quot;headerlink&quot; title=&quot;示例 2&quot;&gt;&lt;/a&gt;示例 2&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,6,4,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以用动态规划实现，那么就会涉及到状态转移方程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态转移方程：计算到每一天的最低股价 = 前一天的股价 &amp;lt; 当天的股价 ？ 前一天的股价 ： 当天的股价。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最大利润为最低股价和当前股价之间的差值的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>HeapSort.堆排序</title>
    <link href="http://yoursite.com/2020/05/12/HeapSort/"/>
    <id>http://yoursite.com/2020/05/12/HeapSort/</id>
    <published>2020-05-11T16:13:18.000Z</published>
    <updated>2020-05-12T09:22:25.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>来源百度百科：</p><blockquote><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是<strong>完全二叉树</strong>。</p></blockquote><p>简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法</p><ul><li>最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子</li><li>那么处于最小堆的根节点的元素一定是这个堆中的最小值（此处我们考虑小根堆）</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul><li><p>在原数组上构造堆时，我们需要从最后一个父节点( (len-1)/2 )开始调整堆。</p></li><li><p>调整堆的原理：</p><ul><li>找到子节点中的最小节点</li><li>比较最小子节点和父节点的大小<ul><li>如果父节点大于最小子节点，则交换父节点和最小子节点，并在最小子节点上再次调整堆</li><li>如果父节点小于最小子节点，则调整完成</li></ul></li></ul></li><li>调整好堆以后，我们逐次输出根节点（最小节点）<ul><li>交换根节点和最末节点，并将堆的大小减一</li><li>从根节点调整堆</li></ul></li></ul><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustheap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; len &amp;&amp; arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeheap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        adjustheap(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr || len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    makeheap(arr, len);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        adjustheap(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[len - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">100</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    heapsort(a, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;来源百度百科：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是&lt;strong&gt;完全二叉树&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说：堆排序是将数据看成是完全二叉树、根据完全二叉树的特性来进行排序的一种算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大堆要求节点的元素都要不小于其孩子，最小堆要求节点元素都不大于其左右孩子&lt;/li&gt;
&lt;li&gt;那么处于最小堆的根节点的元素一定是这个堆中的最小值（此处我们考虑小根堆）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;算法思路&quot;&gt;&lt;a href=&quot;#算法思路&quot; class=&quot;headerlink&quot; title=&quot;算法思路&quot;&gt;&lt;/a&gt;算法思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在原数组上构造堆时，我们需要从最后一个父节点( (len-1)/2 )开始调整堆。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调整堆的原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到子节点中的最小节点&lt;/li&gt;
&lt;li&gt;比较最小子节点和父节点的大小&lt;ul&gt;
&lt;li&gt;如果父节点大于最小子节点，则交换父节点和最小子节点，并在最小子节点上再次调整堆&lt;/li&gt;
&lt;li&gt;如果父节点小于最小子节点，则调整完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调整好堆以后，我们逐次输出根节点（最小节点）&lt;ul&gt;
&lt;li&gt;交换根节点和最末节点，并将堆的大小减一&lt;/li&gt;
&lt;li&gt;从根节点调整堆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-160.相交链表</title>
    <link href="http://yoursite.com/2020/05/10/LeetCode-160/"/>
    <id>http://yoursite.com/2020/05/10/LeetCode-160/</id>
    <published>2020-05-10T04:55:59.000Z</published>
    <updated>2020-05-12T09:23:33.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-160-相交链表"><a href="#LeetCode-160-相交链表" class="headerlink" title="LeetCode-160.相交链表"></a>LeetCode-160.相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p><img src="/2020/05/10/LeetCode-160/160_statement.png" alt="img"></p><p>在节点 c1 开始相交。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p><img src="/2020/05/10/LeetCode-160/160_example_1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p><img src="/2020/05/10/LeetCode-160/160_example_2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><p><img src="/2020/05/10/LeetCode-160/160_example_3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>如果两个链表没有交点，返回 null</li><li>在返回结果后，两个链表仍须保持原有的结构</li><li>可假定整个链表结构中没有循环</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>因为时间复杂度O(n)和空间复杂度O(1)的要求，所以我们可知，只能遍历固定次数链表，且不能根据数据规模开辟内存空间。</li><li>两个链表可能是不等长的，并且如果存在交点，交点肯定不在不等长的那部分。</li><li>首先遍历两个链表，确定两个链表的长度，Lengtha，Lengthb。</li><li>根据Lengtha和Lengthb的长度调整两个链表为等长的</li><li>遍历比较两个链表的首节点是否相等<ul><li>不相等将首节点下一个节点置为首节点</li><li>相等跳出遍历</li></ul></li><li>如果首节点不为空，则存在交点；如果为空，则不存在交点</li></ul><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Lengtha = <span class="number">0</span>,Lengthb = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmpa = headA,*tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(tmpa)&#123;</span><br><span class="line">            ++Lengtha;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpb)&#123;</span><br><span class="line">            ++Lengthb;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpa = headA,tmpb = headB;</span><br><span class="line">        <span class="keyword">while</span>(Lengtha != Lengthb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Lengtha &lt; Lengthb)&#123;</span><br><span class="line">                --Lengthb;</span><br><span class="line">                tmpb = tmpb-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --Lengtha;</span><br><span class="line">                tmpa = tmpa-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tmpa!=tmpb)&#123;</span><br><span class="line">            tmpa = tmpa-&gt;next;</span><br><span class="line">            tmpb = tmpb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpa)</span><br><span class="line">            <span class="keyword">return</span> tmpa;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-160-相交链表&quot;&gt;&lt;a href=&quot;#LeetCode-160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-160.相交链表&quot;&gt;&lt;/a&gt;LeetCode-160.相交链表&lt;/h2&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/05/10/LeetCode-160/160_statement.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;h3 id=&quot;示例-1&quot;&gt;&lt;a href=&quot;#示例-1&quot; class=&quot;headerlink&quot; title=&quot;示例 1&quot;&gt;&lt;/a&gt;示例 1&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/10/LeetCode-160/160_example_1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：intersectVal &amp;#x3D; 8, listA &amp;#x3D; [4,1,8,4,5], listB &amp;#x3D; [5,0,1,8,4,5], skipA &amp;#x3D; 2, skipB &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：Reference of the node with value &amp;#x3D; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;示例-2&quot;&gt;&lt;a href=&quot;#示例-2&quot; class=&quot;headerlink&quot; title=&quot;示例 2&quot;&gt;&lt;/a&gt;示例 2&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/10/LeetCode-160/160_example_2.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：intersectVal &amp;#x3D; 2, listA &amp;#x3D; [0,9,1,2,4], listB &amp;#x3D; [3,2,4], skipA &amp;#x3D; 3, skipB &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：Reference of the node with value &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;示例-3&quot;&gt;&lt;a href=&quot;#示例-3&quot; class=&quot;headerlink&quot; title=&quot;示例 3&quot;&gt;&lt;/a&gt;示例 3&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/10/LeetCode-160/160_example_3.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：intersectVal &amp;#x3D; 0, listA &amp;#x3D; [2,6,4], listB &amp;#x3D; [1,5], skipA &amp;#x3D; 3, skipB &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：这两个链表不相交，因此返回 null。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果两个链表没有交点，返回 null&lt;/li&gt;
&lt;li&gt;在返回结果后，两个链表仍须保持原有的结构&lt;/li&gt;
&lt;li&gt;可假定整个链表结构中没有循环&lt;/li&gt;
&lt;li&gt;程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;因为时间复杂度O(n)和空间复杂度O(1)的要求，所以我们可知，只能遍历固定次数链表，且不能根据数据规模开辟内存空间。&lt;/li&gt;
&lt;li&gt;两个链表可能是不等长的，并且如果存在交点，交点肯定不在不等长的那部分。&lt;/li&gt;
&lt;li&gt;首先遍历两个链表，确定两个链表的长度，Lengtha，Lengthb。&lt;/li&gt;
&lt;li&gt;根据Lengtha和Lengthb的长度调整两个链表为等长的&lt;/li&gt;
&lt;li&gt;遍历比较两个链表的首节点是否相等&lt;ul&gt;
&lt;li&gt;不相等将首节点下一个节点置为首节点&lt;/li&gt;
&lt;li&gt;相等跳出遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果首节点不为空，则存在交点；如果为空，则不存在交点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>PaperExamRecord-SwissRoll</title>
    <link href="http://yoursite.com/2020/05/09/PaperExamRecord-SwissRoll/"/>
    <id>http://yoursite.com/2020/05/09/PaperExamRecord-SwissRoll/</id>
    <published>2020-05-09T10:29:49.000Z</published>
    <updated>2020-05-14T14:49:50.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SwissRoll局部线性近似实验分析"><a href="#SwissRoll局部线性近似实验分析" class="headerlink" title="SwissRoll局部线性近似实验分析"></a>SwissRoll局部线性近似实验分析</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>验证算法在三维流形数据集上的有效性</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>多次实验，观察实验结果是否一致</li><li>实验结果分析得到的结论是否存在异常</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>在SwissRoll三维流形数据集上使用ISOMAP方法投影到二维</li><li>使用算法将ISOMAP投影简化成包含10个局部投影的投影集合</li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="SwissRoll-ISOMAP分片示意图"><a href="#SwissRoll-ISOMAP分片示意图" class="headerlink" title="SwissRoll ISOMAP分片示意图"></a>SwissRoll ISOMAP分片示意图</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589023174018.png" alt="1589023174018"></p><h4 id="SwissRoll分片树示意图"><a href="#SwissRoll分片树示意图" class="headerlink" title="SwissRoll分片树示意图"></a>SwissRoll分片树示意图</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589022936862.png" alt="1589022936862"></p><h4 id="SwissRoll三维模型示意图（图片中的数字对应分片号）"><a href="#SwissRoll三维模型示意图（图片中的数字对应分片号）" class="headerlink" title="SwissRoll三维模型示意图（图片中的数字对应分片号）"></a>SwissRoll三维模型示意图（图片中的数字对应分片号）</h4><p><img src="/2020/05/09/PaperExamRecord-SwissRoll/1589022188714.png" alt="1589022188714"></p><a id="more"></a><h4 id="局部参数映射列表-维度顺序是（z-y-x"><a href="#局部参数映射列表-维度顺序是（z-y-x" class="headerlink" title="局部参数映射列表 维度顺序是（z,y,x)"></a>局部参数映射列表 维度顺序是（z,y,x)</h4><table>     <tr>        <td>分片标号</td>        <td>原始特征在X轴上的相关性</td>        <td>原始特征在Y轴上的相关性</td>     </tr>     <tr>        <td>1</td>        <td>-0.24</td>        <td>0.01</td>     </tr>     <tr>        <td></td>        <td>0.01</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>0.96</td>        <td>-0.03</td>     </tr>     <tr>        <td>2</td>        <td>-0.81</td>        <td>0.04</td>     </tr>     <tr>        <td></td>        <td>0.02</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>0.59</td>        <td>0.03</td>     </tr>     <tr>        <td>3</td>        <td>-0.99</td>        <td>0</td>     </tr>     <tr>        <td></td>        <td>0</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>-0.16</td>        <td>0.05</td>     </tr>     <tr>        <td>4</td>        <td>-0.62</td>        <td>0.03</td>     </tr>     <tr>        <td></td>        <td>0</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>-0.78</td>        <td>0</td>     </tr>     <tr>        <td>5</td>        <td>0.2</td>        <td>0</td>     </tr>     <tr>        <td></td>        <td>-0.02</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>-0.98</td>        <td>0</td>     </tr>     <tr>        <td>6</td>        <td>0.34</td>        <td>0</td>     </tr>     <tr>        <td></td>        <td>-0.01</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>-0.94</td>        <td>0.03</td>     </tr>     <tr>        <td>7</td>        <td>0.73</td>        <td>0.01</td>     </tr>     <tr>        <td></td>        <td>0.03</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>-0.68</td>        <td>0.02</td>     </tr>     <tr>        <td>8</td>        <td>1</td>        <td>0</td>     </tr>     <tr>        <td></td>        <td>0</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>0.11</td>        <td>0.01</td>     </tr>     <tr>        <td>9</td>        <td>0.57</td>        <td>0.04</td>     </tr>     <tr>        <td></td>        <td>0.03</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>0.82</td>        <td>-0.01</td>     </tr>     <tr>        <td>10</td>        <td>0.07</td>        <td>-0.01</td>     </tr>     <tr>        <td></td>        <td>0</td>        <td>-1</td>     </tr>     <tr>        <td></td>        <td>1</td>        <td>-0.02</td>     </tr>  </table><h3 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><ul><li>多次实验得到的实验结果一致，且实验结果中没有发现异常</li><li>ISOMAP在展开SwissRoll数据集时，二维投影的Y轴与数据集本身的第二维(Y）一一对应。<ul><li>所有分片的Y轴与SwissRoll的第二维（Y）相关程度都为-1</li></ul></li><li>ISOMAP在展开SwissRoll数据集时，不同分片的X轴与原始特征之间的关系呈现出可解释的规律：<ul><li>1,5,6,10等接近水平的分片，X轴与第三维（X）的相关性更强。</li><li>3,8等接近垂直的分片，X轴与第一维（Z）的相关性更强</li><li>根据分片在三维空间中的分布，X轴与第一维（Z）和第三维（X）的相关性一直在规律性的变化<ul><li>1-》2-》3，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直</li><li>4-》5，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li><li>6-》7-》8，Z的相关性增强，X的相关性减弱，因为分片变得更接近垂直<ul><li>其中7存在Z和X相关性接近的情况，这是因为7在Z和X上的可分性都很好</li></ul></li><li>8-》9-》10，Z的相关性减弱，X的相关性增强，因为分片变得更接近水平</li><li>根据上述实验结果的分析，我认为我们方法生成的参数映射是连续的，并可以利用参数映射连续性来分析分片之间的非线性变化。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SwissRoll局部线性近似实验分析&quot;&gt;&lt;a href=&quot;#SwissRoll局部线性近似实验分析&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll局部线性近似实验分析&quot;&gt;&lt;/a&gt;SwissRoll局部线性近似实验分析&lt;/h2&gt;&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;验证算法在三维流形数据集上的有效性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多次实验，观察实验结果是否一致&lt;/li&gt;
&lt;li&gt;实验结果分析得到的结论是否存在异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在SwissRoll三维流形数据集上使用ISOMAP方法投影到二维&lt;/li&gt;
&lt;li&gt;使用算法将ISOMAP投影简化成包含10个局部投影的投影集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验结果&quot;&gt;&lt;a href=&quot;#实验结果&quot; class=&quot;headerlink&quot; title=&quot;实验结果&quot;&gt;&lt;/a&gt;实验结果&lt;/h3&gt;&lt;h4 id=&quot;SwissRoll-ISOMAP分片示意图&quot;&gt;&lt;a href=&quot;#SwissRoll-ISOMAP分片示意图&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll ISOMAP分片示意图&quot;&gt;&lt;/a&gt;SwissRoll ISOMAP分片示意图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/09/PaperExamRecord-SwissRoll/1589023174018.png&quot; alt=&quot;1589023174018&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;SwissRoll分片树示意图&quot;&gt;&lt;a href=&quot;#SwissRoll分片树示意图&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll分片树示意图&quot;&gt;&lt;/a&gt;SwissRoll分片树示意图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/09/PaperExamRecord-SwissRoll/1589022936862.png&quot; alt=&quot;1589022936862&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;SwissRoll三维模型示意图（图片中的数字对应分片号）&quot;&gt;&lt;a href=&quot;#SwissRoll三维模型示意图（图片中的数字对应分片号）&quot; class=&quot;headerlink&quot; title=&quot;SwissRoll三维模型示意图（图片中的数字对应分片号）&quot;&gt;&lt;/a&gt;SwissRoll三维模型示意图（图片中的数字对应分片号）&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2020/05/09/PaperExamRecord-SwissRoll/1589022188714.png&quot; alt=&quot;1589022188714&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="SwissRoll" scheme="http://yoursite.com/tags/SwissRoll/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-437.路径总和III</title>
    <link href="http://yoursite.com/2020/05/09/LeetCode-437/"/>
    <id>http://yoursite.com/2020/05/09/LeetCode-437/</id>
    <published>2020-05-09T09:56:52.000Z</published>
    <updated>2020-05-12T09:25:42.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-437-路径总和III"><a href="#LeetCode-437-路径总和III" class="headerlink" title="LeetCode-437.路径总和III"></a>LeetCode-437.路径总和III</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11</code></pre><h3 id="使用双递归完成"><a href="#使用双递归完成" class="headerlink" title="使用双递归完成"></a>使用双递归完成</h3><ul><li>第一层递归遍历起始节点</li><li>第二层递归遍历结束节点</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> func(root,sum) + pathSum(root-&gt;left,sum) + pathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (sum ? <span class="number">0</span> : <span class="number">1</span>) + func(root-&gt;left,sum) + func(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用前缀和"><a href="#使用前缀和" class="headerlink" title="使用前缀和"></a>使用前缀和</h3><ul><li>前缀和的定义是，路径上到当前节点为止的累加和（包括当前节点）</li><li>因此我们可以得到推论：A节点和B节点之间的节点和为B的前缀和与A的前缀和的差值。</li><li>那么给定B的前缀和与路径和，我们可以算出A的前缀和（A = B - val)</li><li>为了方便检索前缀和，我们可以使用Map管理前缀和。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> count = <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> func(root,count,sum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;count,<span class="keyword">int</span> &amp;val,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum == val)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum-val) != count.<span class="built_in">end</span>())</span><br><span class="line">            ans += count[sum-val];</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(sum) == count.<span class="built_in">end</span>())</span><br><span class="line">            count[sum] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++count[sum];</span><br><span class="line">        ans += func(root-&gt;left,count,val,sum);</span><br><span class="line">        ans += func(root-&gt;right,count,val,sum);</span><br><span class="line">        --count[sum];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-437-路径总和III&quot;&gt;&lt;a href=&quot;#LeetCode-437-路径总和III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-437.路径总和III&quot;&gt;&lt;/a&gt;LeetCode-437.路径总和III&lt;/h2&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放着一个整数值。&lt;/p&gt;
&lt;p&gt;找出路径和等于给定数值的路径总数。&lt;/p&gt;
&lt;p&gt;路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。&lt;/p&gt;
&lt;p&gt;二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

返回 3。和等于 8 的路径有:

1. 5 -&amp;gt; 3
2. 5 -&amp;gt; 2 -&amp;gt; 1
3. -3 -&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用双递归完成&quot;&gt;&lt;a href=&quot;#使用双递归完成&quot; class=&quot;headerlink&quot; title=&quot;使用双递归完成&quot;&gt;&lt;/a&gt;使用双递归完成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一层递归遍历起始节点&lt;/li&gt;
&lt;li&gt;第二层递归遍历结束节点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="前缀和" scheme="http://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="双递归" scheme="http://yoursite.com/tags/%E5%8F%8C%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>GP-tSNE论文重构</title>
    <link href="http://yoursite.com/2020/05/08/GP-tSNEReconstruct/"/>
    <id>http://yoursite.com/2020/05/08/GP-tSNEReconstruct/</id>
    <published>2020-05-08T05:19:13.000Z</published>
    <updated>2020-05-10T05:10:40.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GP-tSNE论文重构"><a href="#GP-tSNE论文重构" class="headerlink" title="GP-tSNE论文重构"></a>GP-tSNE论文重构</h2><p>高维数据投影是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GP-tSNE论文重构&quot;&gt;&lt;a href=&quot;#GP-tSNE论文重构&quot; class=&quot;headerlink&quot; title=&quot;GP-tSNE论文重构&quot;&gt;&lt;/a&gt;GP-tSNE论文重构&lt;/h2&gt;&lt;p&gt;高维数据投影是&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="论文重构" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%87%8D%E6%9E%84/"/>
    
      <category term="可理解性" scheme="http://yoursite.com/tags/%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-448.找到所有数组中消失的数字</title>
    <link href="http://yoursite.com/2020/05/08/LeetCode-448/"/>
    <id>http://yoursite.com/2020/05/08/LeetCode-448/</id>
    <published>2020-05-08T05:09:24.000Z</published>
    <updated>2020-05-12T09:27:08.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-448-找到所有数组中消失的数字"><a href="#LeetCode-448-找到所有数组中消失的数字" class="headerlink" title="LeetCode-448.找到所有数组中消失的数字"></a>LeetCode-448.找到所有数组中消失的数字</h2><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>因为不能使用额外空间，且1 ≤ a[i] ≤ n,所以我们可以直接使用原数组完成hash</li><li>将被hash到的位置变成负数，因为1 ≤ a[i] ≤ n,所以值为负就可以确保该位置被hash到</li><li>最后统计值&gt;0的位置即可</li><li>时间复杂度O(2n),空间复杂度O(1)(如果不算返回值)</li></ul><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            j = <span class="built_in">abs</span>(nums[i])<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; <span class="number">0</span>)</span><br><span class="line">                nums[j] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-448-找到所有数组中消失的数字&quot;&gt;&lt;a href=&quot;#LeetCode-448-找到所有数组中消失的数字&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-448.找到所有数组中消失的数字&quot;&gt;&lt;/a&gt;LeetCode-448.找到所有数组中消失的数字&lt;/h2&gt;&lt;p&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;
&lt;p&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字。&lt;/p&gt;
&lt;p&gt;您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4,3,2,7,8,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[5,6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;因为不能使用额外空间，且1 ≤ a[i] ≤ n,所以我们可以直接使用原数组完成hash&lt;/li&gt;
&lt;li&gt;将被hash到的位置变成负数，因为1 ≤ a[i] ≤ n,所以值为负就可以确保该位置被hash到&lt;/li&gt;
&lt;li&gt;最后统计值&amp;gt;0的位置即可&lt;/li&gt;
&lt;li&gt;时间复杂度O(2n),空间复杂度O(1)(如果不算返回值)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>论文错误记录</title>
    <link href="http://yoursite.com/2020/05/07/ErrorRecord/"/>
    <id>http://yoursite.com/2020/05/07/ErrorRecord/</id>
    <published>2020-05-07T15:33:13.000Z</published>
    <updated>2020-05-17T08:26:10.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文错误记录"><a href="#论文错误记录" class="headerlink" title="论文错误记录"></a>论文错误记录</h2><ul><li>原句：但是，目前最流行的可视化方法（如t-SNE[]）往往是黑箱方法，因为使用者无法洞察可视化如何表示数据的原始特征<ul><li>问题：最流行的降维方法，不仅仅是t-SNE，还有PCA；无法观察原始特征，和黑箱之间的因果联系未论证。</li><li>解析：<ul><li>定语缺失，应该说是最流行的的流形学习方法</li><li>“流形学习方法（如t-SNE[]）往往是黑箱方法”作为结论，“因为使用者无法洞察可视化如何表示数据的原始特征”作为前提，是以偏概全</li></ul></li></ul></li><li>原句：即使是可视化领域中最新的研究进展，如UMAP[] 也承认其依然存在着可解释性问题。<ul><li>问题：不知道这里的可解释性问题又是什么？最新的进展，和可解释性有什么关系？为什么要用即使？</li><li>解析：<ul><li>可解释性问题在上文中没有给出直接的定义，我只描述了导致可解释问题的两个情景。</li><li>因果关系没写清楚，太含混了</li></ul></li></ul></li><li>原句：其他的方法如AutoEncoder[] 和 parametric t-SNE[] 给出了从原始数据及到二维可视化<br>的参数映射，但这些参数映射都基于复杂的神经网络生成，对人来说依然难以理解<ul><li>问题：其它的方法，什么叫其它的方法？举例不能代表概念。</li><li>解析：应该写成给出参数映射的流形学习变体</li></ul></li><li>原句：虽然PCA 和LDA 等线性方法的可视化结果具有很强的可解释性，但它们的可视化仅能表示数据的原始特征的线性组合，这限制了其可视化的质量。<ul><li>问题：刚刚在讨论可解释性，为什么忽然又变成了可视化的质量？</li><li>解析：要紧扣主题</li></ul></li><li>写作结构：<ul><li>原来的t-sne投影，原始特征跟投影轴之间的关系复杂，难以描述和理解</li><li>虽然有一些方法试图可视化这种复杂关系，但还存在xx问题</li><li>我们提出t-sne投影的分片线性近似，如何解决了上述问题</li><li>我们认为，一个可理解的分片线性近似，需要具有如下的性质1、2、3、</li><li>为次，我们提出了xx算法，设计了xx表达，…</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论文错误记录&quot;&gt;&lt;a href=&quot;#论文错误记录&quot; class=&quot;headerlink&quot; title=&quot;论文错误记录&quot;&gt;&lt;/a&gt;论文错误记录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原句：但是，目前最流行的可视化方法（如t-SNE[]）往往是黑箱方法，因为使用者无法洞察可视化如
      
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="写作错误" scheme="http://yoursite.com/tags/%E5%86%99%E4%BD%9C%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-283.移动零</title>
    <link href="http://yoursite.com/2020/05/07/LeetCode-283/"/>
    <id>http://yoursite.com/2020/05/07/LeetCode-283/</id>
    <published>2020-05-07T03:48:57.000Z</published>
    <updated>2020-05-12T09:24:53.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode-283.移动零"></a>LeetCode-283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们使用双指针i，j来解决这个问题</li><li>其中i指向数组中第一个为0的位置，j指向i后第一个非0的位置</li><li>因为i，j之间只有两种关系：<ul><li>i，j相同。此时num[i] == num[j]。因此我们++i,++j来找到第一个不为0的num[i]</li><li>i，j不同。此时i，j之间没有非零数，所以当nums[i] != 0时，nums[j] == 0。因此我们++i,++j来找到第一个不为0的num[i]</li><li>因此这两种情况都需要++i,++j</li></ul></li></ul><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;j != nums.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j != nums.<span class="built_in">size</span>() &amp;&amp; !nums[j])++j;</span><br><span class="line">                <span class="keyword">if</span>(j != nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-283-移动零&quot;&gt;&lt;a href=&quot;#LeetCode-283-移动零&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-283.移动零&quot;&gt;&lt;/a&gt;LeetCode-283.移动零&lt;/h2&gt;&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;我们使用双指针i，j来解决这个问题&lt;/li&gt;
&lt;li&gt;其中i指向数组中第一个为0的位置，j指向i后第一个非0的位置&lt;/li&gt;
&lt;li&gt;因为i，j之间只有两种关系：&lt;ul&gt;
&lt;li&gt;i，j相同。此时num[i] == num[j]。因此我们++i,++j来找到第一个不为0的num[i]&lt;/li&gt;
&lt;li&gt;i，j不同。此时i，j之间没有非零数，所以当nums[i] != 0时，nums[j] == 0。因此我们++i,++j来找到第一个不为0的num[i]&lt;/li&gt;
&lt;li&gt;因此这两种情况都需要++i,++j&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-538.把二叉搜索树转换为累加树</title>
    <link href="http://yoursite.com/2020/05/06/LeetCode-538/"/>
    <id>http://yoursite.com/2020/05/06/LeetCode-538/</id>
    <published>2020-05-06T04:11:29.000Z</published>
    <updated>2020-05-12T09:26:31.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-538-把二叉搜索树转换为累加树"><a href="#LeetCode-538-把二叉搜索树转换为累加树" class="headerlink" title="LeetCode-538.把二叉搜索树转换为累加树"></a>LeetCode-538.把二叉搜索树转换为累加树</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>因为是二叉搜索树，所以左子树&lt;根节点&lt;右节点</li><li>所以转换成累加树，我们只需要从最右向最左遍历树，并且将当前节点的值设为已遍历节点值的和（已遍历节点包括当前节点）</li></ul><a id="more"></a><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><ul><li>直接按解题思路遍历树即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            val += root-&gt;val;</span><br><span class="line">            root-&gt;val = val;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><ul><li>非递归方法先找到当前节点的右子节点</li><li>然后再遍历当前的左子节点，如果没有则回溯</li><li>回溯过程和遍历左子节点过程要区分开，避免节点重复遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()||node)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node)&#123;</span><br><span class="line">                s.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            node = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            val += node-&gt;val;</span><br><span class="line">            node-&gt;val = val;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-538-把二叉搜索树转换为累加树&quot;&gt;&lt;a href=&quot;#LeetCode-538-把二叉搜索树转换为累加树&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-538.把二叉搜索树转换为累加树&quot;&gt;&lt;/a&gt;LeetCode-538.把二叉搜索树转换为累加树&lt;/h2&gt;&lt;p&gt;给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 原始二叉搜索树:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#x2F;   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           2     13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 转换为累加树:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#x2F;   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          20     13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;因为是二叉搜索树，所以左子树&amp;lt;根节点&amp;lt;右节点&lt;/li&gt;
&lt;li&gt;所以转换成累加树，我们只需要从最右向最左遍历树，并且将当前节点的值设为已遍历节点值的和（已遍历节点包括当前节点）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="递归/非递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92-%E9%9D%9E%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21.合并两个有序链表</title>
    <link href="http://yoursite.com/2020/05/05/LeetCode-21/"/>
    <id>http://yoursite.com/2020/05/05/LeetCode-21/</id>
    <published>2020-05-05T05:50:29.000Z</published>
    <updated>2020-05-12T09:23:58.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode-21.合并两个有序链表"></a>LeetCode-21.合并两个有序链表</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>选取两个链表中较小的头节点作为合并链表的头结点，然后按从小到大顺添加两个链表的头节点到合并链表上</p><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>,*tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-21-合并两个有序链表&quot;&gt;&lt;a href=&quot;#LeetCode-21-合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-21.合并两个有序链表&quot;&gt;&lt;/a&gt;LeetCode-21.合并两个有序链表&lt;/h2&gt;&lt;p&gt;将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;选取两个链表中较小的头节点作为合并链表的头结点，然后按从小到大顺添加两个链表的头节点到合并链表上&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-169.多数元素</title>
    <link href="http://yoursite.com/2020/05/04/LeetCode-169/"/>
    <id>http://yoursite.com/2020/05/04/LeetCode-169/</id>
    <published>2020-05-04T02:33:08.000Z</published>
    <updated>2020-05-12T09:23:48.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-169-多数元素"><a href="#LeetCode-169-多数元素" class="headerlink" title="LeetCode-169.多数元素"></a>LeetCode-169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为多数元素数量大于n/2，所以我们只需要统计投票数：（因为只有众数的投票数不为0）</p><ul><li><p>如果当前数字和记录数一致，投票加1</p></li><li><p>如果当前数字和记录数不一致，投票减1</p><ul><li>如果减一后投票数为0，则更新记录数</li></ul></li></ul><a id="more"></a><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record = nums[<span class="number">0</span>],count = <span class="number">1</span>,i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i != nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == record)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count;</span><br><span class="line">                <span class="keyword">if</span>(!count)</span><br><span class="line">                &#123;</span><br><span class="line">                    record = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-169-多数元素&quot;&gt;&lt;a href=&quot;#LeetCode-169-多数元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-169.多数元素&quot;&gt;&lt;/a&gt;LeetCode-169.多数元素&lt;/h2&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;h3 id=&quot;示例-1&quot;&gt;&lt;a href=&quot;#示例-1&quot; class=&quot;headerlink&quot; title=&quot;示例 1&quot;&gt;&lt;/a&gt;示例 1&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;示例-2&quot;&gt;&lt;a href=&quot;#示例-2&quot; class=&quot;headerlink&quot; title=&quot;示例 2&quot;&gt;&lt;/a&gt;示例 2&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,2,1,1,1,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;因为多数元素数量大于n/2，所以我们只需要统计投票数：（因为只有众数的投票数不为0）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果当前数字和记录数一致，投票加1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果当前数字和记录数不一致，投票减1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果减一后投票数为0，则更新记录数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>批判性思维-阅读笔记</title>
    <link href="http://yoursite.com/2020/05/03/CRITICAL-THINKING/"/>
    <id>http://yoursite.com/2020/05/03/CRITICAL-THINKING/</id>
    <published>2020-05-03T03:39:02.000Z</published>
    <updated>2020-05-12T09:21:40.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批判性思维基础"><a href="#批判性思维基础" class="headerlink" title="批判性思维基础"></a>批判性思维基础</h1><h2 id="什么是批判性思维"><a href="#什么是批判性思维" class="headerlink" title="什么是批判性思维"></a>什么是批判性思维</h2><ul><li>但归结起来，批判性思维就是指审慎地运用推理去断定一个断言是否为真</li><li>批判性思维技能列表：<ul><li>判断信息是否恰当</li><li>区分理性的断言与情感的断言</li><li>区别事实与观点</li><li>识别证据的不足</li><li>洞察他人论证的陷阱和漏洞</li><li>独立分析数据或信息</li><li>识别论证的逻辑错误</li><li>发现信息和其来源之间的联系</li><li>处理矛盾的、不充分的、模糊的信息</li><li>基于数据而不是观点建立令人信服的论证</li><li>选择支持力强的数据</li><li>避免言过其实的结论</li><li>识别证据的漏洞并建议收集其他信息</li><li>知道问题往往没有明确答案或唯一解决办法</li><li>提出替代方案并在决策时予以考虑</li><li>采取行动时考虑所有利益相关的主体</li><li>清楚地表达论证及其语境</li><li>精准地运用证据为论证辩护</li><li>符合逻辑地组织复杂的论证</li><li>展开论证时避免无关因素</li><li>有序地呈现增强说服力的证据</li></ul></li></ul><a id="more"></a><h2 id="基本概念：断言、论题和论证"><a href="#基本概念：断言、论题和论证" class="headerlink" title="基本概念：断言、论题和论证"></a>基本概念：断言、论题和论证</h2><ul><li>构成批判性思维的基本要素是断言（claims），论题（issues）和论证（arguments）</li><li>断言：陈述（statements）或断言（我们在相同的意义上使用这两个概念）区分为真的或假的</li><li>论题：当我们对一个断言进行审查的时候，即当我们探究断言之真假时，我们就提出了一个论题。批判性思维主要关注这样一类断言：被论证支持或反驳的论题。“论题”实际上就是“问题”（question），我们可以互换地使用这两个概念。“问题”就是指某个特定的断言是否真实。解决问题就是对断言的真假做出回答。</li><li>论证：一旦我们清楚了论题是什么，下一步就是评价支持或反驳这个断言的论证，并断定论题的真假。论证是批判性思维的最重要因素，尽管论证可以很复杂，但究其实质，论证的概念很简单：我们从事论证是为了给一个断言的真提供理由。论证由前提（premise）和结论（conclusion）构成。前提是为另一个断言提供理由的断言，被前提支持的断言是论证的结论。</li><li>我们将会发现，在实际生活的境况中，重要而且往往困难的是准确识别到底什么是有问题的断言，即论题到底是什么。我们识别论题的困难是由多种原因导致的，从有意混淆到含混的术语以及思想本身的混乱等。</li><li>对于如何审查一个断言而言，关键是知道如何支持或反驳这个断言的真假。如果我们不知道如何确定断言的真假，对于如何通过论证支持或反驳断言我们就束手无策。</li><li>如果无从知道一个断言何时为真何时为假，谈论断言的真假就没有意义。换句话说，只有针对清楚地表达意思的断言、一个合乎语法的断言，我们才能谈论它的真假。</li><li>好论证的标准有待进一步阐述，但目前需要指出两点：第一，支持结论的前提必须是真的。一个论证的前提的真往往需要新的论证来支持，这样，一个论证的前提就是新论证的结论；第二，前提和结论必须是相关的。相关的要求是指：前提为真的确能增加结论为真的可能性。</li></ul><h2 id="论证与解释"><a href="#论证与解释" class="headerlink" title="论证与解释"></a>论证与解释</h2><ul><li>1.洛勒头疼因为他脑袋里有钉子。</li><li>2.洛勒该上医疗保险因为他不能支付医疗费。</li><li>这两个表达都是“X，因为Y”。论证包含两部分，其中一部分（前提）是据以认为另一部分（结论）为真的理由。表达2是论证，因为洛勒不能支付医疗费是据以认为他该上医疗保险的理由。与之相对，表达1中，洛勒脑袋里有钉子不是据以认为他头疼的理由。对洛勒而言，不需要理由他也能知道自己头疼。“他脑袋里有钉子”不是证明洛勒头疼的理由，而是表明引起他头疼的原因。</li><li>从根本上说，论证是为了支持或证明结论，而解释是为了指明某事物的原因、它如何运作或它是如何制作的等。论证一条狗身上有跳蚤和解释狗身上有跳蚤的原因是不同的思维，论证暴力犯罪的增加也不同于解释犯罪率升高的原因。提出对荷兰榆树病的解释也不同于证明该解释是正确的。尽管解释和论证容易被混淆，但这是两种不同的思维。</li><li>就像“农民不需要干旱，国家森林不需要修路”，这样的表达是要告诉大家：对于国家森林，修路不是好事。但这只是从不利的角度来描述在国家森林边修路，这样的表达不是论证。有人把论证界定为说服某人接受某种观点，但这并不正确。论证是证明或支持某结论，而说服某人是赢得他同意你的观点。从逻辑的观点看，论证和说服是不同的思维。的确，试图说服别人时往往要运用论证。但论证并不总是用于说服，说服往往也不一定借助于论证。</li></ul><h2 id="两种好的论证"><a href="#两种好的论证" class="headerlink" title="两种好的论证"></a>两种好的论证</h2><ul><li>逻辑学家将好的论证分为两类：好的演绎论证和好的非演绎论证。</li><li>好的演绎论证（deductive arguments）被称为“有效的”。一个论证是有效的，指该论证不可能出现前提为真而结论为假的情形。</li><li>好的非演绎论证（inductive arguments）的前提并不证明其结论。非演绎论证的前提支持结论。也就是说，如果非演绎论证的前提为真，那么就提高了其结论为真的可能性。</li></ul><h2 id="识别论证"><a href="#识别论证" class="headerlink" title="识别论证"></a>识别论证</h2><ul><li>无论是演绎论证还是非演绎论证，都由两部分构成。其中一个部分提供让我们相信另一部分的理由。论证的根本标识词为“所以”之类的词语。构成论证至少要有两个断言，而且各断言间（或明示的或暗示的）以“所以”等词语连接。</li><li>论证的提示词是识别论证的指南。除了“所以”之外，论证之结论的提示词还有：<ul><li>由此得出……</li><li>这表明……</li><li>于是……</li><li>因此……</li><li>结果……</li><li>我的结论是……</li></ul></li><li>论证的前提也有其指示词，如：<ul><li>既然……</li><li>因为……</li><li>由于……</li><li>依据……</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>断言：表达意见或信念的陈述；真或假。</li><li>论证：由断言按一定结构形成的两部分，其中一部分（前提）为另一部分（结论）的真提供理由。</li><li>论题/问题：因探究问题而提出的断言。</li><li>有效的演绎论证：该类论证的前提真意味着其结论一定真。</li><li>强的非演绎论证：前提为结论提供的支持越多，非演绎论证越强。</li><li>价值判断：表达对事物评价的断言。</li><li>道德价值判断：表达对事物道德或伦理评价的断言。</li><li>修辞：具有心理上的说服力，但并不增加逻辑力量的语言。</li><li>影响批判性思维的错误观念：<ul><li>假定所有的价值判断都是主观的。</li><li>混淆论证和解释。</li><li>混淆论证和说服。</li><li>混淆修辞与逻辑，误以为心理说服力越强的论证逻辑力量越强。</li></ul></li></ul><h1 id="两种推理（论证）"><a href="#两种推理（论证）" class="headerlink" title="两种推理（论证）"></a>两种推理（论证）</h1><h2 id="论证：基本特征"><a href="#论证：基本特征" class="headerlink" title="论证：基本特征"></a>论证：基本特征</h2><ul><li>结论指示词：论证中运用下列语词，通常表示就已经给出的前提将要得出结论（“……”表示结论）<ul><li>于是……</li><li>结果……</li><li>所以……</li><li>因此……</li><li>这表明……</li><li>这蕴涵……</li><li>这显示……</li><li>这证明……</li></ul></li><li>前提指示词：论证中运用下列语词，通常是引入前提。这些词语往往也在给出的结论之后出现。“……”代表实际论证中的前提。<ul><li>既然……</li><li>因为……</li><li>由于……</li><li>依据……</li></ul></li></ul><h2 id="两种论证"><a href="#两种论证" class="headerlink" title="两种论证"></a>两种论证</h2><ul><li>演绎论证：对于一个演绎论证，如果其前提为真，则证明了其结论。乍看起来这很简单。但为了阐明问题，我们先学习演绎逻辑的基本概念：有效。当一个论证满足条件：当其前提为真时，其结论不可能为假，这个论证就是有效的。</li><li>非演绎论证：与演绎论证的前提证明结论不同，非演绎论证的前提并不证明结论，非演绎论证的前提支持结论。</li></ul><h2 id="演绎，非演绎和未表达前提"><a href="#演绎，非演绎和未表达前提" class="headerlink" title="演绎，非演绎和未表达前提"></a>演绎，非演绎和未表达前提</h2><ul><li>实际生活中的论证往往包含未表达前提。通过不同的方式补充未表达前提，可以形成非演绎论证，也可以形成演绎论证。通常上下文和语境能帮助我们理解论证者的意图，但也有时候语境不能帮助我们解决问题。后一种情形下，通过考虑各种因素，所补充的未表达前提至少应该是可信的。</li></ul><h2 id="理解论证的技术"><a href="#理解论证的技术" class="headerlink" title="理解论证的技术"></a>理解论证的技术</h2><ul><li>为了理解论证，首先要发现结论或某语篇的主要观点。其次，要找出为得出结论而陈述的种种理由，即寻找前提。接着，再发现针对前提的论证（如果有）。为了展开上述步骤，需要在口头表达或书面论证中准确发现前提或结论并且理解这些断言之间的相互联系——即论证的结构。</li></ul><h2 id="评估论证"><a href="#评估论证" class="headerlink" title="评估论证"></a>评估论证</h2><ul><li>批判性思维要求我们评估论证。评估论证分为两个方面：逻辑和真假</li><li>一方面我们从逻辑的角度评估论证：该论证是在证明还是在支持其结论？这是一个有效的演绎论证还是较强的非演绎论证？从理论上说，到目前为止，你已能明白这些问题在表达什么意思；随着深入学习本书，你就能针对实际论证回答这些问题。</li><li>另一方面我们从真假的角度评估论证。论证的前提确实为真吗？在第4章中，我们将解释，就像对于缺乏可靠信息来源的前提一样，对于与背景信息以及其他可靠信息相冲突的前提，我们最好提出质疑。在第5章、第6章和第7章中，我们将告诫大家避免落入修辞或心理的误区。在第3章中，我们要提请注意，在接受前提之前必须弄清其表达的准确含义。通常，确定前提的真假依赖于知识、经验、冷静的头脑和乐于深入调查。</li></ul><h2 id="总结（推理-论证）"><a href="#总结（推理-论证）" class="headerlink" title="总结（推理==论证）"></a>总结（推理==论证）</h2><ul><li>论证由前提和结论组成，推理的前提可以不止一个。</li><li>同一个命题可以是一个推理的前提，又是另一个推理的结论。</li><li>推理分为两种：演绎论证和非演绎论证。</li><li>如果演绎推理是可靠的，就可以证明其结论为真。</li><li>可靠的推理是前提为真的有效推理。</li><li>有效的推理不会出现前提为真而结论为假的可能。</li><li>非演绎推理不是证明结论，而是为结论提供支持。</li><li>支持程度有高低之分：支持程度决定于前提使得结论为真的可能性的高低。</li><li>支持程度高的非演绎推理较强，支持程度低的非演绎推理较弱。</li><li>演绎推理和非演绎推理都可能含有未表达的前提。</li><li>一个推理是演绎推理还是非演绎推理可能决定于未表达的前提到底是什么。</li><li>如果难以把握文章中的论证，试着刻画其论证结构图。</li></ul><h1 id="清晰地思维、批判性思维与清晰的写作"><a href="#清晰地思维、批判性思维与清晰的写作" class="headerlink" title="清晰地思维、批判性思维与清晰的写作"></a>清晰地思维、批判性思维与清晰的写作</h1><ul><li>尽管多种因素都可能导致表达的含混不清，但其中最主要的原因可以归结为如下四点：过度模糊、歧义、过于抽象、未定义术语。本章将在深入探讨模糊、歧义和抽象后阐述定义。</li><li>写作的时候也常常需要进行批判性思维，在论文写作时尤其如此。在论文中，需要表达对论题的立场，还要提供支持该立场的论证。优秀的论文通常由四部分构成：陈述论题、表明对论题所持的立场、提供支持立场的论证、对支持相反立场的论证展开反驳。显然，如果论文中的陈述含混不清，当然会削弱论证的力量。本章中，我们还将具体指导如何清晰地写作。</li></ul><h2 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h2><ul><li>无论是思维还是写作中，最常见的含混是模糊（vaguness）。仔细探究起来，模糊的概念相当复杂。过去几十年中哲学家们就集中对这个概念展开了深入研究。不过就应用的层面来讲，不难把握这个概念。词语或短语的模糊是指：与该词语或短语相对应的对象是不明确的。<ul><li>“秃头”就是模糊的。帕里斯·希尔顿不是秃头及帕特里克·斯图尔特是秃头都是无可争议的，但对于生活中另外很多人是否秃头就难有定论。“秃头”概念是否可以指上述两类极端人群之间的人，就是不明确的。正因如此，“秃头”是模糊概念。</li></ul></li><li>模糊的程度各不相同。至于何等模糊度是可接受的，除了借助于适度的注意和常识以外并没有一成不变的答案。但可以这样认定：如果某断言不至于因为模糊而不能恰当地表达有用的信息，其模糊度就是可接受的。<ul><li>在上面说到的指路的例子中，如果其指引足以让我们顺利找到目的地，指引中的模糊度就是可接受的。如果政治人物在其税收计划中足够清楚地说明该计划将如何实施，我们就不能抱怨它的模糊性。但如果在表达中夹杂着过度的模糊以至于我们难以甚至不能理解其中的断言，具有批判性思维能力的人就会要求表达者负责澄清。</li></ul></li></ul><h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><ul><li>具有多重含义的语词、短语或句子被称为歧义（ambiguity）。<ul><li>“保罗兑付了现金”指别人给了保罗现金还是保罗给了别人现金呢？两者都有可能。“杰西卡在租房子”可以指杰西卡把房子租给别人，也可以指别人把房子租给杰西卡。周五下午，珍妮弗从座位上站起来说：“我这儿的工作已经做完了。”珍妮弗的意思可能指完成了手中项目的工作报告，也可能指她完成了一周的工作可以去度周末了，还有可能指她已经厌倦了这儿的工作打算离开这家公司。如果你访问网站，不难发现各种引人发笑的歧义。对于引人发笑的歧义，通常我们知晓表达者利用歧义的意图。</li></ul></li><li>歧义的最常见情形是语义歧义（semantic ambiguity），即表达断言的语句中含有歧义的语词或短语.例：<ul><li>Jessica is cold.</li><li>Aunt Delia never used glasses.</li><li>例1可能在描述杰西卡的体温低，也可能在描绘杰西卡的个性冷漠；例2可能在说德里亚姑姑的视力好，也可能在说德里亚姑姑直接用瓶子而不用杯子喝啤酒。通过用不带歧义的语词来替换产生歧义的语词就可以消除语句中的歧义，如将例2中的”glasses”替换为”eyeglasses”（眼镜）就可以消除该句的歧义。</li></ul></li><li>组合歧义（grouping ambiguity）是一种特殊的语义歧义。当不能明确区分一个语词指集合体，还是指构成该集合体的个别成员时，就出现了组合歧义。<ul><li>语句“秘书挣的钱比医生多”中，如果“秘书”和“医生”分别指这两类从职人员的总体，这个句子或许是真的，因为从事秘书工作的人远比从事医生工作的人多；但若这两个语词分别指个体，这句话显然是假的。</li><li>骑越野摩托车的人或许为自己的癖好辩护说：“割草机比越野摩托车制造的污染更多。”因为这个表达中存在歧义，它既可以被解释为真的，也可以被解释为假的。作为总体来说，割草机制造的污染的确较多，因为割草机的数量远多于越野摩托车；但逐个进行比较，显然是越野摩托车制造的污染更多（毋庸讳言，越野摩托车还制造了大量恼人的噪音）。</li><li>对组合歧义进一步分析，有两种源于组合歧义的常见谬误：分解谬误与合成谬误。从群体具有某特征推导出群体的每个成员也一定具有该特征，就犯了分解谬误（fallacyof division）。<ul><li>1973年的美国棒球联赛中，迈阿密海豚队获得了冠军，该队还参加了1974年的超级碗比赛。迈阿密海豚队是联盟该年度最优秀的球队乃不争的事实，由此就可以推出该队的队员就是联盟最好的队员吗？即由此可得出鲍勃·格里耶瑟是最好的四分卫、拉里·克斯卡是最好的后卫、默克里·莫里斯是最好的接球手吗？当然不能。整体的特征未必为构成整体的各独立部分所具有。正如圆形的建筑物不必由圆砖块建筑而成。</li></ul></li><li>从另一个方向去思考，即由成员都具有某特征为前提推出所有成员构成的整体也一定具有该特征，就犯了合成谬误（fallacy of composition）。<ul><li>例如，在民意测验中，众议院的每个议员都获得较高的评价，但如果由此推定民意测验也会给众议院较高评价就是错误的，因为通常在相同的民意测验中，众议院得到的评价较低。人们对部分的评价和对整体的评价未必相同。正如人们可以用方形砖块建造圆形建筑物。在专栏中你会看到更多关于分解谬误与合成谬误的实例。</li></ul></li></ul></li><li>语形歧义：一个句子的语法结构可以作两种以上的解释时，这个句子就含有语形歧义（syntactic ambiguity）。<ul><li>“去加拿大旅行，须携带出生证或驾照和其他附照片的身份证明。”这句话在说跨越美加边境到底有什么要求？按照一种解释，除携带出生证或驾照之外，还得携带其他附照片的身份证明；按照另一种解释，携带其他身份证明就不是必须的。下面用括号分别标出两种不同的解释：<ul><li>[须携带出生证或驾照]和[其他附照片的身份证明]</li><li>[须携带出生证]或[驾照和其他附照片的身份证明]</li></ul></li></ul></li></ul><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li>与模糊及歧义密切相关的一个概念就是抽象（generality），抽象的表达也会引起含混不清。我们已经知道“孩子”是模糊概念，因为我们不知道“孩子”和“非孩子”的界线到底在哪里。“孩子”也是歧义的，因为它既可以指未成年人，又可以指婴儿。这个概念也是抽象的，因为它既指男孩，又指女孩。大致说来，一个断言表达的内容越不具体，该断言就越抽象。就具体语词或短语X而言，”X”所指的范围越广，X越抽象。“摩尔有只狗”比“摩尔有只澳达猎犬”抽象，而更抽象的是“摩尔有宠物”。</li><li>模糊、歧义、抽象这些相互联系的有碍清晰思维的诸多概念，可能会让你觉得眼花缭乱。但实际上，重要的是发现问题，即识别表达或断言中哪些是不清晰的以及寻求如何解释它。至于给所发现的问题一个什么样的名称（到底是模糊、歧义还是抽象）并不重要。例如：如果有人随意地使用语词“战争”，你最好的反应就是问对方“你所说的‘战争’指什么”。</li></ul><h2 id="定义术语"><a href="#定义术语" class="headerlink" title="定义术语"></a>定义术语</h2><ul><li><p>定义的目的：定义的目的中最值得注意的有四种。</p><ul><li>告知词语的日常意义。为了弄清语词的意义，我们往往借助于字典。字典上所给的就是词典定义（lexical definition）。它告诉我们语词的通常含义，如“绢毛猴，名词，南美森林中的小猴，绒猴家族，色彩明亮，脸和脖子周围毛发丛生”。</li><li>约定在特定语境下的语词意义。为实现该目的而做出的定义叫约定定义（stipulative definition）。如，“这种情形下，‘桌面’指打开操作系统时显示屏所显示的含有回收站的状态”。也可以通过约定定义来给新发明的语词指派意义。2005年，在新开播的电视节目《科尔伯特报告》中，斯蒂芬·科尔伯特发明了新词汇”truthiness”。该词的约定意义为：未经证据、逻辑、理智或事实等的检验，仅凭直觉或“本能”被认定为真的事物。</li><li>减轻模糊、抽象或消除歧义。“本合同中，’dollars’指加元，而不是指美元或澳元。”为实现此种意图的定义被称为精确定义（precising definition）。</li><li>用于说服。这种定义为了提供语词的日常意义或各方约定的意义，因而不是真正意义上的定义，它被称为说服定义或修辞定义（persuasive or rhetoricaldefinitions）。尽管这种定义也和其他定义一样被列在定义的名录中，但值得注意的是，这类“定义”不仅仅包含着语言方面的信息，它的意图是影响人们的信念和态度。<ul><li>如果一个开明者试图把“保守者”“定义”为：认为生活的重心就是挣钱和盘剥穷人的刻板守旧、心胸狭窄的伪君子。这并不是为了澄清“保守”的意思，而是为了抨击保守者。这样的修辞定义往往借助于语词的情感意义（e-motive meaning）。有的人更愿意称之为修辞力（rhetorical force）。这样的意义包含着对语词所指对象的正面或负面评价。经历了多年对伊拉克的战争之后，美国民众中有的希望“带他们回家以支持部队”，有的希望“匆忙离开”。这两种人都表达了从伊拉克撤回美军的相同愿望，但不同表达的情感意义不同，成语“言外之意”就是描述与语词相关的情感意义的。前面说过的把“堕胎”定义为“谋杀未出生的孩子”就是常被引用的该类型的定义。</li></ul></li></ul></li><li><p>定义的种类：</p><ul><li>实指定义（ostensive definition）：即通过指明语词所指的对象或识别语词所指对象的典型例子来下定义。如：“我用‘圣典’指圣经、古兰经这样的文本”、“鼠标就是这个（展示实物）带有按键的东西”。</li><li>同义词定义（definition by synonym）：即给出与被定义术语具有相同意义的语词或短语。如：“‘吹毛求疵’与‘挑剔’意思相同”“‘悸动’意味着‘跳动’”。</li><li>分析定义（analytical definition）：确定被定义术语所指对象的必要特征从而明确术语所指的对象。这样的定义通常的形式是明确属和种。例如：“俄式茶壶是俄罗斯人用于烧水泡茶的壶”、“猫鼬是食蛇的与麝猫有亲缘关系的雪貂大小的哺乳动物”。字典上的定义大都是分析定义。</li></ul></li><li>定义的注意事项：<ul><li>首先，不能通过定义使论辩的任何一方处于不利境地。这里只需说明：如果对于关键术语的定义论辩双方没有形成共识，任何一方都不能仅通过对己有利的定义来赢得辩论。人们应该站在中立的立场来下定义。</li><li>其次，定义必须是清晰的。定义是用来澄清歧见而不是为了混淆视听。所以必须用简单清楚的语言来表述定义。如果用比被定义语言更含混的语言来下定义，不可能达成预期的目的。定义要清晰就要求尽可能避免在定义中使用诉求情感的语言。</li></ul></li></ul><h2 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h2><ul><li>论文通常由四部分组成：<ul><li>陈述论题</li><li>表明对论题所持的立场</li><li>提供支持立场的论证</li><li>对支持相反立场的论证展开反驳</li></ul></li><li>论文写作要点：<ul><li>论文的开端要通过描述论题的重要性和趣味性来介绍论题，这往往并不容易，纵然你自己未必对该论题感兴趣也要激发读者对它的兴趣。但你的陈述必须是中立的，即不能把你对论题的立场表述为唯一正确的立场。这会让读者怀疑你将展开的论证会成为劝说他的负担。</li><li>你对论题所持的立场必须是明确的，而且要尽量做到简明扼要。清晰地陈述论题会为识别你的立场提供捷径。</li><li>支持立场的论证要尽量言简意赅，但比简洁更重要的是清楚。毕竟这部分是论文的心脏。陈述的理由必须明显相关，这些理由如果不是显而易见的就需要其他论证的支持。</li><li>如果对论题的相反立场有著名的论证，你要列举这样的论证，并提供理由证明它缺乏说服力。你可以指出其前提不必为真，或该前提不能支持其结论。</li></ul></li><li>写作指导：<ul><li>中心突出。文章的开篇就要陈述论题、表明立场，但这不等于用呆板的语言罗列清单：“本文将论证X、Y和Z”，然后逐一论证所列各项，最后总结：“本文论证了X、Y和Z”。陈词滥调的文风不可能引人入胜。“你会因为母亲的猫而减少该被继承的遗产吗？”比“本文将讨论动物继承其主人遗产的问题”能让读者更加饶有兴味地继续关注你的论题或立场。</li><li>紧扣主题。论文中所表达的要点要与讨论的主题密切相连，各要点只能服务于两个目的：<ul><li>（a）对所持立场的说明、解释、澄清、阐述；</li><li>（b）对持相反观点者的回应。要删除无关的论述和没有针对性的思想。</li></ul></li><li>按照一定的逻辑顺序谋篇布局。在你为支持自己的观点举例或澄清的时候，要让读者明白你到底在做什么。要让读者明白你给出的语句与你的最终目的之间是什么关系。如果读者在通读你的文章后依然不知所云，抓不住你的要旨，说明你没有适当地组织材料。这类洋洋洒洒的文章或许类似法国哲人的大作，但作为议论文它是不合格的。</li><li>结构完整。文章的结构要力求完整：充分支持自己的观点，反驳已知的对立观点，并对可能反驳自己的意见进行回应。许多论题都不可能仅在一篇论文中作穷尽的论述，关键在于要集中探讨论题的某一方面，从而完整地论述它。所以，越明确地限定话题，越容易完整地驾驭它。<ul><li>可以从不同层面来理解结构完整——句子要完整，段落要完整（每一段落要紧扣一个观点），整篇文章要有结论。值得注意的是，形成文章的结论和总结文章不是一回事。短篇论文并不需要总结。</li></ul></li></ul></li><li>如何练习写作：<ul><li>初步组织材料后，列出写作提纲。然后，确认提纲是否合乎逻辑、文中逐词逐句是否都适合提纲的需要。有的作者在着手之前就先拟非正式的提纲。我们的建议是：先要识别论题和你的立场，文章开篇就要表明二者。</li><li>修改你的作品。修改是让文章优秀的秘诀，即使是专栏作家们也需要不断修改他们的作品。除非你比职业作家更具天赋，对自己的文章要修改、修改、再修改。不要只打算二易其稿或三易其稿，要准备不厌其烦、千推万敲。</li><li>如果有人读完你的文章后提出批评，按照他的意见修改。</li><li>如果在语法或拼写上有困难，大声朗读文章可以帮你发现默读时错过的问题。</li><li>对自己的文章完全满意后，把它搁在一边，隔段时间再进一步修改。</li></ul></li><li><p>写作中好的文风：</p><ul><li>避免陈词滥调</li><li>尽量具体</li><li>不要抽象</li><li>避免被动语句</li><li>不要啰嗦</li><li>夸大其词远不如谨慎陈述</li><li>保证主语与谓语的一致</li><li>为什么运用修辞手段</li><li>无论多么相关，插入的定论都不是必需的</li><li></li></ul></li><li><p>论文写作的误区：</p><ul><li>废话连篇：不是直接切入论题，而是大量介绍、评价论题、谈论该论题一直困扰着世世代代的思想者以及对于该论题如何众说纷纭等。</li><li>信口开河：写作时不注意组织自己的思想，想到哪儿写到哪儿。</li><li>未经思考：不对论题作深入和详细的探讨而写出对论题的第一反应。</li><li>不得要领：写作时拐弯抹角。需要评价骑自行车的好处时，大谈自行车的历史；需要介绍自行车的历史时，却通过历史评述骑自行车的益处。</li><li>让读者领会：期望读者从作者不合逻辑的推论、转移话题的论述和无关的旁敲侧击中领会作者的意图。</li></ul></li><li><p>有说服力的写作：</p><ul><li>集中讨论与对手就论题产生的分歧，而不是只关注个人观点。</li><li>在反驳对手的观点时不能出言不逊。不能说对手的论证是荒谬、可笑的。</li><li>对于对手的好论证，要坦率承认。</li><li>在受限的时间和条件下，把注意力集中于最主要的环节。不要过分关心枝节上的分歧。</li><li>先陈述强有力的论证。</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>批判性思维的前提是清晰的思维</li><li>引起断言及论证的含混不清有诸多原因，但主要有模糊、歧义和抽象</li><li>模糊有程度之分，关键是相对于特定目的而言不能太模糊</li><li>歧义指一个语句有多种解释，而且不能断明其中哪种解释是正确的</li><li>歧义主要分为语义歧义、语形歧义、组合歧义和指代歧义</li><li>过于抽象的断言指缺乏足够的信息来界定它到底可应用于哪些对象</li><li>无论是减少模糊、消除歧义还是运用新词汇或旧词新用，定义都能助一臂之力</li><li>定义主要分为同义词定义、实指定义、分析定义</li><li>修辞定义并不是为了澄清意义，而是为了表明或影响态度</li><li>修辞定义借助术语的修辞力（情感意义）来实现目的</li><li>论文写作是批判性思维能力的运用和体现，要训练和掌握论文写作的技能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;批判性思维基础&quot;&gt;&lt;a href=&quot;#批判性思维基础&quot; class=&quot;headerlink&quot; title=&quot;批判性思维基础&quot;&gt;&lt;/a&gt;批判性思维基础&lt;/h1&gt;&lt;h2 id=&quot;什么是批判性思维&quot;&gt;&lt;a href=&quot;#什么是批判性思维&quot; class=&quot;headerlink&quot; title=&quot;什么是批判性思维&quot;&gt;&lt;/a&gt;什么是批判性思维&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;但归结起来，批判性思维就是指审慎地运用推理去断定一个断言是否为真&lt;/li&gt;
&lt;li&gt;批判性思维技能列表：&lt;ul&gt;
&lt;li&gt;判断信息是否恰当&lt;/li&gt;
&lt;li&gt;区分理性的断言与情感的断言&lt;/li&gt;
&lt;li&gt;区别事实与观点&lt;/li&gt;
&lt;li&gt;识别证据的不足&lt;/li&gt;
&lt;li&gt;洞察他人论证的陷阱和漏洞&lt;/li&gt;
&lt;li&gt;独立分析数据或信息&lt;/li&gt;
&lt;li&gt;识别论证的逻辑错误&lt;/li&gt;
&lt;li&gt;发现信息和其来源之间的联系&lt;/li&gt;
&lt;li&gt;处理矛盾的、不充分的、模糊的信息&lt;/li&gt;
&lt;li&gt;基于数据而不是观点建立令人信服的论证&lt;/li&gt;
&lt;li&gt;选择支持力强的数据&lt;/li&gt;
&lt;li&gt;避免言过其实的结论&lt;/li&gt;
&lt;li&gt;识别证据的漏洞并建议收集其他信息&lt;/li&gt;
&lt;li&gt;知道问题往往没有明确答案或唯一解决办法&lt;/li&gt;
&lt;li&gt;提出替代方案并在决策时予以考虑&lt;/li&gt;
&lt;li&gt;采取行动时考虑所有利益相关的主体&lt;/li&gt;
&lt;li&gt;清楚地表达论证及其语境&lt;/li&gt;
&lt;li&gt;精准地运用证据为论证辩护&lt;/li&gt;
&lt;li&gt;符合逻辑地组织复杂的论证&lt;/li&gt;
&lt;li&gt;展开论证时避免无关因素&lt;/li&gt;
&lt;li&gt;有序地呈现增强说服力的证据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="阅读笔记" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="批判思维" scheme="http://yoursite.com/tags/%E6%89%B9%E5%88%A4%E6%80%9D%E7%BB%B4/"/>
    
      <category term="逻辑思维" scheme="http://yoursite.com/tags/%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
