<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-22T13:42:22.155Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Programming in Lua：Chapter 1.Getting Started</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-1/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-1/</id>
    <published>2020-06-22T13:38:43.000Z</published>
    <updated>2020-06-22T13:42:22.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-1-Getting-Started"><a href="#Programming-in-Lua：Chapter-1-Getting-Started" class="headerlink" title="Programming in Lua：Chapter 1. Getting Started"></a>Programming in Lua：Chapter 1. Getting Started</h2><ul><li><p>Lua使用块（Chunks）作为代码执行的单位，一个Chunks可以是交互模式中的一行代码或者是一个函数</p></li><li><p>使用Chunks的方法：</p><ul><li>在交互模式中，可以使用<code>% lua -i prog​</code></li><li>或者可以使用dofile()导入别的lua文件</li></ul></li><li><p>Lua中的标识符可以是字母，数字和下划线开头，不能以数字开头</p></li><li><p>以下是Lua中的保留字，不能作为标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and      break     do        else      elseif</span><br><span class="line">end      false     for       function  goto</span><br><span class="line">if       in        local     nil       not</span><br><span class="line">or       repeat    return    then      true</span><br><span class="line">until    while</span><br></pre></td></tr></table></figure></li><li><p>注释的两种方式：</p><ul><li>以<code>--</code>开始的那一整行</li><li>以<code>--[[</code>开始直至<code>]]</code>或<code>--]]</code>结束的一整段</li></ul></li><li><p>Coding的语法喝JavaScript一致，即不需要强制添加分号，但是可以使用分号作为分隔符</p></li><li><p>全局变量不需要声明，访问未初始化的全局变量不会报错，会得到一个nil（null）值</p></li><li><p>声明但未初始化的变量和值为nil的变量存储在相同区域，不会被GC管理</p></li><li><p>Lua有8种基本类型：</p><ul><li>nil（空类型）：对全局变量分配nil使gc回收它的内存</li><li>boolean（true/false）:<ul><li>在Lua中任何值都可以表示条件，false和nil都视为false，其他值都视为true。</li><li><strong>注意数字0和空字符串也视为true！！！</strong></li><li>逻辑运算符：所有的值都会想条件控制一样被划分成true和false<ul><li>and（与操作）：如果第一个操作数为false，则返回第一个操作数，否则返回第二个操作数 （假如第一个操作数为假，那么我们返回这个操作数就可以判假，反之我们需要判断第二个操作数）</li><li>or（或操作） ：如果第一个操作数为true,  则返回第一个操作数，否则返回第二个操作数（假如第一个操作数为真，那么我们返回这个操作数就可以判真，反之我们需要判断第二个操作数）</li><li>not（非操作）：返回一个boolean值，这个值为操作数的boolean值取反</li><li>and 和 or都满足短路原则</li><li>赋默认值 x = x or y (假如x未定义，则会把默认值y赋给x)</li><li>三目运算符 a ? b : c == a and b or c （当且仅当b不为false时）</li></ul></li></ul></li><li>number (浮点数)</li><li>string （字符串）</li><li>userdata （用户数据 io.stdin）：允许将任意C数据结构存储在Lua中</li><li>function (函数)</li><li>table (数据表)</li><li>thread （线程）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-1-Getting-Started&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-1-Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Prog
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第一章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 3.Numbers</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-3/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-3/</id>
    <published>2020-06-22T13:38:37.000Z</published>
    <updated>2020-06-22T13:42:32.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-3-Numbers"><a href="#Programming-in-Lua：Chapter-3-Numbers" class="headerlink" title="Programming in Lua：Chapter 3. Numbers"></a>Programming in Lua：Chapter 3. Numbers</h2><ul><li><p>Number定义：</p><ul><li>在5.2版本之前，Lua使用双精度浮点格式表示Number</li><li>从5.3版本开始，使用64位整数（integer）和双精度浮点数（float）来表示Number</li><li>对于受限平台，可以把Lua 5.3编译成Small Lua，它可以使用32位整数和单精度浮点数</li></ul></li><li><p>Number比较：</p><ul><li>尽管具有浮点数和整数两种Number表示形式，但是它们的类型都是Number，且它们之间是可以相互转换的，例如1 == 1.0 —&gt; true</li><li>在需要区分整数和浮点数的场景，可以使用math.type()接口（整形返回integer，浮点数返回float）</li></ul></li><li><p>Number的十六进制：</p><ul><li>使用“0x”前缀来支持十六进制常量。并且支持浮点十六进制,十六进制的数保持了浮点值的所有精度，且转换速度比十进制快</li><li><p>可以使用string.format结合”%a”来表示十六进制的数</p><ul><li><p>> string.format(“%a”, 419)         —&gt; 0x1.a3p+8 </p></li><li><p>>  string.format(“%a”, 0.1)         —&gt; 0x1.999999999999ap-4</p></li></ul></li></ul></li><li><p>Number提供的算术运算：</p><ul><li>加法，减法，乘法，除法，取反，取模</li><li>整数除法: //，将结果向负无穷大舍入</li><li>幂运算：^</li></ul></li><li><p>Number的关系运算符：</p><ul><li>>  , &lt; , &gt;=, &lt;=</li><li>相等运算符: ==</li><li>不等云运算法: ~=</li></ul></li><li><p>Number的舍入函数：</p><ul><li>floor：趋向负无穷大舍入</li><li>ceil：趋向正无穷大舍入</li><li>modf：四舍五入</li></ul></li><li><p>Number的转换：</p><ul><li>整形 —》 浮点数：整形 + 0.0 就会转换成浮点数</li><li>浮点数 —》 整形： <ul><li>浮点数和 0 或运算就会转换成整形（只有在浮点数的值精确表示为整数的情况下才可以执行这种转换，即这个浮点数没有小数部分且它在整数范围之内）</li><li>math.tointeger（x），如果x不能转换成整数，返回nil</li></ul></li></ul></li><li><p>Number中的运算符优先级，从上到下（高 —》 低）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">unary operators (- # ~ not)</span><br><span class="line">* &#x2F; &#x2F;&#x2F; %</span><br><span class="line">+ -</span><br><span class="line">.. (concatentation)</span><br><span class="line">&lt;&lt; &gt;&gt; (bitwise shifts)</span><br><span class="line">&amp; (bitwise AND)</span><br><span class="line">~ (bitwise exclusive OR)</span><br><span class="line">| (bitwise OR)</span><br><span class="line">&lt; &gt; &lt;&#x3D; &gt;&#x3D; ~&#x3D; &#x3D;&#x3D;</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-3-Numbers&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-3-Numbers&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第三章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 4.Strings</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-4/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-4/</id>
    <published>2020-06-22T13:38:34.000Z</published>
    <updated>2020-06-22T13:41:04.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-4-Strings"><a href="#Programming-in-Lua：Chapter-4-Strings" class="headerlink" title="Programming in Lua：Chapter 4. Strings"></a>Programming in Lua：Chapter 4. Strings</h2><ul><li>Lua中的String是不可修改的</li><li>Lua中的String如同其他对象（table，function）一样由Lua的GC管理内存，因此我们不必担心字符串的分配和释放。</li><li>#string获取string的长度</li><li>我们可以使用串联运算符”..”来串联两个字符串（例如，”Result is “.. 3 —》 “Result is 3”），并且串联运算符不会修改已有的字符串，而是创建并返回新一个的字符串。</li><li>多行的字符串：<ul><li>“[[“和”]]”之间的多行文本会被认为是一个String</li><li>我们也可以使用”[==(=个数自定)[“和”]==]”来表示一个长字符串</li><li>换行使用“\z”</li></ul></li><li>Lua在运行时提供数字和字符串之间的自动转换，字符串数被认为是浮点数</li><li>使用tonumber显示的转换string：<ul><li>tonumber(num,jinzhi)，jinzhi可以是2~36之间的任何基数</li></ul></li><li>String 库函数：<ul><li>string.len(s) 等价与#s</li><li>string.rep(s, n) 重复字符串s，n次</li><li>string.lower(s)返回一个副本，其中的大写字母都变为小写字母</li><li>string.upper(s)返回一个副本，其中的消息字母都变为大写字母</li><li>string.sub(s，i，j)，返回s中的第i个字符到第j个字符之间（包括i，j）字符串的副本（我们也可以使用负索引，该索引从字符串的末尾开始计数）</li><li>string.char(nums,…)，它接受一个或多个整数输入，并且将每个整数转换为一个字符</li><li>string.byte(s，i)，它返回s中第i个字符的内部数字表示形式。</li><li>string.byte(s，i，j)，它返回s中第i个字符到第j个字符之间的内部数字表示形式（包括i，j）</li><li>string.format 使用规则和C中的Printf类似</li><li>string.find（stra，strb），返回strb字符串在stra中的起始和终止位置，如果不存在，则返回il</li><li>string.gsub(str，a，b)，将str中的a全部替换成b。返回两个值，第一个值是替换后生成的副本，第二个值是替换发生的次数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-4-Strings&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-4-Strings&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：C
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第四章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 6.Functions</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-6/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-6/</id>
    <published>2020-06-22T13:38:32.000Z</published>
    <updated>2020-06-22T13:42:12.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-6-Functions"><a href="#Programming-in-Lua：Chapter-6-Functions" class="headerlink" title="Programming in Lua：Chapter 6. Functions"></a>Programming in Lua：Chapter 6. Functions</h2><ul><li><p>o:foo(x) 表示调用对象o的foo函数</p></li><li><p>function 支持多个返回值，当调用位置是Table的末尾时，返回所有返回值，其他位置只返回第一个返回值，并丢弃其他的返回值</p></li><li><p>return function() 这种形式会返回所有的返回值</p></li><li><p>return (function()) 这种形式只会返回第一个返回值</p></li><li><p>function可以支持可变参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span></span><br><span class="line">        s = s + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">12</span>)) <span class="comment">--&gt; 54</span></span><br></pre></td></tr></table></figure></li><li><p>table.unpack()：获取一个列表，并且把列表中的所有元素作为结果返回</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unpack</span> <span class="params">(t, i, n)</span></span></span><br><span class="line">    i = i <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    n = n <span class="keyword">or</span> #t</span><br><span class="line">    <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> t[i], <span class="built_in">unpack</span>(t, i + <span class="number">1</span>, n)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>如果在function的尾部调用另一个function，那么这个函数调用的底层实现时goto（即不再保存当前函数的堆栈信息，也不会再返回当前函数的现场，所以尾调用不会出现程序栈溢出的问题）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\\这些都不是尾调用，因为需要处理g(x)返回的值，<span class="keyword">goto</span>是不会回来处理值的（没有保存堆栈信息），所以不能使用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> g(x) + <span class="number">1</span> <span class="comment">-- must do the addition</span></span><br><span class="line"><span class="keyword">return</span> x <span class="keyword">or</span> g(x) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line"><span class="keyword">return</span> (g(x)) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line">\\这是尾调用，尽管参数是表达式，但是不需要返回来处理返回值，可以用<span class="keyword">goto</span></span><br><span class="line"><span class="keyword">return</span> x[i].foo(x[j] + a*b, i + j)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-6-Functions&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-6-Functions&quot; class=&quot;headerlink&quot; title=&quot;Programming in L
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第六章" scheme="http://yoursite.com/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Lua：Chapter 5.Tables</title>
    <link href="http://yoursite.com/2020/06/22/Programming-in-Lua-5/"/>
    <id>http://yoursite.com/2020/06/22/Programming-in-Lua-5/</id>
    <published>2020-06-22T13:38:20.000Z</published>
    <updated>2020-06-22T13:41:42.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Programming-in-Lua：Chapter-5-Tables"><a href="#Programming-in-Lua：Chapter-5-Tables" class="headerlink" title="Programming in Lua：Chapter 5. Tables"></a>Programming in Lua：Chapter 5. Tables</h2><ul><li><p>Lua中Table可以作为数组ArrayList，集合Set，记录Dict等数据结构的载体</p></li><li><p>Table的本质是一个Dict，其关键字可以使数字，字符串等任何Lua中的值（除了nil）</p></li><li><p>Lua中的Table本质上是一个对象，可以视为一个动态分配的对象，因此程序只能操纵它们的引用（或指针）</p></li><li><p>Lua永远不会再后台隐藏或创建新的Table</p></li><li><p>创建一个Table的最简单形式就是 “a = {}”  </p></li><li><p>Table的两种构造函数形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">polyline = &#123;</span><br><span class="line">    \\列表形式</span><br><span class="line">    color=<span class="string">"blue"</span>,</span><br><span class="line">    thickness=<span class="number">2</span>,</span><br><span class="line">    npoints=<span class="number">4</span>,</span><br><span class="line">    \\记录形式</span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[1]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">0</span>&#125;, <span class="comment">-- polyline[2]</span></span><br><span class="line">    &#123;x=<span class="number">-10</span>, y=<span class="number">1</span>&#125;, <span class="comment">-- polyline[3]</span></span><br><span class="line">    &#123;x=<span class="number">0</span>, y=<span class="number">1</span>&#125; <span class="comment">-- polyline[4]</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>当我们需要一个Array时，我们仅使用带有整数键的Table</p></li><li><p>当一个Array使用连续的整数键（1…n），且中间没有中断，那么这种结构被称为序列（sequence），可以使用#来获取sequence的长度</p></li><li><p>没有内容的字段和空字段没有区别，因此<code>a = {10, 20, 30, nil, nil}</code>的长度为3</p></li><li><p>我们可以使用pairs()遍历Table中的所有键值对，遍历顺序不是固定的（可以理解为C++中的 unordered_map<T1, t2>）</T1,></p></li><li><pre><code class="lang-lua">\\这种判断包是否能使用的方法导入了6个表，效率很低zip = company and company.director and company.director.address and company.director.address.zipcode\\这种判断包能否使用的方法导入了3个表，效率高zip = (((company or {}).director or {}).address or {}).zipcode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Table的内置函数：</span><br><span class="line"></span><br><span class="line">  * Table.insert(t,loc,data)：把data插入到表t的第i个位置上，并把后续元素向后迁移</span><br><span class="line"></span><br><span class="line">  * Table.insert(t, data)：把数据插入到表t的末尾</span><br><span class="line"></span><br><span class="line">  * Table.remove(t, loc)：把表t中第i个位置的数据返回并删除，最后把后续元素向前迁移</span><br><span class="line"></span><br><span class="line">  * Table.move(t, s, e ,p)：把表t中从第s个位置（包括s）到第e个位置（包括e）之间的元素位移到第t个位置</span><br></pre></td></tr></table></figure>  //要将元素插入Table的开头  table.move(a, 1, #a, 2)  a[1] = newElement  //删除Table开头的元素  table.move(a, 2, #a, 1)  a[#a] = nil</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Programming-in-Lua：Chapter-5-Tables&quot;&gt;&lt;a href=&quot;#Programming-in-Lua：Chapter-5-Tables&quot; class=&quot;headerlink&quot; title=&quot;Programming in Lua：Cha
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://yoursite.com/categories/Lua/"/>
    
    
      <category term="第五章" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-75.颜色分类</title>
    <link href="http://yoursite.com/2020/06/21/LeetCode-75/"/>
    <id>http://yoursite.com/2020/06/21/LeetCode-75/</id>
    <published>2020-06-21T04:00:40.000Z</published>
    <updated>2020-06-21T04:33:21.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-75-颜色分类"><a href="#LeetCode-75-颜色分类" class="headerlink" title="LeetCode-75.颜色分类"></a>LeetCode-75.颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用双指针来保存0的右边界和2的左边界</li><li>开头 —&gt; nums[i] 之间都是数字0</li><li>nums[i] —&gt; nums[j]（j是当前数字的位置）之间没有数字0和2</li><li>那么当num[k] —&gt; 结尾都是数字2</li><li>那么当 j == k时，开头 —&gt; nums[i] 都为0， num[i] —&gt; num[j]之间都为1，nums[j] —&gt; nums[k]之间都为2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len;</span><br><span class="line">        <span class="keyword">for</span>(i = j = <span class="number">0</span>, len = nums.<span class="built_in">size</span>(),k = len - <span class="number">1</span>;i &lt;= k;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">                nums[j++] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[i] = nums[k];</span><br><span class="line">                nums[k--] = <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-75-颜色分类&quot;&gt;&lt;a href=&quot;#LeetCode-75-颜色分类&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-75.颜色分类&quot;&gt;&lt;/a&gt;LeetCode-75.颜色分类&lt;/h2&gt;&lt;p&gt;给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。&lt;/p&gt;
&lt;p&gt;此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;br&gt;不能使用代码库中的排序函数来解决这道题。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,0,2,1,1,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [0,0,1,1,2,2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个直观的解决方案是使用计数排序的两趟扫描算法。&lt;br&gt;首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。&lt;/li&gt;
&lt;li&gt;你能想出一个仅使用常数空间的一趟扫描算法吗？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-279.完全平方数</title>
    <link href="http://yoursite.com/2020/06/20/LeetCode-279/"/>
    <id>http://yoursite.com/2020/06/20/LeetCode-279/</id>
    <published>2020-06-20T14:26:46.000Z</published>
    <updated>2020-06-20T14:43:28.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-279-完全平方数"><a href="#LeetCode-279-完全平方数" class="headerlink" title="LeetCode-279.完全平方数"></a>LeetCode-279.完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>我们可以发现不同的数字之间的关系为$Num[i] = min(Num[i],Num[i - j^2] + 1)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(!m.count(n))</span><br><span class="line">        &#123;</span><br><span class="line">            m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!m.count(i))&#123;</span><br><span class="line">                    m[i] =  m[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(j = <span class="number">2</span>;j * j &lt;= i;++j)&#123;</span><br><span class="line">                        m[i] = <span class="built_in">min</span>(m[i], m[i - j * j] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="贪心-BFS"><a href="#贪心-BFS" class="headerlink" title="贪心+BFS"></a>贪心+BFS</h4><ul><li>上面的方法每一个数字k我们都需要遍历$\sqrt k$次，总共就是$n * k$次</li><li>实际上我们之前的遍历过程就是一颗$\sqrt k$叉树，节点所在的层数表示使用数字的个数，节点的值表示剩下的值。</li><li>我们生成树时优先生成值较小的节点，并采用BFS搜索（从上到下，从左到右）。</li><li>当我们遍历到那个值为0的节点时，返回节点所在的层数即可，并且剩下的节点都不用遍历了，从而减少计算开销</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        i = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(i * i == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;n,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ++tmp.second;</span><br><span class="line">            k = tmp.first;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="built_in">sqrt</span>(k);j &gt; <span class="number">0</span>;--j)&#123;</span><br><span class="line">                tmp.first = k - j * j;</span><br><span class="line">                <span class="keyword">if</span>(tmp.first == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> tmp.second;</span><br><span class="line">                q.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-279-完全平方数&quot;&gt;&lt;a href=&quot;#LeetCode-279-完全平方数&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-279.完全平方数&quot;&gt;&lt;/a&gt;LeetCode-279.完全平方数&lt;/h2&gt;&lt;p&gt;给定正整数 n，找到若干个完全平方数（比如 &lt;code&gt;1, 4, 9, 16, ...&lt;/code&gt;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 12 &amp;#x3D; 4 + 4 + 4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: n &amp;#x3D; 13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 13 &amp;#x3D; 4 + 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-337.打家劫舍 III</title>
    <link href="http://yoursite.com/2020/06/19/LeetCode-337/"/>
    <id>http://yoursite.com/2020/06/19/LeetCode-337/</id>
    <published>2020-06-19T12:32:09.000Z</published>
    <updated>2020-06-21T04:36:18.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-337-打家劫舍-III"><a href="#LeetCode-337-打家劫舍-III" class="headerlink" title="LeetCode-337.打家劫舍 III"></a>LeetCode-337.打家劫舍 III</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>输入: [3,2,3,null,3,null,1]          3    / \   2   3    \   \      3   1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.输入: [3,4,5,1,3,null,1]     3    / \   4   5  / \   \  1   3   1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>可以用动态规划的思想来做，如果我们把每一个节点当成根节点，那么对于该节点其最优解只有两种可能性：<ul><li>使用根节点，那么两个子节点都不使用</li><li>不使用根节点，那么两个子节点从（使用和不使用）两种方案里选择最优方案</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//方案1,比较慢，但是代码比较容易理解</span></span><br><span class="line">    <span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m.count(root))</span><br><span class="line">            <span class="keyword">return</span> m[root];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val += func(root-&gt;left-&gt;left) + func(root-&gt;left-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val += func(root-&gt;right-&gt;left) + func(root-&gt;right-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        m[root] = <span class="built_in">max</span>(val,func(root-&gt;left) + func(root-&gt;right));</span><br><span class="line">        <span class="keyword">return</span> m[root];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方案2，动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans =  func(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans[<span class="number">0</span>],ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">func</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> lc = func(root-&gt;left),rc = func(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> &#123;root-&gt;val + lc[<span class="number">1</span>] + rc[<span class="number">1</span>], <span class="built_in">max</span>(lc[<span class="number">0</span>],lc[<span class="number">1</span>]) + <span class="built_in">max</span>(rc[<span class="number">0</span>],rc[<span class="number">1</span>])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-337-打家劫舍-III&quot;&gt;&lt;a href=&quot;#LeetCode-337-打家劫舍-III&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-337.打家劫舍 III&quot;&gt;&lt;/a&gt;LeetCode-337.打家劫舍 III&lt;/h2&gt;&lt;p&gt;在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。&lt;/p&gt;
&lt;p&gt;计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;输入: [3,2,3,null,3,null,1]     
     3
    / \
   2   3
    \   \ 
     3   1
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-347.前K个高频元素</title>
    <link href="http://yoursite.com/2020/06/19/LeetCode-347/"/>
    <id>http://yoursite.com/2020/06/19/LeetCode-347/</id>
    <published>2020-06-18T16:50:09.000Z</published>
    <updated>2020-06-18T16:54:39.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode-347.前K个高频元素"></a>LeetCode-347.前K个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>我们可以使用一个HashMap在O(n)的时间复杂度里统计各个数字出现的次数</li><li>再使用一个大小为k的堆来保存频率最高的K个元素，复杂度为O(nlogK)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;m](<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)&#123; <span class="keyword">return</span> m[a] &gt; m[b];&#125;;</span><br><span class="line">        make_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m.count(num))</span><br><span class="line">                m[num] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>();iter != m.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">            heap.push_back(iter-&gt;first);</span><br><span class="line">            push_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">            <span class="keyword">if</span>(heap.<span class="built_in">size</span>() &gt; k)&#123;</span><br><span class="line">                pop_heap(heap.<span class="built_in">begin</span>(),heap.<span class="built_in">end</span>(),cmp);</span><br><span class="line">                heap.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-347-前K个高频元素&quot;&gt;&lt;a href=&quot;#LeetCode-347-前K个高频元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-347.前K个高频元素&quot;&gt;&lt;/a&gt;LeetCode-347.前K个高频元素&lt;/h2&gt;&lt;p&gt;给定一个非空的整数数组，返回其中出现频率前 k 高的元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1,1,1,2,2,3], k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: nums &amp;#x3D; [1], k &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。&lt;/li&gt;
&lt;li&gt;你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。&lt;/li&gt;
&lt;li&gt;你可以按任意顺序返回答案。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-62.不同路径</title>
    <link href="http://yoursite.com/2020/06/17/LeetCode-62/"/>
    <id>http://yoursite.com/2020/06/17/LeetCode-62/</id>
    <published>2020-06-17T11:37:00.000Z</published>
    <updated>2020-06-17T11:44:53.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode-62.不同路径"></a>LeetCode-62.不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="/2020/06/17/LeetCode-62/robot_maze.png" alt="img"></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10 ^ 9</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>非常常规的动态规划，状态转移方程如下，$F[i][j] = F[i-1][j] + F[i][j-1]$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">count</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        count[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                    count[i][j] += count[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                    count[i][j] += count[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-62-不同路径&quot;&gt;&lt;a href=&quot;#LeetCode-62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-62.不同路径&quot;&gt;&lt;/a&gt;LeetCode-62.不同路径&lt;/h2&gt;&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/17/LeetCode-62/robot_maze.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;例如，上图是一个7 x 3 的网格。有多少可能的路径？&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: m &amp;#x3D; 3, n &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从左上角开始，总共有 3 条路径可以到达右下角。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 向右 -&amp;gt; 向右 -&amp;gt; 向下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 向右 -&amp;gt; 向下 -&amp;gt; 向右&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 向下 -&amp;gt; 向右 -&amp;gt; 向右&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: m &amp;#x3D; 7, n &amp;#x3D; 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= m, n &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;题目数据保证答案小于等于 2 * 10 ^ 9&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-647.回文子串</title>
    <link href="http://yoursite.com/2020/06/16/LeetCode-647/"/>
    <id>http://yoursite.com/2020/06/16/LeetCode-647/</id>
    <published>2020-06-16T15:32:02.000Z</published>
    <updated>2020-06-16T16:16:56.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-647-回文子串"><a href="#LeetCode-647-回文子串" class="headerlink" title="LeetCode-647.回文子串"></a>LeetCode-647.回文子串</h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br><span class="line"></span><br><span class="line">输入: &quot;aaa&quot;</span><br><span class="line">输出: 6</span><br><span class="line">说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>输入的字符串长度不会超过1000。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>对于每个回文串，都有一个对称中心</li><li>这个中心可以是字符或者字符之间的空隙，假定字符串长度为N，那么就存在N*2 - 1 个位置作为中心</li><li>因此，我们遍历每个对称中心，并像两边拓展回文串，就能得到所有的回文子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,len = s.length(),ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len * <span class="number">2</span> - <span class="number">1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                j = i/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = i/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(k = i/<span class="number">2</span> + <span class="number">1</span>;j &gt;= <span class="number">0</span> &amp;&amp; k &lt; len; --j,++k,++ans)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] != s[k])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-647-回文子串&quot;&gt;&lt;a href=&quot;#LeetCode-647-回文子串&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-647.回文子串&quot;&gt;&lt;/a&gt;LeetCode-647.回文子串&lt;/h2&gt;&lt;p&gt;给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。&lt;/p&gt;
&lt;p&gt;具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abc&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 三个回文子串: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;aaa&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明: 6个回文子串: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;输入的字符串长度不会超过1000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-49.字母异位词分组</title>
    <link href="http://yoursite.com/2020/06/15/LeetCode-49/"/>
    <id>http://yoursite.com/2020/06/15/LeetCode-49/</id>
    <published>2020-06-15T03:42:36.000Z</published>
    <updated>2020-06-15T03:50:14.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-49-字母异位词分组"><a href="#LeetCode-49-字母异位词分组" class="headerlink" title="LeetCode-49.字母异位词分组"></a>LeetCode-49.字母异位词分组</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="排序数组分类"><a href="#排序数组分类" class="headerlink" title="排序数组分类"></a>排序数组分类</h4><ul><li><p>当且仅当它们的排序字符串相等时，两个字符串是字母异位词。</p></li><li><p>我们使用一个Map记录排序字符串和数组位置之间的映射关系即可</p></li><li><p>时间复杂度为$O(NKlogK)$，其中$N$是字符串个数，$K$是字符串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ts;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            ts = str;</span><br><span class="line">            sort(ts.<span class="built_in">begin</span>(),ts.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(!Dict.count(ts))&#123;</span><br><span class="line">                Dict[ts] = ans.<span class="built_in">size</span>();</span><br><span class="line">                ans.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="number">1</span>, str));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[Dict[ts]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="按计数分类"><a href="#按计数分类" class="headerlink" title="按计数分类"></a>按计数分类</h4><ul><li><p>当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。</p></li><li><p>我们使用一个长度为26的字符串记录每个字母出现的次数，用一个Map记录出现次数字符串和数组位置之间的映射关系即可</p></li><li><p>时间复杂度为$O(NK)$，其中$N$是字符串个数，$K$是字符串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> Loc_count;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; Dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : strs)&#123;</span><br><span class="line">            Loc_count = <span class="built_in">string</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : str)&#123;</span><br><span class="line">                ++Loc_count[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Dict.count(Loc_count))&#123;</span><br><span class="line">                Dict[Loc_count] = ans.<span class="built_in">size</span>();</span><br><span class="line">                ans.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="number">1</span>, str));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[Dict[Loc_count]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-49-字母异位词分组&quot;&gt;&lt;a href=&quot;#LeetCode-49-字母异位词分组&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-49.字母异位词分组&quot;&gt;&lt;/a&gt;LeetCode-49.字母异位词分组&lt;/h2&gt;&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;quot;bat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有输入均为小写字母。&lt;/li&gt;
&lt;li&gt;不考虑答案输出的顺序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-215.数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2020/06/14/LeetCode-215/"/>
    <id>http://yoursite.com/2020/06/14/LeetCode-215/</id>
    <published>2020-06-14T12:50:42.000Z</published>
    <updated>2020-06-14T13:36:21.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-215-数组中的第K个最大元素"><a href="#LeetCode-215-数组中的第K个最大元素" class="headerlink" title="LeetCode-215.数组中的第K个最大元素"></a>LeetCode-215.数组中的第K个最大元素</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>我们可以使用堆排对数组排序，然后再找到第K大元素，复杂度为$O(nlog(n))$</p></li><li><p>我们也可以使用快排的思想，每一轮剪枝一部分数据来找到第K大元素，复杂度最优为$O(n)$，最坏为$O(n^2)$</p></li><li><p>我们还可以使用分治的思想来解决这个问题，分治算法当然在达到一个非常小的规模时，会能直接或用很简单的方法得出结论，但是，其实，问题规模在达到某个阈值的时候，用直接朴素的方法解决这个规模的问题的效率，已经比继续分治的算法高了。这个时候，我们在这个阈值就开始选择朴素的方法才是最明智的选择。</p></li><li><p>基本思路：</p><ol><li>当规模小于阈值时，直接用排序算法返回结果。</li><li>当n大于阈值时，把n个元素划分为5个元素一组的n/5组，排除剩余元素（不会有影响，这里只是为了求中项mm），分别排序，然后挑出每一组元素的中间值，再在所有的中间值中，递归调用本算法，挑出中间值mm。</li><li>把元素划分为$A1、A2、A3$三组，分别包含大于、等于、小于$mm$的元素。</li><li>分三种情况：<ol><li>若A1的元素数量大于等于K，即第K个元素在第一组内：在$A1$中递归查找第k小元素。</li><li>若A1、A2元素个数之和大于等于K，即中项mm为第K个元素：返回mm</li><li>否则，第K个元素在第三组：在A3中递归寻找第（$k$-|$A1、A2$元素数量之和|）大元素。</li></ol></li></ol></li><li><p>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入  n 个元素的数组 A[1...n] 和整数 k，1 ≤ k ≤ n  </span><br><span class="line">输出  A 中的第 k 小元素  </span><br><span class="line">   </span><br><span class="line">算法描述 select(A, low, high, k)  </span><br><span class="line">1. n ← high - low----（Θ(1)）  </span><br><span class="line">2. if  n &lt; 44 then 将 sort(A[low...high]) return (A[k-1])----（Θ(1)）</span><br><span class="line">3. 令 q &#x3D;  ⌊n&#x2F;5⌋。将 A 分成 q 组，每组5个元素。如果5不整除 n ，则排除剩余的元素。----（Θ(n)）  </span><br><span class="line">4. 将 q 组中的每一组单独排序，找出中项。所有中项的集合为 M。----（Θ(n)）  </span><br><span class="line">5. mm ← select(M, 0, q,  ⌈q&#x2F;2⌉)   &#123; mm 为中项集合的中项 &#125; ----T(n&#x2F;5)  </span><br><span class="line">6. 将 A[low...high] 分成三组----（Θ(n)）  </span><br><span class="line">    A1 &#x3D; &#123; a | a &gt; mm &#125;  </span><br><span class="line">    A2 &#x3D; &#123; a | a &#x3D; mm &#125;  </span><br><span class="line">    A3 &#x3D; &#123; a | a &lt; mm &#125;  </span><br><span class="line">7. case  </span><br><span class="line">    |A1| ≥ k : return select(A1, 0, |A1|, k)  </span><br><span class="line">    |A1| + |A2| ≥ k : return mm  </span><br><span class="line">    |A1| + |A2| &lt; k : return select(A3, 0, |A3|, k - |A1| - |A2|)  </span><br><span class="line">8. end case</span><br></pre></td></tr></table></figure></li><li><p>算法分析：</p><ul><li><p>第1-6步的复杂度都很容易理解，我们着重讨论第7步的算法复杂度。</p><p><img src="/2020/06/14/LeetCode-215/webp" alt="img"></p></li><li><p>上图是处理到第5步后的元素，从左到右按各组中项降序（图解是求最小值的，所以要反过来看）排列，每组5个元素从下到上按降序排列。我们需要知道的是第7步时候问题的规模，即$A1、A3$这两个数组的规模。上图中我们可以看到$W$区的元素都是小于或等于$mm$的，令$A1’$表示小于或等于$mm$的元素的集合，显然W会是$A1’$的子集，即A1’的元素数量大于等于$W$的元素数量。于是我们有下面这个式子：</p><script type="math/tex; mode=display">|A1’| \ge 3 \lceil \lfloor n/5 \rfloor /2 \rceil \ge \frac{3}{2} \lfloor n/5 \rfloor</script><p>其中$A3$的数量 = $n-A1’$的数量，于是我么可以得到下面的式子：</p><script type="math/tex; mode=display">| A_3 | \le n - \frac{3}{2} \lfloor n/5 \rfloor \le n - \frac{3}{2} (\frac{n-4}{5}) = n - 0.3n + 1.2 = 0.7n + 1.2</script><p>至此，我们知道$A1、A3$的上界是$0.7n+1.2$，步骤7耗费的时间$T(0.7n+1.2)$。到这里还没说到44阈值的由来，这是因为我们希望去掉1.2这个常数，于是引入底函数帮忙：</p><script type="math/tex; mode=display">0.7n + 1.2 \le \lfloor 0.75n \rfloor</script><p>即</p><script type="math/tex; mode=display">0.7n + 1.2 \le  0.75n - 1</script><p>解不等式可得n&gt;=44。阈值44诞生了！！！现在我们还有了算法运行时间的递推式：可以算出来$T(n)=Θ(n)$。对于求中项的题目也是同样的解法，就是找第（n+1）/2个元素（奇数）和第n/2、n/2+1个元素（偶数）。需要注意，这个算法的常数倍数（比如c）都是很大的。</p></li></ul></li><li><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty() || k &gt; nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> select(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>(), k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = high - low;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">44</span>)&#123;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + low, nums.<span class="built_in">begin</span>() + high, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">return</span> nums[low + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; M;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = low;i + <span class="number">5</span> &lt; high;i += <span class="number">5</span>)&#123;</span><br><span class="line">            sort(nums.<span class="built_in">begin</span>() + i,nums.<span class="built_in">begin</span>() + i + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            M.push_back(nums[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mm = select(M, <span class="number">0</span>, M.<span class="built_in">size</span>(), M.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A1,A2,A3;</span><br><span class="line">        <span class="keyword">for</span>(i = low; i &lt; high;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mm)</span><br><span class="line">                A1.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == mm)</span><br><span class="line">                A2.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A3.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A1.<span class="built_in">size</span>() &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> select(A1, <span class="number">0</span>, A1.<span class="built_in">size</span>(), k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A1.<span class="built_in">size</span>() + A2.<span class="built_in">size</span>() &gt;= k)</span><br><span class="line">            <span class="keyword">return</span> mm;</span><br><span class="line">        <span class="keyword">return</span> select(A3, <span class="number">0</span>, A3.<span class="built_in">size</span>(), k - A1.<span class="built_in">size</span>() - A2.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-215-数组中的第K个最大元素&quot;&gt;&lt;a href=&quot;#LeetCode-215-数组中的第K个最大元素&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-215.数组中的第K个最大元素&quot;&gt;&lt;/a&gt;LeetCode-215.数组中的第K个最大元素&lt;/h2&gt;&lt;p&gt;在未排序的数组中找到第 &lt;strong&gt;k&lt;/strong&gt; 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,1,5,6,4] 和 k &amp;#x3D; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Boston房价数据集实验分析</title>
    <link href="http://yoursite.com/2020/06/13/PaperExamRecord-Boston/"/>
    <id>http://yoursite.com/2020/06/13/PaperExamRecord-Boston/</id>
    <published>2020-06-13T02:21:58.000Z</published>
    <updated>2020-06-15T15:38:31.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Boston房价数据集实验分析"><a href="#Boston房价数据集实验分析" class="headerlink" title="Boston房价数据集实验分析"></a>Boston房价数据集实验分析</h2><h3 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h3><ul><li>波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。</li></ul><div class="table-container"><table><thead><tr><th>No</th><th>属性</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>1</td><td>CRIM</td><td>Float</td><td>城镇人均犯罪率</td></tr><tr><td>2</td><td>ZN</td><td>Float</td><td>占地面积超过2.5万平方英尺的住宅用地比例</td></tr><tr><td>3</td><td>INDUS</td><td>Float</td><td>城镇非零售业务地区的比例</td></tr><tr><td>4</td><td>CHAS</td><td>Integer</td><td>查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)</td></tr><tr><td>5</td><td>NOX</td><td>Float</td><td>一氧化氮浓度（每1000万份）</td></tr><tr><td>6</td><td>RM</td><td>Float</td><td>平均每居民房数</td></tr><tr><td>7</td><td>AGE</td><td>Float</td><td>在1940年之前建成的所有者占用单位的比例</td></tr><tr><td>8</td><td>DIS</td><td>Float</td><td>与五个波士顿就业中心的加权距离</td></tr><tr><td>9</td><td>RAD</td><td>Integer</td><td>辐射状公路的可达性指数</td></tr><tr><td>10</td><td>TAX</td><td>Float</td><td>每10,000美元的全额物业税率</td></tr><tr><td>11</td><td>PTRATIO</td><td>Float</td><td>城镇师生比例</td></tr><tr><td>12</td><td>B</td><td>Float</td><td>1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例</td></tr><tr><td>13</td><td>LSTAT</td><td>Float</td><td>人口中地位较低人群的百分数</td></tr><tr><td>14</td><td>MEDV</td><td>Float</td><td>（目标变量/类别属性）以1000美元计算的自有住房的中位数</td></tr></tbody></table></div><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ul><li>分析Boston地区房价相关的因素</li></ul><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><ul><li>使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化</li></ul><h3 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h3><ul><li>使用分片算法将投影分片，并结合分片的主要维度分布来分析和Boston地区房价相关的因素</li></ul><a id="more"></a><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><ul><li>图1是Boston房价数据集使用t-SNE降维到2维后生成的散点图，其中颜色编码该区域房价中间值，颜色越深该区域房价中间值越高。</li></ul><p><img src="/2020/06/13/PaperExamRecord-Boston/t-SNE-price.png" alt="Boston-tSNE图"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图1-Boston房价分布</center> <h4 id="t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系"><a href="#t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系" class="headerlink" title="t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系"></a>t-SNE生成的投影，投影中不同聚类之间的距离不能准确表示聚类之间的近邻关系</h4><ul><li><p>图2为把投影划分成两个分片的情况，这里的分片呈现出一个问题，在投影中离得很远的两个聚类，却在原始空间中为近邻关系。<img src="/2020/06/13/PaperExamRecord-Boston/Div-2.png" alt="Div-2"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图2-两分片分布</center> </li><li><p>为了进一步观察，我们把长条形的分片（1008 -&gt; 1004,699）分裂，进一步观察分片之间的拓扑关系（图3）。其中1004是蓝色（上部）的分片，699是灰色（下部）的分片，结合拓扑关系图，我们可以发现在投影中距离很远的1004分片和699分片之间存在近邻关系，而1004分片与更近的1009分片之间却不存在近邻关系。<img src="/2020/06/13/PaperExamRecord-Boston/Div-3.png" alt="Div-3"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图3-三分片分布</center> </li></ul><h4 id="Boston房价和社区人均犯罪率（1）有关"><a href="#Boston房价和社区人均犯罪率（1）有关" class="headerlink" title="Boston房价和社区人均犯罪率（1）有关"></a>Boston房价和社区人均犯罪率（1）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的犯罪率（1）相关性很低，并且1009分片的房价明显要比另外两个分片高（总体来看区域颜色更深）</p></li><li><p>因此我们提出了一个猜想，Boston房价和犯罪率（1）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的左下方社区的犯罪率越大（颜色编码相关性正负，绿色表示正相关性，蓝色表示负相关性），结合图1我们可以发现分片699中左下方方向上颜色更浅（即房价更低）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的右上方社区的犯罪率越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>因为分片1009的犯罪率相关性很低（即投影结果与犯罪率维度无关），所以我们决定直接观察分片1009的原始数据，我们发现分片1009中犯罪率都保持在2%以下，而另外两个分片（1004,699）的犯罪率在0%~70%之间浮动。这也符合我们符合我们的对犯罪率的普遍认识。</p></li><li><p>因为多个分片中存在相同的模式，因此我们认为这个假设成立</p></li></ul></li></ul><h4 id="Boston房价和社区底层人口率（13）有关"><a href="#Boston房价和社区底层人口率（13）有关" class="headerlink" title="Boston房价和社区底层人口率（13）有关"></a>Boston房价和社区底层人口率（13）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的底层人口率（13）相关性较低低，并且1009分片的房价明显要比另外两个分片高</p></li><li><p>因此我们提出了一个猜想，Boston房价和底层人口率（13）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的左上方社区的底层人口率（13）越大，结合图1我们可以发现分片699中左上方方向上颜色更浅（即房价更低）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的右上方社区的底层人口率（13）越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>因为分片1009的底层人口率（13）相关性较低，并且通过观察分片的原始数据我们发现其中还是存在一些社区的底层人口率（13）较高的，因此我们分裂了分片1009（1009-&gt;1013,994)。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/Div-4.png" alt="image-20200613205811401"></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图4-四分片分布</center> </li><li><p>从分片994（图4中间位置蓝色的分片）的维度分布图中我们观察到，越靠近分片994的右上方社区的底层人口率（13）越大，结合图1我们可以发现分片1004中右上方方向上颜色更浅（即房价更低）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/994.png" alt="image-20200613210149098"></p></li><li><p>因为多个分片中存在相同的模式，因此我们认为这个假设成立</p></li></ul></li></ul><h4 id="Boston房价和社区黑人数量（12）有关"><a href="#Boston房价和社区黑人数量（12）有关" class="headerlink" title="Boston房价和社区黑人数量（12）有关"></a>Boston房价和社区黑人数量（12）有关</h4><ul><li><p>结合图1和图3，我们发现三个分片中，只有1009分片的黑人数量（12）相关性较低低，并且1009分片的房价明显要比另外两个分片高</p></li><li><p>因此我们提出了一个猜想，Boston房价和黑人数量（12）有关，为此我们做了相关分析</p><ul><li><p>从分片699（图3下面的分片）的维度分布图中我们观察到，越靠近分片699的右上方社区的黑人数量（12）越多，结合图1我们可以发现分片699中右上方方向上颜色更深（即房价更高）。</p><p><img src="/2020/06/13/PaperExamRecord-Boston/699.png" alt="image-20200613203604257"></p></li><li><p>从分片1004（图3上面的分片）的维度分布图中我们观察到，越靠近分片1004的左上方社区的黑人数量（12）越多，结合图1我们可以发现分片1004中左上方方向上颜色几乎不变（即房价变化不大）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/1004.png" alt="image-20200613204608260"></p></li><li><p>从分片994（图4中间位置蓝色的分片）的维度分布图中我们观察到，越靠近分片994的左上方社区的黑人数量（12）越多，结合图1我们可以发现分片1004中左上方方向上颜色几乎不变（即房价变化不大）</p><p><img src="/2020/06/13/PaperExamRecord-Boston/994.png" alt="image-20200613210149098"></p></li><li><p>因为多个分片中不存在相同的模式，因此我们认为这个假设不成立</p></li></ul></li></ul><h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ul><li>通过实验分析：<ul><li>我们发现t-SNE投影中聚类的间距不能准确表达聚类之间的近邻关系</li><li>我们发现Boston房价：<ul><li>和社区人均犯罪率（1）有关</li><li>和社区底层人口率（13）有关</li><li>和社区黑人数量（12）无关</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Boston房价数据集实验分析&quot;&gt;&lt;a href=&quot;#Boston房价数据集实验分析&quot; class=&quot;headerlink&quot; title=&quot;Boston房价数据集实验分析&quot;&gt;&lt;/a&gt;Boston房价数据集实验分析&lt;/h2&gt;&lt;h3 id=&quot;数据介绍&quot;&gt;&lt;a href=&quot;#数据介绍&quot; class=&quot;headerlink&quot; title=&quot;数据介绍&quot;&gt;&lt;/a&gt;数据介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;波士顿房价数据集是统计的20世纪70年代中期波士顿郊区房价的中位数，统计了当时教区部分的犯罪率、房产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;字段描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;CRIM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇人均犯罪率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ZN&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;占地面积超过2.5万平方英尺的住宅用地比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;INDUS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇非零售业务地区的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;CHAS&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;查尔斯河虚拟变量 (= 1 如果土地在河边；否则是0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;NOX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;一氧化氮浓度（每1000万份）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;RM&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;平均每居民房数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;AGE&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;在1940年之前建成的所有者占用单位的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DIS&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;与五个波士顿就业中心的加权距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;RAD&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;辐射状公路的可达性指数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;TAX&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;每10,000美元的全额物业税率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;PTRATIO&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;城镇师生比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;1000（Bk - 0.63）^ 2其中Bk是城镇黑人的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;LSTAT&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;人口中地位较低人群的百分数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;MEDV&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;（目标变量/类别属性）以1000美元计算的自有住房的中位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分析Boston地区房价相关的因素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实验设计&quot;&gt;&lt;a href=&quot;#实验设计&quot; class=&quot;headerlink&quot; title=&quot;实验设计&quot;&gt;&lt;/a&gt;实验设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用t-SNE将Boston房价数据降维到2维可视空间，并使用散点图可视化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何验证&quot;&gt;&lt;a href=&quot;#如何验证&quot; class=&quot;headerlink&quot; title=&quot;如何验证&quot;&gt;&lt;/a&gt;如何验证&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用分片算法将投影分片，并结合分片的主要维度分布来分析和Boston地区房价相关的因素&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="论文实验" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="局部线性近似" scheme="http://yoursite.com/tags/%E5%B1%80%E9%83%A8%E7%BA%BF%E6%80%A7%E8%BF%91%E4%BC%BC/"/>
    
      <category term="Boston" scheme="http://yoursite.com/tags/Boston/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-102.二叉树的层序遍历</title>
    <link href="http://yoursite.com/2020/06/13/LeetCode-102/"/>
    <id>http://yoursite.com/2020/06/13/LeetCode-102/</id>
    <published>2020-06-13T00:27:10.000Z</published>
    <updated>2020-06-13T00:33:25.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode-102.二叉树的层序遍历"></a>LeetCode-102.二叉树的层序遍历</h2><p>给你一个二叉树，请你返回其按<strong>层序遍历</strong>得到的节点值。（即逐层地，从左到右访问所有节点）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>二叉树：[3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7 返回其层次遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>以层序遍历，所以我们使用一个<strong>queue</strong>来记录遍历序列。</li><li>又因为每一次要在同一批次遍历，所以我们使用两个<strong>int</strong>来记录，当前批次要遍历的节点个数，和下一个批次要遍历的节点个数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> now,next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        q.push(root);</span><br><span class="line">        now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(now)&#123;</span><br><span class="line">                tmp.push_back(q.front()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;left)&#123;</span><br><span class="line">                    q.push(q.front()-&gt;left);</span><br><span class="line">                    ++next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(q.front()-&gt;right)&#123;</span><br><span class="line">                    q.push(q.front()-&gt;right);</span><br><span class="line">                    ++next;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">                --now;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(tmp);</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-102-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#LeetCode-102-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-102.二叉树的层序遍历&quot;&gt;&lt;/a&gt;LeetCode-102.二叉树的层序遍历&lt;/h2&gt;&lt;p&gt;给你一个二叉树，请你返回其按&lt;strong&gt;层序遍历&lt;/strong&gt;得到的节点值。（即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7 
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="广度优先遍历" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-739.每日温度</title>
    <link href="http://yoursite.com/2020/06/12/LeetCode-739/"/>
    <id>http://yoursite.com/2020/06/12/LeetCode-739/</id>
    <published>2020-06-12T03:14:21.000Z</published>
    <updated>2020-06-12T03:23:22.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-739-每日温度"><a href="#LeetCode-739-每日温度" class="headerlink" title="LeetCode-739.每日温度"></a>LeetCode-739.每日温度</h2><p>请根据每日 <strong>气温</strong> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <strong>0</strong> 来代替。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[73, 74, 75, 71, 69, 72, 76, 73]</span><br><span class="line">输出：[1, 1, 4, 2, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong>气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>要找到某一天之后要想观测到更高的气温，至少需要等待的天数</li><li>我们可以使用单调递减栈来保存还没有找到的日期，因此栈顶是没有找到的日期中温度最低的那一天</li><li>每遍历新的一天，我们就把栈中温度比今天低的pop出栈，并记录今天为它们更高气温的一天</li><li>遍历完所有日期后，还没有出栈的日期就是找不到气温更高的日期</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i,len = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(len,<span class="number">0</span>)</span></span>;<span class="comment">//默认值设为0，那么最后我们就不需要再去处理没有找到更高气温的日期了</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; T[i] &gt; T[s.top()])&#123;</span><br><span class="line">                ans[s.top()] = i - s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-739-每日温度&quot;&gt;&lt;a href=&quot;#LeetCode-739-每日温度&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-739.每日温度&quot;&gt;&lt;/a&gt;LeetCode-739.每日温度&lt;/h2&gt;&lt;p&gt;请根据每日 &lt;strong&gt;气温&lt;/strong&gt; 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 &lt;strong&gt;0&lt;/strong&gt; 来代替。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[73, 74, 75, 71, 69, 72, 76, 73]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1, 1, 4, 2, 1, 1, 0, 0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11.盛最多水的容器</title>
    <link href="http://yoursite.com/2020/06/11/LeetCode-11/"/>
    <id>http://yoursite.com/2020/06/11/LeetCode-11/</id>
    <published>2020-06-11T03:03:16.000Z</published>
    <updated>2020-06-11T03:25:09.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode-11.盛最多水的容器"></a>LeetCode-11.盛最多水的容器</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="/2020/06/11/LeetCode-11/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这道题我们可以用贪心的思想来做：<ol><li>一开始我们选择最左和最右两条边作为容器，并计算容积</li><li>然后我们需要选择舍弃其中一条边，因为容积和最小边相关，所以我们选择舍弃最小边</li><li>重复1~2，并记录最大容积</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int i,j,ans,high;</span><br><span class="line">        for(i &#x3D; 0,j &#x3D; height.size()-1,ans &#x3D; 0;i !&#x3D; j;)&#123;</span><br><span class="line">            high &#x3D; min(height[i],height[j]);</span><br><span class="line">            ans &#x3D; max(ans,high * (j - i));</span><br><span class="line">            if(height[i] &lt; height[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#LeetCode-11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-11.盛最多水的容器&quot;&gt;&lt;/a&gt;LeetCode-11.盛最多水的容器&lt;/h2&gt;&lt;p&gt;给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;你不能倾斜容器，且 n 的值至少为 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/11/LeetCode-11/question_11.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[1,8,6,2,5,4,8,3,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-236.二叉树的最近公共祖先</title>
    <link href="http://yoursite.com/2020/06/10/LeetCode-236/"/>
    <id>http://yoursite.com/2020/06/10/LeetCode-236/</id>
    <published>2020-06-10T06:16:52.000Z</published>
    <updated>2020-06-10T07:34:53.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-236-二叉树的最近公共祖先"><a href="#LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="LeetCode-236.二叉树的最近公共祖先"></a>LeetCode-236.二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="/2020/06/10/LeetCode-236/binarytree.png" alt="img"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ol><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>p，q两点只有以下几种分布：<ol><li>p或者q点其中一个是父节点：<ol><li>另一个在其左子树中</li><li>另一个在其右子树中</li></ol></li><li>p或者q中一个在左子树中，另一个在右子树中</li></ol></li><li>因此我们遍历时只要注意这两种情况即可</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        func(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(TreeNode *root,TreeNode *&amp;p,TreeNode *&amp;q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lb,rb;</span><br><span class="line">        lb = func(root-&gt;left,p,q);</span><br><span class="line">        rb = func(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>((lb &amp;&amp; rb) || ((root == p || root == q) &amp;&amp; (lb || rb)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lb || rb || root == p || root == q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#LeetCode-236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-236.二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;LeetCode-236.二叉树的最近公共祖先&lt;/h2&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;/p&gt;
&lt;p&gt;例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/10/LeetCode-236/binarytree.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: root &amp;#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &amp;#x3D; 5, q &amp;#x3D; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 节点 5 和节点 1 的最近公共祖先是节点 3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: root &amp;#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &amp;#x3D; 5, q &amp;#x3D; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有节点的值都是唯一的。&lt;/li&gt;
&lt;li&gt;p、q 为不同节点且均存在于给定的二叉树中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-406.根据身高重建队列</title>
    <link href="http://yoursite.com/2020/06/09/LeetCode-406/"/>
    <id>http://yoursite.com/2020/06/09/LeetCode-406/</id>
    <published>2020-06-09T06:58:07.000Z</published>
    <updated>2020-06-21T04:34:21.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-406-根据身高重建队列"><a href="#LeetCode-406-根据身高重建队列" class="headerlink" title="LeetCode-406.根据身高重建队列"></a>LeetCode-406.根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高<strong>大于或等于</strong>h的人数。 编写一个算法来重建这个队列。</p><p><strong>注意：</strong>总人数少于1100人。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>对于每个人，会影响其k值的只有<strong>大于等于</strong>其h值的人</li><li>因此，我们可以按照以下思路完成本题：<ol><li>首先，对数组按h值进行排序（从大到小），h值相同的按k值排序（从小到大）</li><li>然后把排序好的数组按k值插入到返回结果中（因为后插入的值，不会影响先插入的值）</li></ol></li><li>因为在这里频繁在容器中间部分插入，所以我们应该使用<strong>list</strong>而不是<strong>vector</strong><ol><li>在<strong>list</strong>中，内存不是连续分布的，因此需要使用<strong>advance</strong>函数来找到对应的插入位置</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">reconstructQueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        sort(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i,len = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i != len;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = ans.<span class="built_in">begin</span>();</span><br><span class="line">            advance(pos,people[i][<span class="number">1</span>]);</span><br><span class="line">            ans.insert(pos,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-406-根据身高重建队列&quot;&gt;&lt;a href=&quot;#LeetCode-406-根据身高重建队列&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-406.根据身高重建队列&quot;&gt;&lt;/a&gt;LeetCode-406.根据身高重建队列&lt;/h2&gt;&lt;p&gt;假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高&lt;strong&gt;大于或等于&lt;/strong&gt;h的人数。 编写一个算法来重建这个队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;总人数少于1100人。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-148.排序链表</title>
    <link href="http://yoursite.com/2020/06/08/LeetCode-148/"/>
    <id>http://yoursite.com/2020/06/08/LeetCode-148/</id>
    <published>2020-06-08T15:28:52.000Z</published>
    <updated>2020-06-08T15:35:53.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-148-排序链表"><a href="#LeetCode-148-排序链表" class="headerlink" title="LeetCode-148.排序链表"></a>LeetCode-148.排序链表</h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line"></span><br><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>因为时间复杂度为O(n log n)，所以我们要使用归并排序</li><li>因为空间复杂度为O(1)，所以我们不能使用递归方法</li><li>那么我们要非递归的完成链表的归并排序，我把算法分成三部分<ol><li>截断链表cut(head,count)：截断从head开始长度为count的链表，并返回链表尾的下一个元素。</li><li>合并链表marge(list1,list2)：合并两个有序链表，插入排序即可</li><li>我们用count表示归并的链表长度，当count&lt;总链表长度时，排序完成。</li><li>在归并的过程中，我们要用left和right来保存归并区域之前和之后的节点，在归并链表排序后，再把归并链表插入回原链表。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count,length = <span class="number">0</span>;</span><br><span class="line">        ListNode *tmp = head,*Head = <span class="keyword">new</span> ListNode(<span class="number">0</span>),*left = <span class="literal">nullptr</span>,*right = <span class="literal">nullptr</span>,*l1 = <span class="literal">nullptr</span>,*l2 = <span class="literal">nullptr</span>,*tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(++length &amp;&amp; tmp) tmp = tmp-&gt;next;</span><br><span class="line">        Head-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(count = <span class="number">1</span>; count &lt; length;count *= <span class="number">2</span>)&#123;</span><br><span class="line">            left = Head;</span><br><span class="line">            <span class="keyword">while</span>(left-&gt;next)&#123;</span><br><span class="line">                l1 = left-&gt;next;</span><br><span class="line">                l2 = cut(l1,count);</span><br><span class="line">                right = cut(l2,count);</span><br><span class="line">                l1 = marge(l1,l2);</span><br><span class="line">                left-&gt;next = l1;</span><br><span class="line">                tail = l1;</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next)&#123;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next = right;</span><br><span class="line">                left = tail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ListNode *tail = <span class="literal">nullptr</span>;</span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(--length &amp;&amp; head)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;</span><br><span class="line">            tail = head-&gt;next;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *l1,ListNode *l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ListNode *head = <span class="literal">nullptr</span>,*tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        head = <span class="literal">nullptr</span>,tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">            head = tmp = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = tmp = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">            tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">            tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LeetCode-148-排序链表&quot;&gt;&lt;a href=&quot;#LeetCode-148-排序链表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode-148.排序链表&quot;&gt;&lt;/a&gt;LeetCode-148.排序链表&lt;/h2&gt;&lt;p&gt;在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
