<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog</title>
  
  <subtitle>一个游戏开发工程师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-26T05:49:26.704Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HaowenZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPt-SNE 论文重构与分析</title>
    <link href="http://yoursite.com/2020/04/26/GPt-SNE%20%E8%AE%BA%E6%96%87%E9%87%8D%E6%9E%84%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/04/26/GPt-SNE%20%E8%AE%BA%E6%96%87%E9%87%8D%E6%9E%84%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2020-04-26T05:47:15.000Z</published>
    <updated>2020-04-26T05:49:26.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPt-SNE-论文重构与分析"><a href="#GPt-SNE-论文重构与分析" class="headerlink" title="GPt-SNE 论文重构与分析"></a>GPt-SNE 论文重构与分析</h1><h2 id="1-Introduction："><a href="#1-Introduction：" class="headerlink" title="1.Introduction："></a>1.Introduction：</h2><ul><li>首先直接指出目前的可视化的作用和目前可视化方法的痛点<ul><li>痛点：<ul><li>最先进的可视化方法往往是黑盒方法，无法洞察可视化如何编码数据的原始特征</li><li>其他方法如Autoencoder和pt-SNE使用复杂神经网络，对人来说依然难以理解</li></ul></li><li>分析：直接指出可视化的痛点，也是一种很好的表达，观点看起来很清晰，之前自己的写作顾虑太多，应该就事论事。其实作者的观点和我是一致的，但是我一没讲清楚，二是不够自信，过多的自我怀疑对工作毫无益处。</li></ul></li><li>接着指出有良好可解释性的线性方法，在降维上固有的局限性：<ul><li>痛点：线性方法仅通过对原始特征的线性组合来编码可视化</li><li>分析：还是不够自信吧，我们写的太拘谨了，其实我自己写作的时候，就一直在思考为什么不去直接指出线性方法的局限性，我觉得要多坚持自己的想法。</li></ul></li><li>然后介绍基于树的GP（genetic programming）方法，该方法常用于FC（feature construction）中的降维，并且是公认可解释的。最后明确指出，GP方法还并未被用于生成可解释的降维模型即可解释的的可视化。<ul><li>分析：觉得自己调研的不够充分，毕竟我都没收集到GP方法。论文写法上来说，我觉得简单直接，我在写作中也要以他为模板，即使技术方案简单也没什么好扭捏的。</li></ul></li><li>接着给出了他们之前的工作GP-MaL（该工作使用GP方法进行降维），并指出了之前工作存在的一些问题。<ul><li>分析：这样写，一方面阐述了作者在GP方法上是有底蕴的，让人更相信作者的表达。我觉得我在写作的时候可以多引用作者的论文和表达，体现出我在该研究方向上的理解。</li></ul></li><li>然后给出了论文的技术方案：多目标GP方法。<ul><li>分析：Introduction通过前两段才讲清楚问题，但是并没有让人觉得冗余。而我总是追求一句话讲清楚，为了达到这个目标，就在非线性方法的问题和线性方法的问题中做取舍，最后不伦不类，要多反思，不能僵化自己的思维。</li></ul></li><li>最后总结了论文的贡献：<ul><li>贡献：<ul><li>Propose a holistic set of functions and terminals for creating powerful and interpretable models for visualisation; </li><li>Design a multi-objective approach to allow for the evolution of a solution front containing visualisations representing different levels of quality and complexity; </li><li>Compare the quality and interpretability of the evolved visualisations with those produced by state-of-the-art visualisation methods on a range of datasets; </li><li>Perform an in-depth analysis of the trade-off between visualisation quality and tree complexity to demonstrate the unique advantages of the proposed approach.</li></ul></li><li>分析：我觉得贡献部分写的很平实，我在写贡献部分的时候也要平实，不要故弄玄虚。</li></ul></li></ul><h2 id="2-BackGround"><a href="#2-BackGround" class="headerlink" title="2.BackGround"></a>2.BackGround</h2><ul><li>Dimensionality Reduction：降维是一种通过减少数据集的特征/属性数量来提高理解和性能的过程，随着数据集变得越来越大，深层神经网络变得越来越不可解释，其重要性也在不断增加。解决这个问题的常用技术包括FS（feature select）和FC，他们分别通过删除不需要的特征或创建更少、更复杂的元特征来减少特征空间。GP方法由于其功能性和可解释性而被证明是一种适合FC问题的方法。流形学习（非线性降维）可以被看作是一种无监督的FC方法，其任务是建立一组表示高维特征空间中存在的非线性流形的特征。实现这一任务的一种方法是尝试构建一个函数，将高维空间映射到低维流形；这种方法可以在两者之间提供可理解的映射。<ul><li>分析：首先论文简单介绍了降维的意义和目标。与之相比我写的相关工作太冗余了，全都是已有技术的堆砌，没有紧扣主题且逻辑松散。其次论文对流形学习的介绍，用简单明了的语言就把流形学习的意义和目的讲清楚了。我在写作中要多比对自己和论文的表达。</li></ul></li><li>Machine Learning for Performing Visualisation:该段从机器学习的角度分析了常用的可视化方法，如FS和PCA，存在的局限性（除了简单的低维数据外，线性转换无法清晰地显示数据集中的任何低维流形/结构）。而创建最优非线性变化是一个NP难问题，因此提出了许多基于损失函数的非线性降维方法（ISOMAP，LLE）。最后提到了t-SNE，作者认为这是目前最成功的技术（当然，作者这么写的主要原因是作者的模型基于t-SNE），并对t-SNE进行了较为详细的介绍。<ul><li>分析：给我的感觉就是详略得当，既能感受到作者在可视化领域和机器学习领域上的积累，又写的很清爽，让人读起来很轻松。相比之下，我写的东西，要不就是全部都详写，要不就是全部都略写，主要还是自己在相关领域的积累太浅，不能把握文章的重点，要在这方面多花功夫。</li></ul></li><li>Multi-objective Optimisation：这部分主要介绍了MO（Multi-objective Optimisation）方法，当一个问题本质上有两个（或多个）冲突目标时使用的一种技术，在这两个目标之间必须通过问题的解决方案进行权衡。在这种情况下，解决方案的质量通常与其他解决方案的目标函数值有关。而目前最流行的的MO方法就是EC方法，这也是论文所采用的方法。<ul><li>分析：我在写作过程中没有了解过MO方法，所以还需要进一步深入。从写作上来说，我觉得讲的还是很清晰的，虽然我看完不知道MO方法的细节实现，但是为什么用MO方法，以及MO方法的目的，以及作者如何实现MO方法都已经了解了。所以我在介绍相对冷门的技术的时，也要这样抓住重点来讲。</li></ul></li><li>Related Work：作者把相关工作分成了两部分，一部分是GP方法在流形学习和可视化上的应用，另一部分介绍了其它与可解释性相关的工作。<ul><li>因为作者就是第一个提出将GP方法用于在流形学习，所以这一部分写的非常的自信。其中提到了三个优化目标：可分类性，视觉可解释性，语义可解释性。</li><li>介绍了参数t-SNE（参数t-SNE是t-SNE的一种变体，它允许在将来的样本上重用学习到的t-SNE表示。 参数化t-SNE使用受限的Boltzmann机器构造从高维空间到低维空间的映射，以构建预训练的前馈神经网络模型。 该神经网络在最大的数据集上使用了10,000多个神经元，从而严重限制了解释该网络的潜力），Autoencoder（自动编码器[3]是另一种基于神经网络的方法，它试图将数据表示压缩到尽可能小的中间隐藏层中，以便可以从简洁的表示中重新创建原始数据。 为此，自动编码器使用许多大小不同的层来编码和解码数据。 这提供了与学习到的表示之间的映射，但是在给定节点数和完全连接的拓扑的情况下进行解释是不现实的），SOM（是无监督神经网络的一种变体，已用于可视化，但是权重的数量随维度而定，因此它们的可解释性受到非平凡数据集的限制）。并指出论文和已有增强可解释性方法的区别，已有方法（如DimReader）通过更改模型参数或数据实例来分析模型，而论文提出了一种可直接解释的降维模型。</li><li>分析：这部分内容可以作为我们解释非线性降维相关工作参考的模板，我们不应该为了分类而分类，要紧扣自己的工作，提出符合逻辑的分类，让读者的关注点一直保持在我们的工作上。通过这段，我们可以发现我们的工作和论文工作的区别，所以我认为我们的工作还是有价值的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GPt-SNE-论文重构与分析&quot;&gt;&lt;a href=&quot;#GPt-SNE-论文重构与分析&quot; class=&quot;headerlink&quot; title=&quot;GPt-SNE 论文重构与分析&quot;&gt;&lt;/a&gt;GPt-SNE 论文重构与分析&lt;/h1&gt;&lt;h2 id=&quot;1-Introductio
      
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="可理解性" scheme="http://yoursite.com/tags/%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7/"/>
    
      <category term="非线性降维" scheme="http://yoursite.com/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E9%99%8D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-23</title>
    <link href="http://yoursite.com/2020/04/26/LeetCode-23/"/>
    <id>http://yoursite.com/2020/04/26/LeetCode-23/</id>
    <published>2020-04-26T05:36:33.000Z</published>
    <updated>2020-04-26T05:48:49.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-23-合并K个排序链表"><a href="#LeetCode-23-合并K个排序链表" class="headerlink" title="LeetCode 23.合并K个排序链表"></a>LeetCode 23.合并K个排序链表</h1><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p>解题思路：</p><p>1.循环合并最后两个链表：花费时间168ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *a = <span class="literal">nullptr</span>,*b = <span class="literal">nullptr</span>,*c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(lists.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        b = lists.back();</span><br><span class="line">        lists.pop_back();</span><br><span class="line">        c = marge(a,b);</span><br><span class="line">        lists.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用分治法：耗时24ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">marge</span><span class="params">(ListNode *a,ListNode *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a || !b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(!a &amp;&amp; !b)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *tmp = <span class="literal">nullptr</span>,*next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;val &gt; b-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = b;</span><br><span class="line">        b = a;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = a;</span><br><span class="line">    <span class="keyword">while</span>(a-&gt;next &amp;&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;next-&gt;val &gt; b-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            next = a-&gt;next;</span><br><span class="line">            a-&gt;next = b;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">            a-&gt;next-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        next = a-&gt;next;</span><br><span class="line">        a-&gt;next = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">        a-&gt;next-&gt;next = next;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">margeFunc</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low+<span class="number">1</span> == high)</span><br><span class="line">    <span class="keyword">return</span> lists[low];</span><br><span class="line">    <span class="keyword">int</span> middle = (low+high)/<span class="number">2</span>;</span><br><span class="line">    ListNode *ls = margeFunc(lists,low,middle);</span><br><span class="line">    ListNode *rs = margeFunc(lists,middle,high);</span><br><span class="line">    ListNode *s = marge(ls,rs);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ans = <span class="literal">nullptr</span>;</span><br><span class="line">    ans = margeFunc(lists,<span class="number">0</span>,lists.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> lists.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用优先队列：耗时48ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.empty())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> comp = [](ListNode* &amp;a,ListNode* &amp;b)&#123;<span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(comp)&gt; que(comp);</span><br><span class="line">    ListNode *Head = <span class="literal">nullptr</span>,*temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i != lists.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists[i])</span><br><span class="line">        &#123;</span><br><span class="line">        que.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Head)</span><br><span class="line">        &#123;</span><br><span class="line">        Head = temp = que.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = que.top();</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">        que.push(temp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分需要注意，构造优先队列的第三参数时仿函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-23-合并K个排序链表&quot;&gt;&lt;a href=&quot;#LeetCode-23-合并K个排序链表&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 23.合并K个排序链表&quot;&gt;&lt;/a&gt;LeetCode 23.合并K个排序链表&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="优先队列" scheme="http://yoursite.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
